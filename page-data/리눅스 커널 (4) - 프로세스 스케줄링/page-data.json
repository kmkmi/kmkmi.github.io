{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/리눅스 커널 (4) - 프로세스 스케줄링/","result":{"data":{"site":{"siteMetadata":{"title":"KMKMI","author":"Kangmo Han"}},"markdownRemark":{"id":"82491f5c-0fb1-5948-8f4b-05b5db1ff0ee","html":"<h1>프로세스 스케줄러</h1>\n<p>어떤 프로세스 얼마나 오랫동안 실행할지 결정<br>\n실행 중인 시스템 프로세스에 프로세서 동작 시간이라는 유한한 자원 분배<br>\n리눅스 같은 멀티태스킹 OS의 기본 요소<br>\n실행 프로세스 선택 과정을 통해, 시스템 최대 사용률 끌어내야 하고,<br>\n사용자에게 여러 개의 프로세스가 동시에 실행되는 느낌을 줘야 함</p>\n<p>원리는 간단<br>\n실행 가능한 프로세스가 있다면, 그 중 어떤 것이던 실행되야 함<br>\n프로세서 개수보다 프로세스의 개수가 많다면 특정 순간에 일부 프로세스는 실행 중 아니게 됨<br>\n이 경우 실행되기를 기다림<br>\n스케줄러가 해결할 근본적 문제는 실행 가능한 프로세스 여러 개가 있을 때 어떤 프로세스를 다음에 실행할 것인가 결정하는 것  </p>\n<h1>멀티태스킹</h1>\n<p>멀티태스킹 OS : 하나 이상의 프로세스를 동시에 중첩 형태로 실행할 수 있는 OS</p>\n<p>멀티태스킹을 통해 프로세서 하나인 시스템에서도 여러 개의 프로세스를 동시 실행하는 느낌 줄 수 있음<br>\n프로세서가 여러 개면 실제로 여러 프로세스 동시 실행 가능</p>\n<p>많은 프로세스 대기 상태 혹은 잠든 상태 될 수 있음(이 경우 메모리상에는 있지만 실행 가능한 상태 아님)<br>\n커널은 이런 프로세스를 특정 조건(인터럽트) 발생전까지 대기 상태로 둠 </p>\n<p>메모리상엔 많은 프로세스 있을 수 있지만 현대 리눅스 시스템에서 실행 중인 프로세스는 하나뿐  </p>\n<ul>\n<li>\n<p>멀티태스킹 운영체제</p>\n<ul>\n<li>협동형 멀티태스킹<strong>cooperative multitasking</strong></li>\n<li>선점형 멀티태스킹<strong>preemptive multitasking</strong> : 프로세스 실행을 언제 중단하고 다른 프로세스 실행할지 스케줄러가 결정하는데 실행 중인 프로세스 강제 중지하는 작업을 선점<strong>preemption</strong>이라 함, 리눅스도 이것 지원함</li>\n</ul>\n</li>\n</ul>\n<h2>선점형 멀티태스킹<strong>preemptive multitasking</strong></h2>\n<p>프로세스가 선점되기 전까지 프로세스에 주어지는 시간 보통 미리 정해지고 프로세스의 타임슬라이스<strong>timeslice</strong>라고 함<br>\n타임슬라이스 관리하는 방식으로 전체적인 시스템 스케줄링 결정<br>\n한 프로세스가 프로세서 독점 방지  </p>\n<p>요즘 OS 시스템 정책과 프로세스 동작 관련 함수 이용 동적으로 타임슬라이스 계산  </p>\n<p>리눅스 특유 '공정<strong>fair</strong>' 스케줄러는 타임슬라이스 값을 그 자체로 적용 안하는 방식으로 동작  </p>\n<p>대부분 OS 선점형 멀티태스킹 지원\n유닉스는 태초부터 선점형 멀티태스킹 지원</p>\n<h2>협동형 멀티태스킹<strong>cooperative multitasking</strong></h2>\n<p>프로세스가 자발적으로 실행 중단 안하면 한 프로세스 중지 불가능<br>\n프로세스가 자발적으로 동작 중단하는 행동을 양보<strong>yield</strong>라고 함<br>\n이상적으로 프로세스가 자주 양보해서 실행 중인 프로세스가 충분한 프로세서 동작 시간 확보 가능하지만 OS가 이것을 강제 불가함<br>\n스케줄러가 실행 시간에 관해 전체적 결정 불가함<br>\n사용자 의도보다 더 오래 독점할 가능성 있음<br>\n양보하지 않는 큰 프로세스가 전체 시스템 먹통 만들 수 있음  </p>\n<p>Mac OS 9, 윈도우 3.1과 이것들의 이전버전이 해당됨</p>\n<h1>리눅스의 프로세스 스케줄러</h1>\n<p>2.5 커널에 도입된 O(1) 스케줄러 : 상수 시간 알고리즘 사용, 프로세서마다 별도의 실행 대기열<strong>queue</strong> 사용으로 이전 스케줄러의 설계상 제약 제거함</p>\n<p>잘 동작하다 이후 문제 발견됨<br>\n커다란 서버 작업에는 이상적이나<br>\n응답시간에 민감한 애플리케이션인 대화형<strong>interactive</strong> 프로세스가 중요한 데스크톱 시스템에서 평균 이하 성능 보임</p>\n<p>2.6 커널에 도입된 새로운 프로세스 스케줄러\n회전 계단식 기한<strong>Rotating Staircase Deadline</strong> 스케줄러 : 공정 스케줄링 개념을 큐잉 이론에서 빌려 적용함<br>\n위로부터 영감을 받아 2.6.23 커널부터 <strong>CFS</strong>라고 부르는 완전 공정 스케줄러가 O(1) 스케줄러 대신하게 됨</p>\n<h1>정책</h1>\n<p>정책<strong>Policy</strong>는 스케줄러가 무엇을 언제 실행할 것인지를 정하는 동작을 말함<br>\n스케줄러의 정책을 통해 시스템의 전체적인 느낌 정해지는 경향<br>\n프로세서 시간의 사용을 최적화하는 책임이 있어 매우 중요함</p>\n<h2>입출력중심 프로세스와 프로세서중심 프로세스</h2>\n<ul>\n<li>\n<p>프로세스를 두 가지로 분류 가능</p>\n<ul>\n<li>입출력중심 프로세스 : 입출력 요청 후 기다리는데 대부분 시간 사용, 실제 실행시간 매우 짧음, (디스크, 키보드, 네트워크 등 대기 상태 발생 가능한 모든 시스템 자원의 입출력 대상) </li>\n<li>프로세서중심 프로세스 : 대부분의 시간 코드 실행에 사용, 보통 선점될때까지 계속 실행됨, 이런 프로세스 자주 실행할수록 시스템 반응 나빠짐, 좀 더 긴시간 덜 자주 실행하는게 좋음, 많은 양 수학적 계산 실행하는 ssh-keygen, MATLAB이 예시\n위 분류는 상호배타적이지는 않음<br>\n동시에 두 가지 특성 가질 수 있음 (e.g. X 윈도우 서버, 워드 프로세서)</li>\n</ul>\n</li>\n</ul>\n<p>시스템의 스케줄링 정책은 상충되는 두 가지 목적 달성하고자 함<br>\n프로세스 응답시간(지연시간) 빠르게, 시스템 사용률 최대화(산출물<strong>throughput</strong> 극대화) </p>\n<p>유닉스 시스템 스케줄러 정책은 입출력중심 프로세스에 관대한 경향 => 빠른 프로세스 응답시간<br>\n리눅스도 대화형 작업에 쾌적한 응답시간과 데스크톱 성능 제공 목적으로 입출력중심 프로세스에 관대함 => 빠른 프로세스 응답시간<br>\n리눅스는 독창적 방식으로 이 작업 구현하여 프로세서 중심 프로세스 소홀히 하지 않음</p>\n<h2>프로세스 우선순위</h2>\n<p>스케줄링 알고리즘 일반적 형태 : 우선순위 기반 스케줄링 = 가치와 필요에 따라 프로세스의 순위 매겨 프로세스 시간 할당<br>\n일반적으로 우선순위 높은 프로세스 낮은 것보다 먼저 실행, 같은 경우 순환방식<strong>round-robin</strong></p>\n<p>일부 시스템은 우선순위 높은 프로세스 타임슬라이스 길게 함</p>\n<p>시스템은 물론 사용자도 프로세스 우선순위 조작 가능</p>\n<p>리눅스 커널은 두 가지 별개의 우선순위 단위 가짐</p>\n<ol>\n<li>\n<p>나이스<strong>nice</strong> 값 : -20 ~ +19 사이의 값 가짐, 기본값 0</p>\n<ul>\n<li>클수록 우선순위 낮음(더 친절nice해짐)</li>\n<li>낮은 값 프로세스가 높은 것보다 프로세서 사용 시간 더 많이 할당받음</li>\n<li>유닉스 시스템 우선순위 표기 형식이지만 활용은 알고리즘마다 다르게 함(e.g. Mac OS X 등 유닉스 기반 OS는 nice 값으로 타임슬라이스 절대값 조절, 리눅스는 타임슬라이스 비율 조절, <code class=\"language-text\">$ps -el</code>로 시스템 ps목록과 각각의 나이스 값(NI 항목) 확인 가능)</li>\n</ul>\n</li>\n<li>\n<p>실시간 우선순위 : 0 ~ 99 사이의 값, 설정으로 범위 조절 가능</p>\n<ul>\n<li>클수록 우선순위 높음</li>\n<li>모든 실시간 프로세스가 일반적 프로세스보다 높은값 가짐</li>\n<li>나이스 값과 별도의 값</li>\n<li>유닉스 표준 POSIX.1b에 따라 구현</li>\n<li><code class=\"language-text\">$ps -eo state,uid,pid,ppid,rtprio,time,comm.</code>의 rtprio항목으로 실시간 우선순위 확인 가능 ('-' 표시된 경우 실시간 프로세스 아님)</li>\n</ul>\n</li>\n</ol>\n<h2>타임슬라이스</h2>\n<p>타임슬라이스 너무 길면 시스템 대화형 성능 저하<br>\n너무 짧으면 프로세스 전환 오버헤드 커짐(프로세서중심인 경우 불리함)<br>\n입출력중심인지 프로세서중심인지 고려해야 함  </p>\n<p>많은 OS에서 기본 타임슬라이스 10ms로 설정</p>\n<p>리눅스 CFS 스케줄러 프로세스별로 프로세서 할당 비율 지정<br>\n리눅스 프로세스 시간은 시스템 부하에 따른 함수로 결정됨<br>\n이 할당값은 나이스 값에 영향 받음<br>\n나이스 값은 가중치로 비율에 영향을 줌  </p>\n<p>리눅스는 새 프로세스가 현재 실행 중인 프로세스보다 낮은 비율의 프로세서 시간 사용 시 선점하고 즉시 실행됨<br>\n그렇지 않으면 나중에 실행  </p>\n<h2>스케줄러 정책의 동작</h2>\n<p>대화형 작업에 많은 비율의 가용 프로세서 할당 : 프로세서 많이 필요하지 않지만 필요한 순간에 항상 프로세서 시간 얻기 위함, 깨어나는 순간 프로세서중심 프로세스 실행하는 프로세서 선점해야 함<br>\n=> 이렇게 해야 좋은 대화형 성능 보장 가능 </p>\n<p>많은 OS는 대화형 작업에 높은 우선순위, 긴 타임슬라이스 할당해 해결<br>\n발전된 OS는 대화형 작업인지 자동 탐지하여 이 과정 수행<br>\n리눅스는 다른 방법 사용  </p>\n<p>리눅스는 대화형 작업에 특정 우선순위, 타임슬라이스 할당하지 않고,<br>\n일정 비율의 프로세서 시간 보장함  </p>\n<p>같은 나이스 값 가진 프로세스가 대화형 작업 A, 프로세서중심 작업 B 둘뿐이라면 이 비율은 50%임<br>\n각 프로세스는 절반의 프로세서 시간 보장받음<br>\n자연스럽게 대화형 작업이 입출력 기다리며 사용 시간 덜 사용하여 비율 커짐\n대화형 작업이 깨어났을 때, CFS가 비율 차이를 알게 되고 A가 선점할 수 있게함\nA가 다시 입출력 대기 상태로 들어가면 B가 실행됨</p>\n<h1>리눅스 스케줄링 알고리즘</h1>\n<h2>스케줄러 클래스</h2>\n<p>리눅스 스케줄러는 모듈화되어 있음<br>\n여러 유형의 프로세스를 각기 다른 알고리즘 적용 스케줄링 가능  </p>\n<p>스케줄러 클래스 이용 교체 가능한 여러 알고리즘 동시 사용하며 클래스별로 독자적 방식 프로세스 스케줄링 가능</p>\n<p>각 스케줄러 클래스에 우선순위 존재<br>\nkernel/sched.c에 정의된 기본 스케줄러 코드는 각 스케줄러 클래스를 우선순위에 따라 차례대로 실행함<br>\n실행 가능한 프로세스가 있는 가장 우선순위 높은 스케줄러가 다음에 실행할 프로세스 선택함  </p>\n<p>CFS는 SCHED<em>NORMAL로 정의된(POSIX 표준에서는 SCHED</em>OTHER) 리눅스의 일반 프로세스용 스케줄러 클래스\nCFS는 kernel/sched_fair.c에 정의됨  </p>\n<h2>유닉스 시스템의 프로세스 스케줄링</h2>","excerpt":"프로세스 스케줄러 어떤 프로세스 얼마나 오랫동안 실행할지 결정 실행 중인 시스템 프로세스에 프로세서 동작 시간이라는 유한한 자원 분배 리눅스 같은 멀티태스킹 OS…","frontmatter":{"title":"리눅스 커널 (4) - 프로세스 스케줄링","date":"2019-12-06","tags":["리눅스","커널"],"keywords":["KMKMI"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/리눅스 커널 (4) - 프로세스 스케줄링/","previous":{"fields":{"slug":"/캐시 컬러링(페이지 컬러링)/"},"frontmatter":{"title":"캐시 컬러링(페이지 컬러링)","tags":["캐시"],"published":true}},"next":{"fields":{"slug":"/소프트웨어 공학 - 애자일 프로세스, 스크럼/"},"frontmatter":{"title":"소프트웨어 공학 - 애자일 프로세스, 스크럼","tags":["소프트웨어 공학"],"published":true}}}}}