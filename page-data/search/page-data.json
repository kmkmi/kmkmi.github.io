{"componentChunkName":"component---src-pages-search-js","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n##1. 현대 대칭키 암호\r\n\r\n###(1) 현대 블록 암호\r\n\r\n####1) 현대 블록 암호의 구성요소\r\n\r\n__(가) 개요__  \r\n\r\n1. 현대 블록 암호는 __확산과 혼돈__ 성질 만족을 위해 전치 요소(P-박스), 치환 요소(S-box) 그 외 구성 요소 결합하여 설계됨.  \r\n2. 공격 방지 암호화를 위해 이동요소(shift), 교환요소(swap), 분할요소(split), 조합요소, 전치장치(transposition, P-box), 치환장치(substitution, S-box), XOR연산의 조합으로 만들어짐.  \r\n\r\n#####\r\n    \r\n* 혼돈 : 암호문과 키의 상관관계를 숨김\r\n* 확산 : 평문의 통계적 성질을 암호문 전반에 퍼뜨려 숨김 \r\n* 대칭키 암호 ≒ 관용 암호 ≒ 공통키 암호\r\n* 비대칭키 암호 ≒ 공개키 암호 \r\n\r\n\r\n__(나) P-박스__  \r\n\r\n1. 문자 단위 암호화, 고전 장치 암호를 병렬적으로 수행  \r\n   블록 암호에서는 단순(straight) P-box, 확장(expansion) P-box, 축소(compresssion) P-box 세 가지 종류.  \r\n   => 아웃풋 크기가 동일, 확장, 축소됨.\r\n2. 축소 P-box  \r\n   n bit 입력 m bit 출력, n>m, 입력 비트 중 특정 비트 소실되 출력 안됨.\r\n3. 확장 P-box  \r\n   n bit 입력 m bit 출력, n<m, 입력 비트 중 특정 비트는 한 개 이상의 출력 비트로 연결.  \r\n   비트를 치환하고 동시에 다음 단계에서 비트의 양을 증가시키고자 할 때 사용.\r\n4. 역함수의 존재성  \r\n   단순 P-box는 역함수 존재  \r\n   축소 P-box, 확장 P-box 역함수 존재 안함\r\n\r\n\r\n####2) S-박스\r\n\r\n__(가) 개요__  \r\n1. S-box는 치환 암호의 축소. 입력과 출력 개수 달라도 됨.\r\n2. 역함수 존재성 : 존재할 수도 안할 수도 있다. 역함수 존재하는 S-box는 입력과 출력 비트 수 동일.\r\n\r\n\r\n####3) 합성 암호(Product Ciphers)\r\n\r\n__(가) 개요__  \r\n1. 치환, 전치, 그리고 그 밖의 구성요소를 결합한 복합적인 암호\r\n\r\n__(나) 확산(Diffusion)과 혼돈(Confusion)__  \r\n1. 합성 암호의 주된 개념은 설계된 블록 암호가 확산, 혼돈 성질을 갖도록 하는 것\r\n2. 확산 : 암호문과 평문 사이의 관계를 숨기는 것. 암호문 통계 테스트를 통해 평문을 찾는 것 방지\r\n3. 혼돈 : 암호문과 키의 관계를 숨김. 암호문을 이용해 키를 찾는 것을 방지. 즉, 키의 단일 비트가 변하면 암호문의 거의 모든 비트가 변함. \r\n\r\n__(다) 라운드(Rounds)__\r\n1. 반복적 합성 암호를 통해 확산과 혼돈 얻음. 반복적 합성 암호를 라운드라고 칭함.\r\n\r\n\r\n####4) 두 가지 종류의 함성 암호\r\n\r\n__(가) Feistel 암호__  \r\n1. 3라운드 이상, 짝수 라운드로 구성. 라운드 함수와 관계없이 역변환 가능, 두 번의 수행으로 블록간의 완전한 확산이 이루어짐.  \r\n   알고리즘 수행 속도 빠르고, 하드웨어 및 소프트웨어 구현 용이, 아직 구조상 문제점 발견되지 않음.  \r\n   구조는 입력을 좌우 블록으로 분할하여 한 블록을 라운드 함수에 적용시킨 후의 출력 값을  \r\n   다른 블록에 적용하는 과정을 좌우블록에 대해 반복적으로 시행.  \r\n   라운드 키가 역순으로 작용한다는 점을 제외하면 암/복호화 과정이 동일하고 라운드 함수에 대한  \r\n   제약 조건이 없어 DES를 비롯한 대부분 블록암호에 채택.\r\n\r\n2. 암호 강도 결정 요소 : 평문 블록의 길이  >= 64 비트, 키 K의 길이 64 비트 내외, 라운드 수 >= 16회 권장\r\n\r\n3. 암호화, 복호화 과정 동일. 복호화 과정의 입력은 암호문과 보조키 $K_{i}$, 보조키의 입력 순서는 암호화 시 순서의 반대,  \r\n   즉, 복호화 첫 라운드 $K_{n-i}$, 마지막 라운드 $K_{1}$을 보조키로 입력.\r\n\r\n__(나) Feistel 암호 특징__  \r\n\r\n1. 입력 n 비트를 두 개의 블록 $(L_{0}, R_{0})$으로 나누어 라운드 함수 F, 라운드 키 $K_{i}$로 i 번째 라운드 과정  \r\n   주의) 최종 라운드에서 좌우 블록을 한 번 더 교환해야 함.  \r\n\r\n   $L_{i} = R_{i-1}$  \r\n   $R_{i} = L_{i-1} \\oplus F_{i}(R_{i-1},K_{i})$\r\n\r\n2. 페이스텔 네트워크는 많은 블록 암호 알고리즘에서 사용. AES 최종 후보 5개 중 3개 (MARS, RC6, Twofish)에서 사용.\r\n   AES 최종 선정된 Rijndael은 사용 안함.\r\n\r\n#####\r\n\r\n- __대칭 블록 암호 구현__  \r\n\r\n1. 블록 크기(Block size) : 블록 크기 크면 더 강한 보안, but 암 * 복호화 속도 저하. 128 비트가 조화로운 합리적 크기, 블록 암호 설계에서 공통적으로 이 크기 사용.\r\n2. 키 길이(Key size) : 키 길이가 길다는 것은 더 강한 보안, but 암 * 복호화 속도 저하. 보편적 키 길이 128 비트.\r\n3. 라운드 수 : 단일 과정으로는 보안 부족 => 라운드 수 증가시켜 보안 강화, 전형적 라운드 수 16.\r\n4. 서브키 생성 알고리즘 : 복잡할수록 암호해독 어려움.\r\n5. 라운드 함수 : 복잡할수록 암호해독 어려움. \r\n\r\n\r\n__(다) SPN 구조__  \r\n\r\n\r\n1. 블록 암호 라운드 함수 적용 방법에 따라 크게 두 가지 형태  \r\n   Substitution-permutation(SP) network, Feistel\r\n2. SP Network : 여러 개의 함수 중첩 시 개별 함수로 이루어진 암호보다 안전하다는 이론에 근거  \r\n                => 고전 암호 일종인 Substitution Cipher와 Permutation Cipher를 중첩하는 형태\r\n3. 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box로 입력하여 대치(Substitution)  \r\n   S-box의 출력을 P-box로 전치(permutation)하는 과정을 반복하는 방식  \r\n\r\n####5) 블록 암호에 대한 공격\r\n\r\n__(가) 차분 분석(차분 해독법, Differential Cryptanalysis)__  \r\n1. Biham Shamir가 개발, __평문의 일부를 변경하면 암호문이 어떻게 변화하는지__를 조사하는 암호 해독법  \r\n2. 블록 암호는 입력 평문이 한 비트라도 달라지면 암호문은 전혀 다른 비트 패턴으로 변화 => 변화 형태 조사하여 해독  \r\n\r\n\r\n__(나) 선형 분석(선형 해독법, Linear Cryptanalysis)__  \r\n\r\n1. Matsui가 개발, __평문과 암호문 비트를 몇 개 정도 XOR해서 0이 되는 확률을 조사__\r\n2. 암호문이 충분히 랜덤하면 평문과 암호문의 비트를 몇 개 XOR한 결과가 0이 되는 확률은 1/2  \r\n   => 따라서 1/2 비율을 크게 벗어난 비트의 개수를 조사하여 키에 관한 정보 얻음  \r\n3. 차분, 선형 해독법은 해독자가 임의로 만든 평문을 암호화할 수 있다는 가정 => __선택 평문 공격(Chosen Plaintext Attack)__  \r\n   선형 해독법의 경우 근사 선형 관계성을 찾았다면 이를 통해 기지평문 공격에서 선택 평문 공격을 수행 가능  \r\n\r\n__(다) 전수공격법(Exhaustive key search)__  \r\n\r\n1.  Diffe와 Hellman이 제안한 방법, 모든 경우 전수 조사\r\n\r\n\r\n__(라) 통계적 분석(Statistical analysis)__  \r\n1. 암호문에 대해 평문의 각 단어별 빈도 등 통계적 자료 이용 해독  \r\n\r\n__(마) 수학적 분석(Mathematical analysis)__  \r\n\r\n1. 통계적 방법을 포함, 수학적 이론 이용 해독  \r\n\r\n\r\n###(2) 현대 스트림 암호 \r\n\r\n####1) 개요\r\n\r\n__(가) 기본 개념__  \r\n\r\n1. 현대 스트림 암호에서 암호화와 복호화는 한번에 r 비트 생성.  \r\n   평문 비트 스트림 = $P=p_{n} \\cdots p_{2}p_{1}$, 암호문 비트 스트림 = $C=c_{n} \\cdots c_{2}c_{1}$,  \r\n   키 비트 스트림 = $K=k_{n} \\cdots k_{2}k_{1}$이라 할 때  (단, $p_{i},c_{i},k_{i}$는 r 비트 워드)  \r\n   암호화 : $c_{i} = E(k_{i},p_{i})$  \r\n   복호화 : $p_{i} = D(k_{i},c_{i})$  \r\n\r\n2. 키 스트림 $K = k_{n} \\cdots k_{2}k_{1}$ 생성 방법이 현대 스트림 암호 주 관심사  \r\n   현대 스트림 암호 : 동기식, 비동기식 두 가지 종류로 분류\r\n\r\n__(나) 스트림 암호 설계 시 고려사항__  \r\n1. 암호화의 연속은 긴 주기를 가져야함  \r\n   의사 난수 생성기가 언젠가 반복되는 비트 스트림 생성하므로 반복 주기가 더 길어야 해독이 더 어려워짐\r\n2. 키 스트림은 진 난수 스트림과 최대한 비슷해야 함  \r\n   1, 0의 개수가 거의 동일해야 함, 키 스트림이 바이트 스트림으로 처리 시 256개의 가능한 바이트 값이 거의 같은 빈도로 출현해야 함  \r\n3. 전사적 공격에 대응하기 위해서는 키가 충분히 길어야 함  \r\n   블록 암호에도 적용할 수 있기 때문에 현재 기술 수준에서 최소 128 비트인 것이 바람직  \r\n\r\n\r\n####2) 동기식 스트림 암호 \r\n\r\n__(가) 개요__   \r\n\r\n1. 동기식 스트림 암호에서 키 스트림은 평문 혹은 암호문 스트림과 독립적  \r\n2. 키 스트림은 평문 혹은 암호문 비트와 키 사이에 어떠한 관계도 없이 생성, 사용  \r\n\r\n__(나) One-Time Pad__  \r\n\r\n1. 동기식 스트림 암호 중 가장 간단, 안전  \r\n   암호화를 수행할 때마다 랜덤하게 선택된 키 스트림을 사용\r\n2. 해독 불가능하다는 것이 수학적으로 증명됨  \r\n   일회용 패드는 무조건 안전(unconditionally secure), 이론적으로 해독 불가능(theoretically unbreakable)로 알려짐  \r\n3. 암호화 알고리즘, 복호화 알고리즘 각각 배타적 논리합 연산(XOR)을 사용. XOR의 성질로 암호화와 복호화 알고리즘은 서로 역관계  \r\n   XOR을 한 번에 한 비트씩 적용함\r\n\r\n#####\r\n\r\n* OTP 안전성을 위한 조건 : 패드는 한 번만 사용, 패드는 메시지 길이만큼 길어야함, 패드는 목적지로 안전하게 배포, 보호되어야 함, 패드는 순수하게 임의값으로 만들어져야 함\r\n* 현대 스트림 암호에서 평문 스트림의 r 비트 워드는 키 스트림의 r 비트 워드를 사용하여 대응되는 암호문의 r 비트 워드를 생성하여 암호화함\r\n* 동기식 스트림 암호에서 키는 평문 혹은 암호문과 독립적  \r\n\r\n__(다) 귀환 시프트 레지스터(FSR, Feedback Shift Register)__  \r\n1. one-time pad의 절충안은 FSR이다. SW, HW 환경에서 모두 구현 가능, HW 구현이 더욱 용이함\r\n2. 시프트 레지스터와 귀환(feedback) 함수로 구성됨  \r\n\r\n\r\n__(라) 선형 귀환 시프트 레지스터(LFSR, linear feedback shift register)__  \r\n\r\n1. HW로 쉽게 구현되며 많은 스트림 암호가 이용\r\n\r\n#####\r\n* LSFR의 최대 주기는 $2^m-1$이다. \r\n* 비동기식 스트림 암호에서 키는 평문 혹은 암호문에 종속적으로 결정됨\r\n* 현대 블록 암호는 모두 함성 암호이고 Feistel, non-Feistel 두 가지로 분류됨  \r\n  Feistel 암호는 역함수가 존재하는 요소와 존재하지 않는 요소 모두 이용 가능  \r\n  non-Feistel 암호는 오직 역함수가 존재하는 요소만 이용 가능  \r\n\r\n__(마) 비선형 귀환 시프트 레지스터(NLFSR, Nonlinear Feedback Shift Register)__  \r\n1. LFSR이 선형성 공격에 취약, NLFSR로 더욱 안전한 스트림 암호 설계 가능  \r\n\r\n#####\r\n\r\n* 강력한 스트림 암호 특징  \r\n  키스트림 값 내부에서 장기간 반복되는 패턴 없음  \r\n  통계적 예측 불가한 키스트림  \r\n  키스트림은 키와 선형적 관계에 있지 않음 => 키스트림값을 알아내도 키값을 아는 것이 아님  \r\n  통계적으로 치우치지 않은 키스트림(0과 1의 개수)  \r\n\r\n\r\n####3) 비동기식 스트림 암호 \r\n\r\n1. 각 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정\r\n2. 블록 암호에서 다른 운영 모드를 생성하기 위해 사용되는 한 방법인 CFB(cipher feedback mode)는 실제로 스트림 암호를 생성  \r\n\r\n\r\n##2. DES(Data Encryption Standard)\r\n\r\n###(1) 개요\r\n\r\n####1) 역사\r\n\r\n1. NIST 표준\r\n2. NIST는 이제 3중 DES 사용 권고\r\n3. AES가 DES 대체하기 위해 새 표준으로 제정됨 \r\n\r\n\r\n####2) 개관\r\n1. 평문 길이 64 bit, 키의 길이 56 bit, 평문이 64 bit보다 길면 블록으로 나눔  \r\n   Feistel 네트워크의 변형 형태, 16 라운드  \r\n   56 bit 원래 키로부터 16개의 서브키를 생성하고 이 것을 각 라운드에서 사용  \r\n2. DES의 복호화 과정은 암호화 과정과 동일   \r\n   암호문을 알고리즘 입력으로, 서브키 $K_{i}$는 순서를 뒤집어서 적용.  \r\n   즉, 첫번째 라운드에 $K_{16}$ 사용, 다음 라운드 $K_{15}$, 마지막 16 라운드에 $K_{1}$ 사용으로 반복\r\n\r\n#####\r\n* DES는 64 bit 평문을 64 bit 암호문으로 암호화하는 대칭키 암호화\r\n* DES의 키는 7 비트마다 오류검출 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트\r\n\r\n\r\n###(2) DES의 구조\r\n\r\n####1) 개요\r\n\r\n1. 암호화 과정은 두 개의 P-box와 16개의 Feistel 라운드 함수로 구성됨  \r\n   두 개의 P-box 중 하나는 초기 전치(initial permutation), 다른 하나는 최종 전치(final permutation)\r\n2. 각 라운드는 라운드 키 생성기에 의해 암호키로부터 생성된 48 bit 라운드 키 사용 \r\n\r\n####2) 라운드 함수 \r\n\r\n__(가) 개요__  \r\n1. DES는 16번 라운드 함수 사용. 각 라운드 함수는 Feistel 암호\r\n\r\n2. 라운드 함수는 이전 라운드 함수(또는 초기 P-box)의 출력 값 $L_{i-1}$과 $R_{i-1}$을 입력 받아, 다음 라운드(또는 최종 P-box)에 입력으로 전송될 $L_{i}$와 $R_{i}$을 생성  \r\n\r\n3. 각 라운드에는 혼합기(mixer)와 교환기(swapper) 존재, 이 것들은 역연산이 가능. 교환기는 명백히 역연산 가능 \r\n\r\n\r\n__(나) DES 함수__  \r\n1. DES의 핵심은 DES 함수. 라운드 함수에 사용된 $f(R_{i-1},K_{i})$를 가리킴.  \r\n   DES 함수는 32비트 출력값을 산출하기 위해 가장 오른쪽 32비트 $(R_{i-1})$에 48키를 적용  \r\n2. DES 함수는 확장 P-box, 키 XOR, 8개의 S-box 그리고 단순 P-box의 4개 부분으로 구성됨  \r\n\r\n#####\r\n* DES  \r\n  키 크기 : 56비트 + parity 8비트 = 64 비트  \r\n  안전성은 주로 비선형 함수로 구성된 8개의 S-box에 의존  \r\n  16라운드의 페이스텔 구조  \r\n  복호화는 암호화의 역순 \r\n\r\n####3) 암호화 알고리즘과 복호화 알고리즘\r\n\r\n__(가) 개요__  \r\n1. mixer, swapper 사용해 16라운드 암호화, 복호화 알고리즘 만듦.\r\n2. 중요한 점은 암호화 키 순서의 역순으로 복호화 시 키 순서 적용  \r\n\r\n\r\n###(3) DES 분석\r\n\r\n####1) 설계 기준\r\n\r\n__(가) S-box__  \r\n1. S-box는 각 라운드에서부터 그 다음 라운드까지 혼돈 만족하도록 설계됨\r\n2. S-box는 비선형 함수\r\n3. 입력값의 한 비트를 바꾼다면 출력값에서는 두 비트 이상이 바뀜 \r\n\r\n__(나) P-box__   \r\n1. 32비트에서 32비트로 가는 하나의 단순 P-box와 32비트에서 48비트로 가는 하나의 확장 P-box 존재.  \r\n   두 개의 P-box는 비트들을 동시에 확산시킴.\r\n\r\n####2) DES의 취약점\r\n\r\n1. 평문 또는 키의 작은 변화가 암호문에 큰 변화를 만드는 쇄도효과(Avalanche Effect)가 매우 큼, 암호문의 각 비트가 평문의 많은 비트들에 의존하는 완비성(completeness)이 높은 것으로 증명되 암호문으로부터 평문 추론 매우 어려움\r\n2. 그러나 56비트 키 사용하므로 최대 키 공간의 크기 $2^{56}( \\cong 7.2 \\times 10^{16})$이 되고,  \r\n   개발 당시는 전사 공격(Brute Force Attack) 불가했지만, 현대에는 더 이상 안전하지 않음 \r\n3. 실제로 전사 공격에 해독되고, 지금은 적용하면 위험  \r\n\r\n\r\n###(4) 다중 DES\r\n\r\n####1) 3중 DES\r\n\r\n__(가) 개요__  \r\n1. 두 가지 버전 : 두 개의 키, 세 개의 키\r\n\r\n2. 3DES는 HW에서 효율적, SW 비효율적  \r\n   전자 여권 바이오 정보 보호, 금융 분야에서 활용\r\n\r\n__(나) 3중 DES 현황__  \r\n1. 3DES 은행 등에서 활용하지만 빠르지 않음  \r\n   과거 DES 암호화 자료와 호환성 중시하는 경우 제외하고 새 용도로 잘 안쓰임  \r\n2. 3DES는 우리나라 표준은 아님, 우리나라 표준은 블록 암호 SEED, 국내 기관 공동 개발한 ARIA는 현재 사용됨\r\n\r\n#####\r\n* DES가 3DES보다 2.5배 정도 빠름, AES-128은 DES보다 3배 정도 빠름, RC4는 AES-128보다 2배 정도 빠름\r\n\r\n\r\n__(다) 두 개의 키를 갖는 3중 DES__  \r\n1. 두 개의 키 $K_{1}$과 $K_{2}$만 사용. 첫 번째와 세번째 단계에서 $K_{1}$사용, 두번째 단계는 $K_{2}$ 사용.\r\n\r\n2. 하나의 DES로 3중 DES를 만들기 위해 두 번째 DES는 복호화 알고리즘 사용, 1, 3 번째 경우 암호화 DES 알고리즘 사용\r\n\r\n__(라) 세 개의 키를 갖는 3중 DES__  \r\n1. 두 개 키를 쓰는 DES는 기지평문공격 가능성이 있어 세 개의 키를 사용하기도 함\r\n2. PGP와 같은 많은 응용프로그램에서 사용  \r\n3. 3DES의 복호화는 암호화의 역이 됨 키3, 키2, 키1 순으로 복호화 -> 암호화 -> 복호화\r\n\r\n__(마) DES와의 호환성__   \r\n1. 트리플 DES에서 모든 키를 동일하게 하면 3DES는 보통의 DES와 같아진다. 1, 2 번째 DES가 암호화 후 복호화 하여 다시 평문이 나오는 꼴  \r\n2. 과거 DES로 암호화된 암호문을 3DES 호환\r\n\r\n|구분(단위 bits)|DES|Triple DES|AES|\r\n|:--------:|:--------:|:--------:|:--------:|\r\n|평문 블록 크기|64|64|128|\r\n|암호문 블록 크기|64|64|128|\r\n|키 크기|56|112 or 168|128, 192, or 256|\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/정보보안기사 2장 - (2) 대칭키 암호/"},"frontmatter":{"title":"정보보안기사 2장 - (2) 대칭키 암호","published":true}}},{"node":{"rawMarkdownBody":"\r\n##1. 암호학의 기본개념\r\n\r\n###1) 암호학(Cryptology)의 정의\r\n\r\n1. 암호 : 약속된 당사자나 집단에서만 내포된 내용을 알 수 있게하는 일종의 문서\r\n2. 암호학 : 암호 기술과 암호해독에 관하여 연구하는 학문 \r\n\r\n\r\n###2) 암호학에서 사용하는 이름\r\n\r\n1. 앨리스(Alice), 밥(Bob) : 메시지 송수신 주체\r\n2. 이브(Eve) : 도청자(eavesdropper), 소극적 공격자\r\n3. 맬로리(Mallory) : 악의적인(malicious) 공격자\r\n4. 트렌트(Trent) : 신뢰할 수 있는 중재자(trusted arbitrator)\r\n5. 빅터(Victor) : verifier, 검증인\r\n\r\n\r\n###3) 송신자, 수신자, 도청자\r\n\r\n1. 송신자(sender), 수신자(receiver), 메시지(message)\r\n2. 사람 이름이 사람이 아닌 기계나 프로그램일 수도 있다.\r\n\r\n###4) 암호화와 복호화\r\n\r\n1. 평문(plaintext) : 암호화하기 전 메시지  \r\n   암호문(ciphertext) : 암호화한 메시지 \r\n2. 암호(cryptography) 기술로 기밀성(confidentiality) 유지\r\n\r\n\r\n###5) 암호화와 복호화의 기호적 표현\r\n\r\n1. 주로, \r\n \r\n   평문 : P  \r\n   암호문 : C  \r\n   암호 알고리즘 : E  \r\n   복호화 알고리즘 : D  \r\n   키 : K\r\n\r\n   * 키 스페이스 : 사용하는 키 값의 크기(size)  \r\n\r\n\r\n - $C = E_{k}(P)$ : 평문 P를 키 K로 암호화(E)하여 암호문 C\r\n - $P = D_{k}(C)$ : 암호문 C를 키 K로 복호화(D)하여 평문 P\r\n\r\n2. 또는 $C = E(K,P)$, $P = D(K,C)$로 표현\r\n\r\n* 암호시스템(Cryptosystem) : 암호화와 복호화를 수행하는 시스템\r\n\r\n###6) 암호 알고리즘과 키의 분리\r\n\r\n암호 알고리즘은 반복하고 키만 바꾸어 사용\r\n\r\n\r\n###7) 암호와 보안 상식\r\n\r\n__(가) 비밀 암호 알고리즘 사용하지 말 것__  \r\n암호 알고리즘 구조가 폭로되면 파훼됨  \r\n숨기는 것에 의한 보안(security by obscurity)라 부르고 위험하고 어리석게 간주  \r\n\r\n__(나) 약한 암호는 암호화하지 않는 것보다 위험__  \r\n잘못된 안심을 하고 기밀성 높은 정보 소홀하게 취급할 가능성  \r\n\r\n__(다) 어떤 암호라도 언젠가는 해독됨__  \r\nBrute-force attack  \r\n해독에 들어가는 시간과 암호화할 평문의 중요성의 밸런스(trade-off) 고려  \r\n\r\n__(라) 암호는 보안의 일부분__  \r\n사회공격(social engineering attack)이 최근 자주 행해짐  \r\ne.g.) 피싱(Phshing) : 위장 홈페이지 등으로 접근하도록 하여 개인정보 빼 가는 해킹 방법,  \r\n트로이목마(Trojan Horse) : 정상적인 프로그램으로 가장해 다른 프로그램 안에 숨어 있다가 그 프로그램이 실행될 때 자신을 활성화하는 악성 프로그램,  \r\n키로거(Keylogger) : 키보드 움직임을 탐지해 개인정보를 몰래 빼 가는 해킹 공격  \r\n\r\n\r\n##2. 암호기법의 분류 \r\n\r\n###1) 치환 암호와 전치 암호\r\n\r\n__(가) 치환 암호(대치 암호, Substitution Cipher)__  \r\n비트, 문자 또는 블록을 다른 비트, 문자 또는 블록으로 대체  \r\n평문에서 사용하는 문자의 집합과 암호문에서 사용하는 문자의 집합이 다를 수 있음  \r\n문자를 교환하는 규칙, 일대일 대응이 아닐 수 있음  \r\n\r\n__(나) 전치 암호(Transposition Cipher)__  \r\n비트, 문자 또는 블록이 원래 의미를 감추도록 재배열  \r\n평문과 암호문에서 사용하는 문자 집합이 동일  \r\n문자 집합 내부에서 자리를 바꾸는 규칙, 평문과 암호문의 문자가 일대일 대응 규칙  \r\n\r\n * 키 공간(Key space)의 크기와 키 비트수  \r\n암호화에서 키 공간의 크기는 전사 공격 방지에 매우 중요.  \r\n클 수록 안전.  \r\n하지만 키가 클 수록 키 비트수도 커짐.  \r\n\r\n\r\n###2) 블록 암호와 스트림 암호\r\n\r\n__(가) 블록 암호(Block cipher)__  \r\n블록 암호는 특정 비트 수의 집합인 블록 단위로 암호화하는 알고리즘을 총칭  \r\n블록 비트 수  = 블록 길이(block length)  \r\n평문을 블록으로 나누어 암호화, 블록 크기는 8 또는 16의 배수  \r\n스트림 암호화와 다르게 Round를 사용하고, 반복적으로 암호화 과정을 수행해 암호화  \r\n\r\n__(나) 스트림 암호(Stream cipher)__  \r\n한번에 1비트 혹은 1바이트의 스트림(데이터 흐름)을 순차적으로 처리해 암호화하는 알고리즘 총칭  \r\n평문과 키 스트림을 XOR해서 암호화  \r\n블록 암호화와 다르게 스트림 암호화는 진행 상태를 알기 위해 내부 상태를 가짐  \r\n군사 및 외교용으로 널리 사용, 일부 상용으로  \r\n이동 통신 환경에서 구현 용이, 안전성을 수학적으로 엄밀 분석 가능하여 무선 데이터 보호에 적합  \r\n\r\n| 구분 | 스트림 암호 | 블록 암호 |\r\n| :--------| :--------| :--------|\r\n| 장점 | 암호화 속도 빠름, 에러 전파현상 없음 | 높은 확산, 기밀성 해시함수 등 다양 |\r\n| 단점 | 낮은 확산 | 느린 암호화, 에러 전달 |\r\n| 사례 | LFSR, MUX generator | DES, IDEA, SEED, RC5, AES | \r\n| 암호화 단위 | 비트 | 블록 |\r\n| 주요 대상 | 음성, 오디오/비디오 스트리밍 | 일반 데이터 전송, 스토리지 저장 |\r\n\r\n\r\n\r\n###3) 위치에 따른 암호화의 구분\r\n\r\n__(가) 링크 암호화(Link Encryption)__  \r\n모든 정보는 암호화됨, 홉(라우터)에서 패킷 목적지를 알기 위해 해독됨  \r\n라우터는 패킷 헤더 부분을 해독하여 라우팅과 주소 정보를 읽고 다시 암호화한 후 다음 홉으로 전송  \r\n링크 암호화는 데이터 링크 또는 물리적 계층에서 일어남, 하드웨어 암호화 장치들은 물리적 계층과의 인터페이스를 가지고 통과하는 모든 데이터 암호화  \r\n\r\n\r\n__(나) 종단간 암호화(End-to-End Encryption)__  \r\n종단간 암호화에서는 헤더와 트레일러가 암호화되지 않기 때문에 패킷을 각 홉에서 해독하고 암호화할 필요가 없음  \r\n근원지와 목적지 사이의 장비들은 단지 필요 라우팅 정보만 읽고 진행 방향으로 통과  \r\n보통 근원지 컴퓨터 사용자가 종단간 암호화 시작, 이 점이 사용자가 어떤 메시지를 암호화할지 여부 결정하는 유연성 제공  \r\n종단간 암호화는 애플리케이션 계층에서 암호화 이루어짐  \r\n\r\n| 구분 | 링크 암호화 | 종단간 암호화 |\r\n| :--------| :--------| :--------|\r\n| 특징 | - ISP나 통신업자가 암호화 <br/> - 헤더를 포함한 모든 데이터를 암호화 <br/> - 유저가 알고리즘 통제 불가 | - 사용자가 암호화 <br/> - 헤더(라우팅 정보)는 암호화 안함 <br/> - 알고리즘에 대한 통제를 사용자가 함 |\r\n| 장점 | - User-transparent하게 암호화되므로 운영 간단(유저에게 보이지 않는다는 의미) <br/> - 트래픽분석을 어렵게 함 <br/> - 온라인으로 암호화 | - 사용자 인증 등 높은 수준의 보안 서비를 제공 가능 <br/> - 중간노드에서도 데이터가 암호문으로 존재 |\r\n| 단점 | - 중간 노드에서 데이터가 평문으로 노출 <br/> - 다양한 보안서비스를 제공하는데 한계 <br/> - 모든 노드가 암호화 장비를 갖추어야하므로 네트워크가 커지면 비용 과다 | - 트래픽분석이 취약 <br/> - 오프라인으로 암호화 | \r\n\r\n\r\n###4) 하드웨어와 소프트웨어 암호시스템\r\n\r\n__(가) 하드웨어 암호시스템__  \r\n하드웨어로 구현하기 위해 컴퓨터와 통신기기 내부버스와 외부 인터페이스에 전용 암호처리용 하드웨어 설치  \r\n전용 하드웨어로 암호화함으로써 컴퓨터 CPU에 부담을 주지 않고 빠른 속도로 암호화, 보안성 확보에 바람직  \r\n\r\n__(나) 소프트웨어 암호시스템__  \r\n암호처리용 소프트웨어를 사용한 데이터 암호화  \r\n저렴한 비용으로 실현 가능, 허용범위 내에서 적당한 안정성과 처리속도 얻을 시 상당히 효과적  \r\n개인 PC 성능 증진으로 처리속도 문제되지 않아 최근에는 소프트웨어 암호화가 주류  \r\n\r\n##3. 주요 암호기술에 대한 개괄\r\n\r\n###1) 대칭키 암호와 비대칭키 암호\r\n대칭키 암호(symmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 동일  \r\n비대칭키 암호(asymmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 서로 다름  \r\n비대칭키 암호 알고리즘 사용 시 송신자도 한 쌍의 키를 가지고 있어야 하고 수신자도 자신만의 한 쌍의 키 가져야함  \r\n\r\n###2) 하이브리드 암호 시스템  \r\n대칭키 암호와 공개키 암호를 조합한 암호 방식을 하이브리드 암호 시스템(hybrid cryptosystem)이라고 함  \r\n두 방식의 장점을 조합  \r\n\r\n###3) 일방향 해시함수\r\n해시값은 일방향 해시함수(one-way hash function)를 사용하여 계산한 값  \r\n무결성 제공  \r\n\r\n###4) 메시지 인증코드 \r\n메시지가 예상 통신 상대로부터 온 것을 확인하기 위해 메시지 인증코드(message authentication code)라는 기술 사용  \r\n메시지 인증코드 사용 시 메시지가 전송 도중에 변경되지 않았다는 것과 생각했던 통신 상대로부터 왔다는 것 확인 가능  \r\n메시지 인증코드는 무결성과 인증 제공  \r\n\r\n###5) 전자서명 \r\n거짓 행세(spoofing), 변경, 부인의 위험을 방지하는 기술  \r\n무결성 확인, 인증과 부인방지 제공  \r\n\r\n###6) 의사난수 생성기\r\n의사난수 생성기(PRNG, pseudo random number generator)는 난수열을 생성하는 알고리즘  \r\n난수는 키 생성(key generator)이라는 매우 중요한 역할  \r\n\r\n\r\n##4. 암호 분석(암호 해독)\r\n\r\n###1) 개요\r\n암호 방식의 정규 참여자 외 제3자가 암호문으로부터 평문을 찾으려 하는 것을 암호 해독(cryptanalysis) 또는 공격이라 함   \r\n공격자 = 암호 해독자, 제3자, 침해자  \r\n평문의 통계적 성질, 암호에 관한 지식, 장비 등 통해 암호문에서 평문 또는 키 찾아냄  \r\n\r\n * 케르히호프의 원리(Kerchhoff's principle) : 암호시스템의 안전성은 암호 알고리즘의 비밀을 지키는데 의존되지 말고, 키의 비밀을 지키는데 의존되어야 한다는 원리\r\n\r\n\r\n###2) 암호 분석의 분류\r\n\r\n__(가) 암호문 단독 공격(COA, Ciphertext Only Attack)__  \r\n암호문 단독 공격은 공격자가 암호문을 얻어서 대응되는 평문과 키를 찾는 것  \r\n공격에 암호문만 필요, 공격자의 메시지 복호화를 막기 위해 이런 종류의 공격에 안전해야 함, 다양한 방법이 이 공격에 사용(평문의 통계적 성질, 문장의 특성 등)  \r\n\r\n__(나) 기지 평문 공격 (KPA, Known Plaintext Attack)__  \r\n기지(알려진) 평문 공격에서 공격자는 암호문 외에 추가로 여러 개의 평문/암호문 쌍을 얻음(미리 갖고 있음)  \r\nAlice가 Bob에게 비밀 메시지를 보냈지만 나중에 그 메시지를 공개한다면, 공격자(Eve)가 공개된 평문/암호문 쌍을 사용해 다음 A to B 보내려는 비밀 메시지를 알아내는데 사용  \r\n\r\n__(다) 선택 평문 공격(CPA, Chosen Plaintext Attack)__  \r\n선택 평문 공격은 알려진 평문 공격과 유사하지만 공격자에게 주어지는 평문/암호문 쌍을 공격자가 선택  \r\ne.g.) 공격자가 A의 컴퓨터에 접속하여 어떤 평문을 선택하고 이에 대응하는 암호문을 얻음  \r\n공격자가 평문을 선택하면 대응하는 암호문을 얻을 수 있는 경우    \r\n\r\n__(라) 선택 암호문 공격(CCA, Chosen Ciphertext Attack)__  \r\n선택 암호문 공격은 공격자가 어떤 암호문을 선택하고 그에 대응되는 평문을 얻음(그 외에는 선택 평문 공격과 유사)  \r\n공격자가 수신자의 컴퓨터에 접속 가능할 경우 적용 가능(공격자가 복호기에 접근 가능한 경우 : 암호문 선택시 대응 평문 얻을 수 있을 경우)  \r\n선택된 암호문(임의의 암호문이거나 계획에 의한 암호문 모두)을 복호화할 수 잇는 능력을 갖추고 있는 기계를 일반적으로 [Decryption Oracle, 복호 오라클]이라 부름  \r\n개인키로 암호화된 암호문을 알려진 공개키로 복호화할 수 있는 공개키 암호화 시스템에 대한 해독 공격에 주로 사용됨  \r\n선택 암호문 공격에 견딜 수 있는 알고리즘은 강한 알고리즘이라 말할 수 있음  \r\n\r\n\r\n * Rubber-Hose Cryptanalysis 고무호스 암호분석 : 암호분석가가 키를 얻을 때까지 키를 가진 사람을 공갈, 협박, 고문하여 키를 획득...\r\n\r\n * 임시파일 : 대부분 암호화 시스템은 계산과정에서 임시파일 사용, 임시파일 삭제 혹은 덮어 쓰기 안될 시 이 정보에 의해 암호 해독 가능  \r\n\r\n\r\n##5. 암호 알고리즘의 안전성 평가\r\n\r\n###1) 안전성 개념 \r\n\r\n주어진 암호 시스템의 안전성을 말할 때는 두 가지 관점  \r\n1. 암호시스템 공격을 위해 필요한 계산량이 매우 커 현실적으로 공격 불가한 경우 : __계산적 안전__  \r\n2. 무한한 계산능력에도 공격 불가한 경우 __무조건적으로 안전__  \r\n다음 기준을 만족하는 알고리즘 필요  \r\n * 암호 해독 비용이 암호화된 정보의 가치를 초과\r\n * 암호 해독 시간이 정보의 유효 기간을 초과\r\n\r\n - 워크팩터(Work Factor) : 공격자가 암호화 방법을 깨는데 걸리는 노력(리소스)\r\n\r\n\r\n###2) 암호제품 평가체계 \r\n\r\n정보보호제품의 신뢰기관의 안정성평가 결과 : 가장 대표적인 것이 __CC(Common Criteria)__ 기반의 정보보호제품 평가  \r\nCC기반의 평가 기준은 암호 알고리즘에 대한 평가기준 명시 안됨, 각국이 독자적으로 규정, 평가  \r\n__암호모듈__에 대한 안정성평가로 가장 널리 참조 되는 미국 NIST가 수행하는 __CMVP(Cryptographic Module Validation Program)__, 세계적으로 인정 받음  \r\n\r\n###3) 암호기술 평가\r\n\r\n__(가) 평가 종류__  \r\n1. 암호 알고리즘 평가\r\n  정보보호제품에 탑대된 암호 알고리즘에 대한 안정성 평가\r\n  알고리즘 자체만을 평가, 따라서 제품이나 시스템과 독립적, 일반적으로 알고리즘 자체의 이론적 안정성만을 평가  \r\n\r\n2. 암호모듈 평가 e.g.) __CMVP__    \r\n  암호 알고리즘을 이용하여 제공되는 암호서비스(기밀성 기능 모듈, 무결성 기능 모듈)에 대한 안정성 평가  \r\n  알고리즘 자체의 이론적 안정성과는 별개, 암호모듈의 암호서비스 기능의 안정성 평가  \r\n\r\n3. 정보보호제품 평가  \r\n  암호모듈을 탑재한 정보보호 제품(예 : 침입차단시스템, 침입탐지시스템)에 대한 안정성 평가  \r\n\r\n4. 응용시스템 평가  \r\n  각 제품을 상호 연동하여 구성되는 시스템(예 : 국가기관망의 네트워크에 대한 보안성 평가, 항공관제센터의 안전성 평가)에 대한 안정성 평가  \r\n\r\n\r\n__(나) 평가 과정__  \r\n1. 안전성 평가는 응용시스템을 평가하는게 가장 바람직하나 현실적으로 어려움  \r\n2. 그러므로 응용시스템의 가장 기본이 되는 암호 알고리즘에 대한 안전성 평가 우선되어야함  \r\n3. 알고리즘으로부터 모듈, 제품, 시스템 순으로 안전성 평가 수행 바람직  \r\n\r\n\r\n###4) 암호모듈의 안전성 평가(CMVP)\r\n\r\n__(가) 개요__  \r\nㄱ. 암호기술의 구현 적합성 평가  \r\nㄴ. 암호키 운용 및 관리  \r\nㄷ. 물리적 보안  \r\n\r\n\r\n##6. 지적 재산권 보호\r\n\r\n###(1) 디지털 저작권 관리\r\n\r\n####1) 스테가노그래피(Steganography)\r\n암호화와 다른 개념, 다른 무언가로 감추어 메시지 자체를 은폐  \r\ne.g.) 사진 속에 미세한 변화로 정보 입력  \r\n\r\n####2) 디지털 워터마킹(Digital Watermarking)\r\n워터마킹 : 위조지폐 감별을 위해 물에 젖은 상태에서 인쇄한 그림을 불빛에 비추면 그림이 보이도록 하는 기술에서 유래  \r\n원본 내용 왜곡하지 않는 범위에서 저작권 정보를 디지털 컨텐츠에 삽입하는 기술  \r\n- 강한(강성) 워터마킹 : 공격을 받아도 쉽게 파괴, 손상 없음\r\n- 약한(연성) 워터마킹 : 공격 받을 시 쉽게 파괴, 손상  \r\n\r\n\r\n####3) 핑거프린팅(Fingerprinting) \r\n1. 디지털 컨텐츠 구매 시 구매자의 정보를 삽입, 불법 배포 발견 시 최초 배포자 추적 가능케 하는 기술  \r\n2. 판매되는 컨텐츠마다 구매자의 정보 들어감, 불법 배포 컨텐츠 내에서 핑거프린팅 정보 추출하여 구매자 식별, 법적 조치 가능케 함  \r\n\r\n\r\n####4) 디지털 저작권 관리(DRM, Digital Rights Management)\r\n__(가) 개요__  \r\n1. DRM은 디지털 컨텐츠 소유자가 자신의 컨텐츠에 대한 접근을 자신 또는 자신의 위임자가 지정하는 다양한 방식으로 제어 가능케 하는 기술적 방법 또는 방법의 집합  \r\n2. 컨텐츠 접근을 제한 실행, 보기, 복제, 출력, 변경 등  \r\n\r\n__(나) DRM 구성 요소__  \r\n1. 메타데이터(Metadata)  \r\n\r\n2. 패키저(Packager) : 컨텐츠와 메타데이터를 함께 Secure Container 포맷으로 패키징하는 모듈  \r\n\r\n3. 시큐어 컨테이너(Secure Container) : DRM 보호 범위 내 유통되는 컨텐츠 배포 단위  \r\n\r\n4. 식별자(Identifier) : 컨텐츠 식별  \r\n\r\n5. DRM 제어기(DRM Controller) : 컨텐츠를 이용하는 사용자의 PC 또는 디바이스 플랫폼에서 컨텐츠가 라이센스에 명시된 범위 내에서 지속적으로 보호될 수 있도록 프로세스 제어  \r\n\r\n\r\n__(다) DRM 모델__  \r\n1. 컨텐츠 제공자(Content Provider), 컨텐츠 배포자(Distributer), 컨텐츠 소비자(Content Consumer), 클리어링하우스(ClearingHouse)  \r\n\r\n2. 컨텐츠 제공자  \r\n  컨텐츠의 디지털 권리를 가지고 권리 보호 원하는 DRM 사용자  \r\n  권리 표현 언어(REL, Rights Expression Language) : 컨텐츠 사용 규칙 표현 언어 e.g.) 대표적으로 ODRL(Open Digital Rights Language), MPEG(Moving Picture Expert Group)  \r\n\r\n3. 컨텐츠 배포자  \r\n  컨텐츠 유통 채널(e.g. 온라인 쇼핑몰)\r\n  정당 소비자에게 컨텐츠 안전하게 전달, 클리어링하우스로부터 대금 분배 받음  \r\n\r\n4. 컨텐츠 소비자  \r\n  클리어링하우스를 통해 컨텐츠에 대한 권리 요청, 대금 지불  \r\n\r\n5. 클리어링하우스  \r\n  디지털 허가를 소비자에게 발급, 제공자에게 로열티 수수료 지불, 배급자에게 배급 수수료 지불하는 재정적 거래 취급, 모든 소비자에게 허가된 사용을 기록하는 책임 있음  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/정보보안기사 2장 - (1) 암호학 개요/"},"frontmatter":{"title":"정보보안기사 2장 - (1) 암호학 개요","published":true}}},{"node":{"rawMarkdownBody":"\r\n#커널 소스 구하기\r\n\r\n[http://www.kernel.org](http://www.kernel.org)\r\n\r\n\r\n[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\r\n\r\n\r\n\r\n#커널 소스 설치\r\n\r\nbzip2 형식 압축 해제  \r\n`$ tar xvjf linux-x.y.z.tar.bz2`  \r\n\r\n\r\nGNU zip 형식 압축 해제  \r\n`$ tar xvzf linux-x.y.z.tar.gz`  \r\n\r\n\r\n* 커널 소스는 보통 /usr/src/linux에 설치된다. 여기 접근하려면 루트 권한 필요, 새 커널 설치 시에만 루트 권한 사용하여 접근하고 그때에도 이 디렉토리 내용은 건드리면 안된다.\r\n\r\n\r\n\r\n#패치\r\n\r\n점증적 패치를 적용하려면,   \r\n`$ patch -p1 < ../patch-x.y.z`  \r\n\r\n\r\n#커널 소스 트리\r\n\r\n| 디렉토리 | 설명 |\r\n| :-------- | :-------- |\r\n| arch | 특정 아키텍처와 관련된 소스 |\r\n| block | 블록 입출력 계층 |\r\n| crypto | 암호화 API |\r\n| Documentation | 커널 소스 문서 |\r\n| drivers | 장치 드라이버 |\r\n| firmware | 특정 드라이버를 사용할 때 필요한 장치 펌웨어 |\r\n| fs | 가상 파일시스템 및 개별 파일시스템 |\r\n| include | 커널 헤더 파일 |\r\n| init | 커널 시작 및 초기화 관련 코드 |\r\n| ipc | 프로세스 간 통신 관련 코드 |\r\n| kernel | 스케줄러와 같은 핵심 커널 서브시스템 |\r\n| lib | 유틸리티 루틴 |\r\n| mm | 메모리 관리 서브시스템 및 가상 메모리 |\r\n| net | 네트워크 서브시스템 |\r\n| samples | 예제, 데모 코드 |\r\n| scripts | 커널을 빌드하는 데 사용하는 스크립트 | \r\n| security | 리눅스 보안 모듈 |\r\n| sound | 사운드 서브시스템 |\r\n| usr | 초기 사용자 공간 코드 initramfs |\r\n| tools | 리눅스 개발에 유용한 도구 |\r\n| virt | 가상화 기반 구조 |\r\n\r\n* 소스트리 최상위에 있는 파일 : COPYING 파일은 커널 저작권 파일, CREDITS 파일에는 커널 개발 기여 개발자 명단, MAINTAINERS 파일에는 커널 서브시스템과 드라이버를 관리하는 사람들 명단, Makefile은 커널의 기본 __Makefile__\r\n\r\n\r\n#커널 설정\r\n\r\n커널 설정 옵션은 __CONFIG__으로 시작하는 CONFIG_FEATURE과 같은 형태\r\ne.g.) CONFIG_SMP : SMP 지원 여부\r\n\r\n두가지 혹은 세가지 설정 값(보통 드라이버의 경우 세 가지 선택이 가능)을 지님.\r\n\r\n__yes__ or __no__ (or __module__)\r\n\r\n__module__ 값을 가지는 경우 해당 기능은 모듈 형태(동적으로 로드할 수 있는 별도 오브젝트)로 컴파일된다.\r\n\r\n\r\n\r\n","fields":{"slug":"/리눅스 커널 (2)/"},"frontmatter":{"title":"리눅스 커널 (2)","published":true}}},{"node":{"rawMarkdownBody":"\r\nLatex 문법으로 수식 표현을 간단하게 할 수 있는 플러그인으로 Katex, MathJax 두 가지가 있는데,  \r\n\r\nMathJax는 dependency도 많고 Katex가 렌더링이 체감될 정도로 빠르므로 Katex 플러그인으로 수식표기를 하기로 결정했다.\r\n\r\n \r\n\r\nKatex 플러그인을 Gatsby 블로그에 적용하기 위해서 우선,  \r\n\r\n`$ npm install --save gatsby-remark-katex katex`  \r\n또는  \r\n`$ yarn add gatsby-remark-katex katex`  \r\n을 통해 katex를 설치해준다.  \r\n\r\nKatex 플러그인을 사용하기 위해 __gatsby-transformer-remark__ 플러그인이 필요한데, 마크다운 설정이 미리 되어있다면 이미 설치되어있을 수 있다.  \r\n\r\n\r\n###gatsby-config.js\r\n```js\r\nmodule.exports = {\r\n  // \r\n  plugins: [\r\n    \r\n    {\r\n      resolve: `gatsby-transformer-remark`,\r\n      options: {\r\n        plugins: [\r\n          \r\n          {\r\n            resolve: `gatsby-remark-katex`,\r\n            options: {\r\n              // Add any KaTeX options from https://github.com/KaTeX/KaTeX/blob/master/docs/options.md here\r\n              strict: `ignore`,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    \r\n  ],\r\n}\r\n```\r\n__gatsby-transformer-remark__ 안에 __gatsby-remark-katex__이 들어가는 꼴로 작성해야 한다.\r\n\r\n\r\n***\r\n\r\n\r\n[공식문서](https://www.gatsbyjs.org/packages/gatsby-remark-katex)에   \r\n\r\nAdd Katex CSS to your template: Katex’s CSS file is required to render the formulas correctly. \r\nInclude the CSS file in your template (example):\r\n\r\n``require(`katex/dist/katex.min.css`)``  \r\n\r\n__katex.min.css__를 참조할 수 있도록 조치하라고 되어있는데,  \r\n\r\nblog post를 띄우는 __src/templates/(포스트 관련.js)__ 파일 안에\r\n\r\n나의 경우에는 `import '../../../node_modules/katex/dist/katex.min.css';`를 추가하여 해결하였다.\r\n\r\n\r\n***\r\n\r\n이제 Katex가 적용된다.\r\n\r\n'$' 문자 하나 사이에 표현하는 inline,\r\n두개 사이에 표현하는 block 방식으로 사용할 수 있다.\r\n\r\n`$a^2 + b^2 = c^2$ 인라인`  \r\n\r\n$a^2 + b^2 = c^2$ 인라인\r\n\r\n```\r\n$$\r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n```\r\n$$\r\na^2 + b^2 = c^2   \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n\r\n","fields":{"slug":"/Gatsby 블로그 수식 표현 플러그인 Katex 적용법/"},"frontmatter":{"title":"Gatsby 블로그 수식 표현 플러그인 Katex 적용법","published":true}}},{"node":{"rawMarkdownBody":"\r\n#01 정보보호관리의 개념\r\n\r\n##1. 정보화 사회의 정보보호\r\n\r\n###(1) 정보사회의 특성과 정보화 역기능\r\n\r\n####1) 정보사회의 특성\r\n 초고속 정보통신 기반구조, 인터넷의 확산과 전자상거래, 사회 모습은 변화, 다양한 특성  \r\n 재택근무가 증가, 홈뱅킹이나 사이버 주식거래   \r\n 미래전쟁 양상으로 떠오르는 정보전쟁, 자동화된 지휘통제시스템과 해커 * 바이러스를 이용하는 사이버 전쟁 개념  \r\n\r\n●\t사이버환경의 특징\r\n-\t비대면성\r\n-\t익명성\r\n-\t시간 및 공간적 운영의 무제한성\r\n-\t무제한적인 정보 및 신속한 전송\r\n-\t미래의 범죄 및 전쟁 공간\r\n\r\n####2) 정보화 역기능\r\n 역기능적인 문제점 또한 갈수록 심각  \r\n 개인의 프라이버시 침해, 해커와 바이러스의 기승, 불법적인 위 * 변조를 통한 각종 컴퓨터 범죄행위, 정보시스템의 파괴에 의한 사회마비 등  \r\n 모바일 환경에서의 정보보호, 중요정보의 노출과 프라이버시 침해 등  \r\n\r\n●\t최근 사이버공격의 특징\r\n-\t공격 기술의 지능화 및 고도화\r\n-\t사이버 공격 전파경로의 다원화\r\n-\t사이버 공격의 초고속화 및 초단기화\r\n-\t사이버 공격의 분산화 및 에이전트화\r\n\r\n\r\n###(2) 정보보호(Information Security)\r\n\r\n####1) 정의 \r\n [정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위]  \r\n 정보보호 : [기밀성, 무결성, 가용성, 인증성 및 부인방지를 보장하기 위하여 기술적 * 물리적 * 관리적 보호대책을 강구하는 것]   \r\n\r\n####2) 정보의 가용성과 안정성(보안성)\r\n 정보의 가용성과 보안 측면에서 정보보호 : [정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위]  \r\n 가용성을 극대화, 정보의 통제는 위협 요소를 줄이고 안정성을 확보  \r\n\r\n●\t가장 쉬운 침투방법 선택 원리(principle of easiest penetration)\r\n-\t침입자는 이용 가능한 모든 침투수단을 이용할 것이다. 침투는 가장 분명한 수단을 이용하여 일어나는 것이 아니고, 침투에 대한 강력한 대비책이 마련되어 있다면 일반적으로 쉽게 이루어지지 않을 것이다. \r\n\r\n●\tNIST의 컴퓨터 보안 정의\r\n-\t정보시스템 자원(하드웨어, 소프트웨어, 펌웨어, 정보/데이터, 통신)의 무결성, 가용성, 기밀성을 보전하고자 하는 목표 달성을 위해 자동화된 정보시스템에 제공하는 보호(컴퓨터 보안에 있어서 가장 핵심이 되는 3가지 주요 목표 제시)\r\n\r\n\r\n####3) 정보보호의 목표\r\n__(가) 기밀성(Confidentiality)__  \r\n직 인가된(authorized) 사람, 인가된 프로세스, 인가된 시스템만이 알 필요성(Need-to-know)에 근거하여 시스템에 접근해야 한다는 원칙  \r\n데이터 처리의 모든 접속점에서 필요한 수준의 비밀 엄수(secrecy)가 강제, 정보 유출을 예방  \r\n접근 제어, 암호화  \r\n\r\n__(나) 무결성(Integrity)__  \r\n네트워크를 통하여 송수신되는 정보의 내용이 불법적으로 생성 또는 변경되거나 삭제되지 않도록 보호  \r\n전력차단과 같은 시스템 중단 경우에도 위반 가능  \r\n접근 제어, 메시지 인증 등으로 보장, 침입 탐지, 백업 등으로 예방\r\n\r\n__(다) 가용성(Availability)__  \r\n시스템이 지체 없이 동작, 합법적 사용자가 서비스 사용  \r\n정보의 비가용성 해로움  \r\n데이터의 백업, 중복성의 유지, 물리적 위협요소로부터의 보호 등  \r\n\r\n__(라) 인증성(인증, Authenticity, Authentication)__  \r\n진짜라는 성질을 확인할 수 있고, 확인 및 신뢰할 수 있다는 것, 출처 유효성에 대한 확신  \r\n\r\n__(마) 책임추적성(책임성, Accountability)__  \r\n개체의 행동을 유일하게 추적해서 찾아낼 수 있음  \r\n부인 봉쇄, 억제, 결함 분리, 침입 탐지 예방, 사후 복구와 법적인 조치 등  \r\n보안 침해에 대한 책임이 있는 곳까지 추적  \r\n시스템은 활동 상황을 기록, 포렌식(forensic) 분석을 하여 보안 침해를 추적하여 전송 관련 분쟁 해결\r\n\r\n●\tCIA Triad(삼각형)\r\n-\t1. 가용성\r\n-\t2. 무결성\r\n-\t3. 기밀성  \r\n●\t정보를 안전하게 보호하기 위해서는 비인가된 접근으로부터 안전하고(기밀성), 비인가된 변경으로부터 보호되어야 하며(무결성), 필요할 때 권한이 있는 사용자가 이용할 수 있어야 한다(가용성).\r\n\r\n●\t추가 정보보호 목표\r\n-\tCIA Triad를 사용해서 보안 목적을 잘 정의했지만, 보안 목적을 완성되게 표현하려면 보안 실무 필드에서 필요한 개념을 추가해야만 한다. 그 중에서 가장 많이 언급되는 개념은 인증성, 책임추적성이다.\r\n\r\n●\t부인 봉쇄(부인방지)\r\n-\t메시지의 송수신이나 교환 후, 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술\r\n\r\n\r\n##2. 정보보호 관리\r\n\r\n###1) 정보보호 관리(Information Security Management)의 개념\r\n\r\n●\t정보보호와 정보보호 관리 시스템\r\n-\t정보보호 : 정보의 수집/가공/저장/검색/송신/수신 중에 발생하는 정보의 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단, 또는 그러한 수단으로 이루어지는 행위. \r\n-\t정보보호 관리 시스템 : 정보통신 서비스 제공자가 정보통신망의 안정성 및 신뢰성을 확보하여 정보자산의 기밀성, 무결성, 가용성을 실현하기 위한 관리적 * 기술적 수단과 절차 및 과정을 체계적으로 관리, 운영하는 체계. 2010년부터 행정 기관은 정보보호관리 시스템(ISMS) 인증을 의무적으로 받아야 한다. \r\n\r\n\r\n###2)  정보보호 관리와 정보보호 대책\r\n__(가) 개요__\r\n1.\t정보보호 관리는 기술적 보호대책, 물리적 보호대책, 관리적 보호대책으로 계층적 구분  \r\n\r\n \r\n__(나) 기술적 보호대책__  \r\n가장 기본적인 대책  \r\n접근통제, 암호기술, 백업 체제, 정보시스템 자체에 보안성이 강화된 시스템 소프트웨어를 사용 등  \r\n\r\n__(다) 물리적 보호대책__  \r\n자연재해로부터 정보시스템이 위치한 정보처리시설을 보호  \r\n불순 세력이나 적의 파괴 대비한 출입통제, 시건(잠금) 장치 등  \r\n\r\n__(라)  관리적 보호대책__  \r\n법 * 제도 * 규정 * 교육 등, 보안계획을 수립(보안등급, 액세스 권한 등), 위험분석 및 보안감사  \r\n제도 * 정책 * 절차 등도 매우 중요  \r\n내부자의 부당행위를 방지하기 위한 교육  \r\n\r\n\r\n●\t기술적 보호대책 : 접근 통제, 암호 기술, 백업 체제 등  \r\n●\t물리적 보호대책 : 화재, 수해, 지진, 태풍 등  \r\n●\t관리적 보호대책 : 법 * 제도 * 규정 *교육 등  \r\n\r\n●\t정보보호 관리는 기업과 조직의 비즈니스 목적을 충족시키면서 수용 가능한 수준으로 위험을 낮추는 것  \r\n●\t위험은 제거대상이 아닌 관리대상  \r\n●\t위험은 식별되거나 감소될 수 있지만 제거될 수는 없음  \r\n●\t정보보호 관리를 위해서는 최고 경영진의 지원과 관심이 반드시 필요  \r\n\r\n\r\n##3. OSI 보안 구조\r\n\r\n###(1) 개요\r\n####1) 기본 개념\r\n ITU-T 권고안 X.800, OSI 보안 구조 : 관리자가 효과적으로 보안 문제를 조직화 하는데에 유용  \r\n●\t보안 공격(Security attack) : 기관이 소유한 정보의 안전성을 침해하는 제반 행위.  \r\n●\t보안 메커니즘(Security mechanism) : 보안 공격을 탐지, 예방하거나 공격으로 인한 침해를 복구하는 절차.  \r\n●\t보안 서비스(Security service) : 조직의 정보 전송과 데이터 처리 시스템의 보안을 강화하기 위한 처리 또는 통신 서비스. 이 서비스는 보안 공격에 대응하기 위한 것이며, 하나 또는 그 이상의 보안 메커니즘을 사용하여 서비스를 제공한다.   \r\n\r\n●\t공격 : 지적인 위협을 수반하는 시스템 보안에 대한 침범을 말한다. 여기서 지적인 위협이란 보안서비스를 교묘히 피하거나 시스템 보안 정책을 위반하는 정교한 시도(특히 방법과 기술 측면에서)를 말한다.  \r\n\r\n###(2) 보안 공격(Security attack)\r\n\r\n####1) 개요\r\n보안의 세 가지 목표(기밀성, 무결성, 가용성)는 보안 공격에 의해 위협  \r\n보안 목표에 관련하여 세 개의 그룹, 공격을 시스템에 미치는 영향에 따라 두 개의 유형  \r\n\r\n●\tOSI 보안 구조는 보안 공격과 보안 기법, 보안 서비스를 체계적으로 정의할 수 있는 틀을 제공한다.   \r\n●\t보안 공격은 소극적 공격과 적극적 공격으로 분류할 수 있다. 소극적 공격에는 파일이나 메시지를 불법적으로 읽거나, 트래픽을 분석하는 것이 포함되고, 적극적 공격에는 파일이나 메시지를 수정하거나, 서비스 거부 공격 등이 포함된다.   \r\n\r\n####2) 기밀성을 위협하는 공격\r\n__(가) 스누핑(Snooping)__  \r\n데이터에 대한 비인가 접근 또는 탈취  \r\n\r\n__(나) 트래픽분석(Traffic Analysis)__  \r\n온라인 트래픽을 분석함으로써 다른 형태의 정보 얻기 가능  \r\nex) 전송의 성향을 추측하는데 도움이 되는 질의와 응답의 쌍을 수집  \r\n\r\n####3) 무결성을 위협하는 공격\r\n__(가) 변경(메시지 수정, Modification)__  \r\n적법한 메시지의 일부를 불법으로 수정하거나 메시지 전송을 지연시키거나 순서를 뒤바꾸어 인가되지 않은 효과를 노리는 행위  \r\n\r\n__(나) 가장(Masquerading)__  \r\n신분위장은 한 개체가 다른 개체의 행세, 다른 형태의 적극적 공격과 병행해서 수행  \r\n\r\n__(다) 재연(재전송, Replaying)__  \r\n적극적 공격의 하나로, 획득한 데이터 단위를 보관하고 있다가 시간이 경과한 후에 재전송  \r\n인가되지 않은 사항에 접근하는 효과를 노리는 행위  \r\n\r\n__(라) 부인(Repudiation)__  \r\n자신이 메시지를 보냈다는 것을 부인 또는 메시지를 받았다는 것을 부인  \r\n부인방지(부인 봉쇄, Nonrepudiation)  \r\n●\t부인 봉쇄란 송신자나 수신자 양측이 메시지를 전송했거나 수신한 사실 자체를 부인하지 못하도록 막는 것을 말한다. \r\n\r\n####4) 가용성을 위협하는 공격\r\n__(가) 서비스 거부(Denial of Service)__  \r\n시스템의 서비스를 느리게 하거나 완전히 차단  \r\n\r\n●\t공격의 발원지에 따른 구분\r\n-\t내부 공격 : 보안 경계 내부의 존재에서 시작된 공격, 내부자에게 시스템 자원접근은 허가되나 허용된 권한 이상으로 사용할 때 발생\r\n-\t외부 공격 : 보안 경계 외부에서 허가되지 않은 불법적인 사용자에 의해 시작된 공격, 공격자는 인터넷상의 아마추어부터 조직화된 범죄자, 국제 테러리스트, 적국의 정부 등일 수 있다.  \r\n\r\n\r\n####5) 소극적 공격과 적극적 공격\r\n __(가) 개요__  \r\n보안 공격(Security attack)을 X.800과 RFC 2828에 따라 분류하면 소극적 공격(passive attack)과 적극적 공격(active attack)으로 나눔  \r\n\r\n| Attack | Passive/Active | Threatening |\r\n|:--------:|:--------:|:--------:|\r\n| Snooping, Traffic analysis | Passive | Confidentiality |\r\n| Modification, Masquerading, Replaying, Repudiation | Active | Integrity |\r\n| Denial of Service | Active | Availability |\r\n\r\n__(나) 소극적 공격(수동적 공격, Passive Attack)__  \r\n목표는 단지 정보를 획득, 공격자가 데이터를 변경하거나 시스템에 해를 끼치지 않는다는 것    \r\n송신자나 수신자는 제3자가 메시지 패턴을 관찰하는지 알 수 없음. 따라서, 탐지보다 예방  \r\n\r\n__(다) 적극적 공격(능동적 공격, Active Attack)__  \r\n데이터를 바꾸거나 시스템에 해를 입힘, 결성과 가용성을 위협하는 공격  \r\n공격자가 다양한 방법을 사용하기 때문에 일반적으로 방어하기보다 탐지  \r\n치명적인 공격의 대부분  \r\n대부분의 능동적 공격은 상당 기간 동안의 수동적 공격 수행을 통해 수집된 정보를 바탕  \r\n\r\n●\tNIST의 정보보호 핵심 5원칙\r\n-\t1. 가용성\r\n-\t2. 무결성\r\n-\t3. 기밀성\r\n-\t4. 책임추적성(Accountability)\r\n-\t5. 보증(Assurance)\r\n\r\n##4. 기본 보안용어 정의\r\n####1) 자산(Asset)\r\n조직이 보호해야 할 대상으로서 데이터 혹은 자산 소유자(Data Owner)가 가치를 부여한 실체  \r\n\r\n####2) 취약점(취약성, Vulnerability)\r\n컴퓨터나 네트워크에 침입하여 환경 내의 리소스에 대한 허가되지 않은 접근을 시도하려는 공격자에게 열린 문을 제공할 수 있는 소프트웨어, 하드웨어, 절차 혹은 인력상의 약점을 가리킨다. 즉, 위협의 이용대상으로 관리적, 물리적, 기술적 약점  \r\n\r\n####3) 위협(Threat) : 위협은 취약성 제어수단에 의하여 차단된다.\r\n손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합  \r\n보안에 해를 끼치는 행동이나 사건  \r\n●\t가로채기(interception) : 비인가된 당사자가 자산으로의 접근을 획득한 것을 의미(불법 복사, 도청  등)  => __기밀성__에 영향   \r\n●\t가로막음(interruption) : 시스템 자산은 손실되거나, 손에 넣을 수 없거나, 사용불가능하게 됨(하드웨어 장치의 악의적 파괴, 파일 삭제, 서비스 거부 등) => __가용성__에 영향     \r\n●\t변조(modification) : 비인가된 당사자가 접근하여 그 내용을 변경(데이터베이스 특정값 변경, 특정 프로그램 변경 등) => __무결성__에 영향  \r\n●\t위조(fabrication) : 비인가된 당사자가 컴퓨팅 시스템상에 불법 객체의 위조 정보를 생성(네트워크 통신에 가짜 거래 정보 만듦 등) => __무결성__에 영향  \r\n\r\n| 분류 | 내용 |\r\n| :--------: | :--------: | \r\n| __자연에 의한 위협__ | 화재, 홍수, 지진, 전력 차단 등 자연에 의한 대표적인 위협으로부터 발생하는 재난을 항상 예방할 수는 없지만 화재경보기, 온도계, 무정전 시스템 등을 설치하여 피해를 최소화할 수 있다. |\r\n| __인간에 의한 위협__ | __비의도적 위협__ : 정보시스템의 보안 사고를 일으키는 가장 큰 위협으로 인간의 실수와 태만이 주된 원인이다. 패스워드의 공유, 데이터에 대한 백업의 부재 등이 대표적인 부주의와 태만으로 간주되며, 이러한 위협은 언론매체에서 크게 다루어지지는 않지만 실제로는 정보보호 문제를 일으키는 가장 중요한 요인이다. <br/>  __의도적 위협__ : 컴퓨터 바이러스, 해커, 사이버 테러리스트 등으로부터 발생하며 도청, 신분위장에 의한 불법 접근, 정당한 정보에 대한 부인, 악의적인 시스템 장애 유발 등이 있다. |\r\n\r\n\r\n####4) 위협주체(위협원, Threat agents)\r\n취약점을 이용하는 존재는 위협 주체(threat agent)  \r\n침입차단시스템의 포트를 통해 네트워크에 접근하는 침입자, 보안 정책을 위반하는 방식으로 데이터에 접근하는 프로세스, 시설물을 파괴하는 태풍, 혹은 의도하지 않은 실수로 기밀 정보를 누설하거나 파일의 무결성을 손상시키는 직원\r\n\r\n####5) 위험(Risk)\r\n위협 주체가 취약성을 활용할 수 있는 가능성과 그와 관련된 비즈니스 영향  \r\n위험은 [자산X위협X취약점]\r\n  \r\n####6) 노출(Exposure)\r\n위협 주체로 인해서 손실이 발생할 수 있는 경우  \r\n취약점은 조직에 있어서 가능한 피해를 노출  \r\n\r\n####7) 대책/안전장치(Countermeasure/Safeguard)\r\n잠재적 위험을 완화시키기 위해 배치  \r\n위험을 감소시키기 위한 소프트웨어 설정, 하드웨어 장비, 또는 절차  \r\n\r\n●\t취약성, 위협, 위험, 노출, 대책  \r\n-\t만약 기업이 백신 소프트웨어를 오직 서버에만 설치하고 바이러스 서명(Signature)을 최신으로 유지하지 않는다면 이는 취약성에 해당되며, 해당 기업은 바이러스 공격에 대하여 취약한 것이다. 위협은 해당 환경에서 발생하여 손해를 유발할 수 있는 가능성은 위험이다. 만약 바이러스가 기업의 환경에 침입한다면 취약성은 이용되었고 기업은 손실에 노출된다. 이 상황에 대한 대책은 바이러스 패턴 정보를 최신으로 갱신하여 백신 소프트웨어를 모든 컴퓨터에 설치하는 것이다. \r\n\r\n\r\n\r\n\r\n####8) 다계층 보안/심층 방어(Defense in Depth)\r\nMulti Layered(Level) Security, 여러 계층의 보안대책이나 대응수단을 구성  \r\n한 가지 통제가 대응에 실패하더라도 전체 시스템을 위험에 빠뜨리지 않음  \r\n가장 최선의 보안 접근 방법으로, 보호 * 탐지 * 대응으로 이루어진 보안 접근법  \r\n\r\n\r\n####9) 직무상의 신의성실, 노력(Due Care, Due Diligence)\r\nDue :  특정 목적을 위하여 필요하거나 요구되는 적절하고 충분한 의무이다.  \r\nDue care :  특정 목적을 위하여 필요하거나 요구되는 충분한 주의이다.  \r\nDue Diligence : 특정 목적을 위하여 필요하거나 요구되는 충분한 노력이다.  \r\n\r\n●\t심층 방어(Defense in Depth) : 다수의 통제를 구현함으로써 성공적 침투와 침해가 발생하는 것을 어렵게 만듦   \r\n●\t사회공학(Social Engineering) : 어떤 사람을 속임으로써 허가되지 않은 접근을 획득하는 것  \r\n  \r\n####10) 사회공학(Social Engineering)\r\n인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상적인 보안 절차를 깨트리기 위한 침입 수단  \r\n\r\n●\t가장 약한 링크 원칙(principle of weakness link)  \r\n-\t보안은 가장 약한 링크보다 더 강할 수 없다. 방화벽에 전력을 공급하는 전원장치이건, 보안 응용 기반으로 동작하는 운영체제이건, 또는 제어수단을 기획 * 실현하고 관리하는 사람들이건 간에 어떤 하나의 제어수단의 실패가 전체 보안실패를 야기한다.  \r\n\r\n●\t보안은 비대칭성(Asymmetrical) : 방어측은 모든 취약점을 알아내야 하지만, 공격자는 하나의 취약점이라도 발견하면 됨.  \r\n\r\n\r\n####11) 시점별 통제(Control)\r\n예방통제(Preventive Control) : 사전에 위협과 취약점에 대처하는 통제\r\n탐지통제(Detective Control) : 위협을 탐지하는 통제로, 빠르게 탐지할수록 대처하기 용이\r\n교정통제(Corrective Control) : 이미 탐지된 위협이나 취약점에 대처하거나, 위협이나 취약점을 감소시키는 통제\r\n\r\n| 구분 | 설명 |\r\n| :--------: | :--------: | \r\n| 공격자 | 시스템을 공격하거나 위협하는 존재 |\r\n| 공격 | 시스템의 보안 서비스를 회피하여 보안 정책을 위반하려는 의도된 시도 | \r\n| 대응 | 피해의 최소화 및 적절한 대응을 위해 탐지, 보고하여 위험, 노출, 공격을 제거하거나 방지하는 행위, 장비, 기법 |\r\n| 위험 | 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실 |\r\n| 보안 정책 | 시스템이나 기관이 민감하고 중요한 시스템 자원에 보안 서비스를 제공하기 위해 명시한 규정과 업무 |\r\n| 자산 | 정보 시스템 내의 데이터, 시스템의 서비스, 처리 기능, 통신 대역폭, 시스템 장비(하드웨어, 펌웨어, 소프트웨어, 문서), 시스템 장비 설비 |\r\n| 위협 | 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 때의 잠재적 보안 위반 |\r\n| 취약점 | 시스템 보안 정책을 위반할 수 있는 시스템 설계, 구현, 혹은 운영, 관리상의 오류 및 약점 |\r\n","fields":{"slug":"/정보보안기사 1장/"},"frontmatter":{"title":"정보보안기사 1장","published":true}}},{"node":{"rawMarkdownBody":"\r\nnpm 설치를 위해 node.js 설치하는 과정에서 \r\n\r\n__C:\\Users\\\\(계정이름)\\AppData\\Roaming\\npm-cache\\\\_libvips__ 의\r\n\r\n__libvips-8.7.4-win32-x64.tar.gz__ 파일이 누락됨.   \r\n(__libvips-8.8.1-win32-x64.tar.gz__을 포함한 다른 버전도 동일.)\r\n\r\n네트워크 문제로 파일을 가져오는데에서 문제가 생긴 것으로 보임.\r\n\r\ngithub realese 페이지에서 직접 받아도 다운링크에 접속을 못하여\r\n\r\n구글링을 통해 libvips 압축파일을 정리해둔 링크를 찾아서 해결.  [http://18.176.30.221/list/libvips](http://18.176.30.221/list/libvips)\r\n\r\n\r\n이를 통해 npm install 명령 실행 도중 getaddrinfo EFNOTFOUND 오류가 나며\r\n\r\n링크에서 파일을 받지 못하는 경우 해결 할 수 있음. \r\n\r\n\r\n***\r\n\r\nnode-gyp 설치가 필요하다면,\r\n\r\n\r\n네이티브 애드온 모듈 컴파일링을 하는 __node-gyp__를 설치\r\n\r\n'node-gyp' is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js\r\n\r\n\r\n`$ npm install -g node-gyp`\r\n\r\n\r\n***\r\n\r\n\r\nnode.js를 윈도우에 설치하고서 필수 요소(python2.7 등) 자동 설치를 위한 빌드 툴을 설치해야함.  \r\n`$ npm install --global --production windows-build-tools`\r\n\r\n이번 블로그 적용 중에는 이 것으로 해결이 안되고 아래와 같은 문제가 생김.\r\n\r\n\r\n***\r\n\r\nnode.js 설치 시 파이썬 등 필수 요소 자동설치를 해줘야하는데 \r\n\r\n실패하여 npm이 Python v2.7을 찾지 못하는 경우 \r\n \r\n기본경로인 __C:\\python27__ 경로로 파이썬2.7을 설치해준다.\r\n\r\n\r\n***\r\n\r\nvisual studio가 2019 버전이라 MSBuild.exe ENOENT 에러가 나는 경우, \r\n\r\n빌드를 위해 Visual C++ Build tools의 2015 또는 2017 버전이 필요한데\r\n\r\n따라서 설치해주면 해결된다. [Visual C++ Build tools 설치](https://go.microsoft.com/fwlink/?LinkId=691126)\r\n\r\nwindows 8.1 sdk만 설치해주면 되고,\r\n\r\n`$ npm config set python python2.7`  \r\n`$ npm config set msvs_version 2015`\r\n\r\n위와 같이 컨픽을 설정해주면 에러 없이 빌드된다.\r\n\r\n이번 경우 npm install 시 이 에러 발생.\r\n\r\n- 참고 : [https://github.com/nodejs/node-gyp/issues/1747](https://github.com/nodejs/node-gyp/issues/1747)\r\n\r\n\r\n***\r\n\r\n```\r\n> gatsby develop\r\n\r\nThe above error occurred in the <StoreStateProvider> component:\r\n    in StoreStateProvider\r\n    in App\r\n```\r\n\r\n위의 오류가 발생하는 경우  \r\n\r\nyarn 설치 후   \r\n\r\n`npm install --global yarn`  \r\n\r\ngatsby의 새 버전 재설치를 yarn으로 해주면  \r\n\r\n`yarn add gatsby`  \r\n\r\n\r\n다시 `gatsby develop`가 정상 작동한다.\r\n\r\n- 참고 : [https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201](https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201)\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/Gatsby 블로그 적용 도중 만난 에러/"},"frontmatter":{"title":"Gatsby 블로그 적용 도중 만난 에러","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n# 운영체제와 커널\r\n\r\n__운영체제__ : 정의 힘듬, but 기술적 관점 => 기본적인 사용과 관리 담당하는 시스템의 일부분\r\n - 커널, 장치 드라이버, 부트로더, 명령행 셸(동등 역할의 사용자 인터페이스 포함), 기본적인 파일 및 시스템 유틸리티 등  \r\n\r\n__시스템__ : 운영체제 + 그 위에서 동작하는 모든 애플리케이션 통틀음    \r\n\r\n__커널__ : (a.k.a 관리자supervisor, 코어core, 내부internals) \r\n - 인터럽트 핸들러, 스케줄러, 메모리 관리 시스템, 네트워크나 프로세스간 통신 처리하는 시스템 서비스 등     \r\n \r\n***\r\n \r\n__커널 공간__kernel-space : 보호 메모리 공간 사용, 제약 없는 하드웨어 접근 등이 가능  \r\n과  \r\n__사용자 공간__user-space :\r\n - 사용자 애플리케이션 실행됨/ 장비의 가용 자원 중 일부만 사용 가능 \r\n - 특정 시스템 함수 실행 가능, 하드웨어 직접 접근 및 커널이 할당한 영역 밖에 메모리 접근은 잘못된 동작  \r\n\r\n은 다른 (시스템)상태를 가짐     \r\n \r\n***\r\n\r\n\r\n커널 코드 실행 시 시스템은 커널 모드로 커널 공간에 있음  \r\n일반적인 프로세스 처리 시 시스템은 사용자 모드로 사용자 공간에 있음  \r\n\r\n실행 애플리케이션은 시스템 호출을 통해 커널과 통신  \r\n주로) 애플리케이션이 라이브러리 함수 호출 => 라이브러리가 시스템 호출 인터페이스 이용 커널이 애플리케이션을 대신해 필요한 작업 수행\r\n\r\n일부 라이브러리 호출은 시스템 호출에는 없는 여러 기능 제공하기도 함, 이 경우 커널 호출은 커다란 함수의 일부 한 단계가 됨     \r\n\r\n\r\nex) printf() : 데이터 출력 형식 지정 or 버퍼링 기능\r\n - 화면에 데이터 출력하기 위해 write() 시스템 호출 이용하는 것은 이 함수의 일부분\r\n\r\n일부 라이브러리 호출은 커널 호출과 일대일 대응\r\n\r\n한편, strcpy() 같은 C 라이브러리 함수는 커널 호출을 직접 사용하지 않음     \r\n\r\n\r\n\r\n* 애플리케이션이 시스템 호출을 실행하는 것을 애플리케이션을 대신에 커널이 실행 중이라고 표현\r\n* 또는 (= 애플리케이션이 커널 공간에서 시스템 호출을 실행 중 = 커널이 프로세스 컨텍스트를 실행 중)\r\n \r\n애플리케이션이 시스템 호출을 통해 커널을 이용하는 방식이 애플리케이션의 작업 수행의 기초적인 방식     \r\n\r\n***\r\n \r\n__커널은 시스템 하드웨어도 관리__ : 인터럽트 개념  \r\n__인터럽트__ : 종류는 숫자로 구분, 커널은 숫자로 인터럽트 처리, 응담할 인터럽트 핸들러 실행  \r\n - 커널이 동기화를 위해 새로운 인터럽트 블락 가능(모든 인터럽트 다 or 특정 인터럽트만)  \r\n - 리눅스 포함 대다수 운영체제 인터럽트 핸들러를 프로세스 컨텍스트에서 실행 안함  \r\n - 대신 프로세스와 분리되어 있는 별도의 인터럽트(전용) 컨텍스트에서 실행      \r\n \r\n \r\n \r\n컨텍스트는 커널의 활동 범주 나타냄  \r\n리눅스에서 프로세스는 세가지 중 한가지 일 하는 중\r\n - 사용자 공간에서 프로세스의 사용자 코드를 실행\r\n - 커널 공간의 프로세스 컨텍스트에서 특정 프로세스를 대신해 코드를 실행\r\n - 커널 공간의 인터럽트 컨텍스트에서 프로세스와 상관없이 인터럽트를 처리\r\n ex) 시스템 유휴상태 = 커널이 커널 모드의 프로세스 컨텍스트에서 idle 프로세스 실행     \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널과 전통적인 유닉스 커널\r\n\r\n* __리눅스는 유닉스와 유사, but 유닉스 아님__ : 유닉스 API(POSIX가 제정한 유일한 유닉스 표준) 구현하고 있지만 소스 물려받지 않음     \r\n\r\n\r\n\r\n리눅스에 __MMU__메모리 관리 장치 필요, 특펼히 없는 버전은 아주 작은 임베디드 시스템용  \r\n\r\n__유닉스 커널__ : 모놀리딕monolithic의 정적 바이너리  \r\n__리눅스 커널__ : 모놀리딕monolithic 커널이지만 마이크로 커널의 장점 수용\r\n - 모듈화 설계, 커널 선점(커널이 자신을 선점), 커널 스레드 지원, 별도의 바이너리(커널 모듈)를 커널 이미지에 동적으로 로드\r\n - 모든 작업은 커널 모드에서 실행, 통신 방식으로 X메세지 전달, O직접 함수 호출     \r\n \r\n*** \r\n \r\n__리눅스 커널 기준 전통적인 유닉스 시스템의 주요 차이점__\r\n - 커널 모듈 동적 로딩, 모노리딕 형식이지만 필요에 따라 동적으로 커널 코드 로드, 제거\r\n - 대칭형 멀티프로세서SMP 지원\r\n - 선점형 : 커널 내부에서 실행 중인 작업도 선점 가능\r\n - 독특한 방식으로 스레드 지원 : 정상 프로세스와 스레드 구분 안함/ 커널 입장에서 동등, but 자원 공유하는 프로세스들이 존재\r\n - 디바이스 클래스, 핫플러그 이벤트, 사용자 공간 디바이스 파일시스템sysfs => 객체지향적인 장치 모델 지원     \r\n \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널 버전\r\n\r\n(주버전).(부버전).(개정판).(안정 버전 일련번호)  \r\n부버전 짝수가 안정 커널\r\n \r\n \r\n\r\n","fields":{"slug":"/리눅스 커널 (1) - 리눅스 커널 입문/"},"frontmatter":{"title":"리눅스 커널 (1) - 리눅스 커널 입문","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}