{"componentChunkName":"component---src-pages-search-js","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"","fields":{"slug":"/리눅스 커널 (3) - 프로세스 관리/"},"frontmatter":{"title":"리눅스 커널 (3) - 프로세스 관리","published":true}}},{"node":{"rawMarkdownBody":"\r\n##1. 현대 대칭키 암호\r\n\r\n###(1) 현대 블록 암호\r\n\r\n####1) 현대 블록 암호의 구성요소\r\n\r\n__(가) 개요__  \r\n\r\n1. 현대 블록 암호는 __확산과 혼돈__ 성질 만족을 위해 전치 요소(P-박스), 치환 요소(S-box) 그 외 구성 요소 결합하여 설계됨.  \r\n2. 공격 방지 암호화를 위해 이동요소(shift), 교환요소(swap), 분할요소(split), 조합요소, 전치장치(transposition, P-box), 치환장치(substitution, S-box), XOR연산의 조합으로 만들어짐.  \r\n\r\n#####\r\n    \r\n* 혼돈 : 암호문과 키의 상관관계를 숨김\r\n* 확산 : 평문의 통계적 성질을 암호문 전반에 퍼뜨려 숨김 \r\n* 대칭키 암호 ≒ 관용 암호 ≒ 공통키 암호\r\n* 비대칭키 암호 ≒ 공개키 암호 \r\n\r\n\r\n__(나) P-박스__  \r\n\r\n1. 문자 단위 암호화, 고전 장치 암호를 병렬적으로 수행  \r\n   블록 암호에서는 단순(straight) P-box, 확장(expansion) P-box, 축소(compresssion) P-box 세 가지 종류.  \r\n   => 아웃풋 크기가 동일, 확장, 축소됨.\r\n2. 축소 P-box  \r\n   n bit 입력 m bit 출력, n>m, 입력 비트 중 특정 비트 소실되 출력 안됨.\r\n3. 확장 P-box  \r\n   n bit 입력 m bit 출력, n<m, 입력 비트 중 특정 비트는 한 개 이상의 출력 비트로 연결.  \r\n   비트를 치환하고 동시에 다음 단계에서 비트의 양을 증가시키고자 할 때 사용.\r\n4. 역함수의 존재성  \r\n   단순 P-box는 역함수 존재  \r\n   축소 P-box, 확장 P-box 역함수 존재 안함\r\n\r\n\r\n####2) S-박스\r\n\r\n__(가) 개요__  \r\n1. S-box는 치환 암호의 축소. 입력과 출력 개수 달라도 됨.\r\n2. 역함수 존재성 : 존재할 수도 안할 수도 있다. 역함수 존재하는 S-box는 입력과 출력 비트 수 동일.\r\n\r\n\r\n####3) 합성 암호(Product Ciphers)\r\n\r\n__(가) 개요__  \r\n1. 치환, 전치, 그리고 그 밖의 구성요소를 결합한 복합적인 암호\r\n\r\n__(나) 확산(Diffusion)과 혼돈(Confusion)__  \r\n1. 합성 암호의 주된 개념은 설계된 블록 암호가 확산, 혼돈 성질을 갖도록 하는 것\r\n2. 확산 : 암호문과 평문 사이의 관계를 숨기는 것. 암호문 통계 테스트를 통해 평문을 찾는 것 방지\r\n3. 혼돈 : 암호문과 키의 관계를 숨김. 암호문을 이용해 키를 찾는 것을 방지. 즉, 키의 단일 비트가 변하면 암호문의 거의 모든 비트가 변함. \r\n\r\n__(다) 라운드(Rounds)__\r\n1. 반복적 합성 암호를 통해 확산과 혼돈 얻음. 반복적 합성 암호를 라운드라고 칭함.\r\n\r\n\r\n####4) 두 가지 종류의 함성 암호\r\n\r\n__(가) Feistel 암호__  \r\n1. 3라운드 이상, 짝수 라운드로 구성. 라운드 함수와 관계없이 역변환 가능, 두 번의 수행으로 블록간의 완전한 확산이 이루어짐.  \r\n   알고리즘 수행 속도 빠르고, 하드웨어 및 소프트웨어 구현 용이, 아직 구조상 문제점 발견되지 않음.  \r\n   구조는 입력을 좌우 블록으로 분할하여 한 블록을 라운드 함수에 적용시킨 후의 출력 값을  \r\n   다른 블록에 적용하는 과정을 좌우블록에 대해 반복적으로 시행.  \r\n   라운드 키가 역순으로 작용한다는 점을 제외하면 암/복호화 과정이 동일하고 라운드 함수에 대한  \r\n   제약 조건이 없어 DES를 비롯한 대부분 블록암호에 채택.\r\n\r\n2. 암호 강도 결정 요소 : 평문 블록의 길이  >= 64 비트, 키 K의 길이 64 비트 내외, 라운드 수 >= 16회 권장\r\n\r\n3. 암호화, 복호화 과정 동일. 복호화 과정의 입력은 암호문과 보조키 $K_{i}$, 보조키의 입력 순서는 암호화 시 순서의 반대,  \r\n   즉, 복호화 첫 라운드 $K_{n-i}$, 마지막 라운드 $K_{1}$을 보조키로 입력.\r\n\r\n__(나) Feistel 암호 특징__  \r\n\r\n1. 입력 n 비트를 두 개의 블록 $(L_{0}, R_{0})$으로 나누어 라운드 함수 F, 라운드 키 $K_{i}$로 i 번째 라운드 과정  \r\n   주의) 최종 라운드에서 좌우 블록을 한 번 더 교환해야 함.  \r\n\r\n   $L_{i} = R_{i-1}$  \r\n   $R_{i} = L_{i-1} \\oplus F_{i}(R_{i-1},K_{i})$\r\n\r\n2. 페이스텔 네트워크는 많은 블록 암호 알고리즘에서 사용. AES 최종 후보 5개 중 3개 (MARS, RC6, Twofish)에서 사용.\r\n   AES 최종 선정된 Rijndael은 사용 안함.\r\n\r\n#####\r\n\r\n- __대칭 블록 암호 구현__  \r\n\r\n1. 블록 크기(Block size) : 블록 크기 크면 더 강한 보안, but 암 * 복호화 속도 저하. 128 비트가 조화로운 합리적 크기, 블록 암호 설계에서 공통적으로 이 크기 사용.\r\n2. 키 길이(Key size) : 키 길이가 길다는 것은 더 강한 보안, but 암 * 복호화 속도 저하. 보편적 키 길이 128 비트.\r\n3. 라운드 수 : 단일 과정으로는 보안 부족 => 라운드 수 증가시켜 보안 강화, 전형적 라운드 수 16.\r\n4. 서브키 생성 알고리즘 : 복잡할수록 암호해독 어려움.\r\n5. 라운드 함수 : 복잡할수록 암호해독 어려움. \r\n\r\n\r\n__(다) SPN 구조__  \r\n\r\n\r\n1. 블록 암호 라운드 함수 적용 방법에 따라 크게 두 가지 형태  \r\n   Substitution-permutation(SP) network, Feistel\r\n2. SP Network : 여러 개의 함수 중첩 시 개별 함수로 이루어진 암호보다 안전하다는 이론에 근거  \r\n                => 고전 암호 일종인 Substitution Cipher와 Permutation Cipher를 중첩하는 형태\r\n3. 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box로 입력하여 대치(Substitution)  \r\n   S-box의 출력을 P-box로 전치(permutation)하는 과정을 반복하는 방식  \r\n\r\n####5) 블록 암호에 대한 공격\r\n\r\n__(가) 차분 분석(차분 해독법, Differential Cryptanalysis)__  \r\n1. Biham Shamir가 개발, __평문의 일부를 변경하면 암호문이 어떻게 변화하는지__를 조사하는 암호 해독법  \r\n2. 블록 암호는 입력 평문이 한 비트라도 달라지면 암호문은 전혀 다른 비트 패턴으로 변화 => 변화 형태 조사하여 해독  \r\n\r\n\r\n__(나) 선형 분석(선형 해독법, Linear Cryptanalysis)__  \r\n\r\n1. Matsui가 개발, __평문과 암호문 비트를 몇 개 정도 XOR해서 0이 되는 확률을 조사__\r\n2. 암호문이 충분히 랜덤하면 평문과 암호문의 비트를 몇 개 XOR한 결과가 0이 되는 확률은 1/2  \r\n   => 따라서 1/2 비율을 크게 벗어난 비트의 개수를 조사하여 키에 관한 정보 얻음  \r\n3. 차분, 선형 해독법은 해독자가 임의로 만든 평문을 암호화할 수 있다는 가정 => __선택 평문 공격(Chosen Plaintext Attack)__  \r\n   선형 해독법의 경우 근사 선형 관계성을 찾았다면 이를 통해 기지평문 공격에서 선택 평문 공격을 수행 가능  \r\n\r\n__(다) 전수공격법(Exhaustive key search)__  \r\n\r\n1.  Diffe와 Hellman이 제안한 방법, 모든 경우 전수 조사\r\n\r\n\r\n__(라) 통계적 분석(Statistical analysis)__  \r\n1. 암호문에 대해 평문의 각 단어별 빈도 등 통계적 자료 이용 해독  \r\n\r\n__(마) 수학적 분석(Mathematical analysis)__  \r\n\r\n1. 통계적 방법을 포함, 수학적 이론 이용 해독  \r\n\r\n\r\n###(2) 현대 스트림 암호 \r\n\r\n####1) 개요\r\n\r\n__(가) 기본 개념__  \r\n\r\n1. 현대 스트림 암호에서 암호화와 복호화는 한번에 r 비트 생성.  \r\n   평문 비트 스트림 = $P=p_{n} \\cdots p_{2}p_{1}$, 암호문 비트 스트림 = $C=c_{n} \\cdots c_{2}c_{1}$,  \r\n   키 비트 스트림 = $K=k_{n} \\cdots k_{2}k_{1}$이라 할 때  (단, $p_{i},c_{i},k_{i}$는 r 비트 워드)  \r\n   암호화 : $c_{i} = E(k_{i},p_{i})$  \r\n   복호화 : $p_{i} = D(k_{i},c_{i})$  \r\n\r\n2. 키 스트림 $K = k_{n} \\cdots k_{2}k_{1}$ 생성 방법이 현대 스트림 암호 주 관심사  \r\n   현대 스트림 암호 : 동기식, 비동기식 두 가지 종류로 분류\r\n\r\n__(나) 스트림 암호 설계 시 고려사항__  \r\n1. 암호화의 연속은 긴 주기를 가져야함  \r\n   의사 난수 생성기가 언젠가 반복되는 비트 스트림 생성하므로 반복 주기가 더 길어야 해독이 더 어려워짐\r\n2. 키 스트림은 진 난수 스트림과 최대한 비슷해야 함  \r\n   1, 0의 개수가 거의 동일해야 함, 키 스트림이 바이트 스트림으로 처리 시 256개의 가능한 바이트 값이 거의 같은 빈도로 출현해야 함  \r\n3. 전사적 공격에 대응하기 위해서는 키가 충분히 길어야 함  \r\n   블록 암호에도 적용할 수 있기 때문에 현재 기술 수준에서 최소 128 비트인 것이 바람직  \r\n\r\n\r\n####2) 동기식 스트림 암호 \r\n\r\n__(가) 개요__   \r\n\r\n1. 동기식 스트림 암호에서 키 스트림은 평문 혹은 암호문 스트림과 독립적  \r\n2. 키 스트림은 평문 혹은 암호문 비트와 키 사이에 어떠한 관계도 없이 생성, 사용  \r\n\r\n__(나) One-Time Pad__  \r\n\r\n1. 동기식 스트림 암호 중 가장 간단, 안전  \r\n   암호화를 수행할 때마다 랜덤하게 선택된 키 스트림을 사용\r\n2. 해독 불가능하다는 것이 수학적으로 증명됨  \r\n   일회용 패드는 무조건 안전(unconditionally secure), 이론적으로 해독 불가능(theoretically unbreakable)로 알려짐  \r\n3. 암호화 알고리즘, 복호화 알고리즘 각각 배타적 논리합 연산(XOR)을 사용. XOR의 성질로 암호화와 복호화 알고리즘은 서로 역관계  \r\n   XOR을 한 번에 한 비트씩 적용함\r\n\r\n#####\r\n\r\n* OTP 안전성을 위한 조건 : 패드는 한 번만 사용, 패드는 메시지 길이만큼 길어야함, 패드는 목적지로 안전하게 배포, 보호되어야 함, 패드는 순수하게 임의값으로 만들어져야 함\r\n* 현대 스트림 암호에서 평문 스트림의 r 비트 워드는 키 스트림의 r 비트 워드를 사용하여 대응되는 암호문의 r 비트 워드를 생성하여 암호화함\r\n* 동기식 스트림 암호에서 키는 평문 혹은 암호문과 독립적  \r\n\r\n__(다) 귀환 시프트 레지스터(FSR, Feedback Shift Register)__  \r\n1. one-time pad의 절충안은 FSR이다. SW, HW 환경에서 모두 구현 가능, HW 구현이 더욱 용이함\r\n2. 시프트 레지스터와 귀환(feedback) 함수로 구성됨  \r\n\r\n\r\n__(라) 선형 귀환 시프트 레지스터(LFSR, linear feedback shift register)__  \r\n\r\n1. HW로 쉽게 구현되며 많은 스트림 암호가 이용\r\n\r\n#####\r\n* LSFR의 최대 주기는 $2^m-1$이다. \r\n* 비동기식 스트림 암호에서 키는 평문 혹은 암호문에 종속적으로 결정됨\r\n* 현대 블록 암호는 모두 함성 암호이고 Feistel, non-Feistel 두 가지로 분류됨  \r\n  Feistel 암호는 역함수가 존재하는 요소와 존재하지 않는 요소 모두 이용 가능  \r\n  non-Feistel 암호는 오직 역함수가 존재하는 요소만 이용 가능  \r\n\r\n__(마) 비선형 귀환 시프트 레지스터(NLFSR, Nonlinear Feedback Shift Register)__  \r\n1. LFSR이 선형성 공격에 취약, NLFSR로 더욱 안전한 스트림 암호 설계 가능  \r\n\r\n#####\r\n\r\n* 강력한 스트림 암호 특징  \r\n  키스트림 값 내부에서 장기간 반복되는 패턴 없음  \r\n  통계적 예측 불가한 키스트림  \r\n  키스트림은 키와 선형적 관계에 있지 않음 => 키스트림값을 알아내도 키값을 아는 것이 아님  \r\n  통계적으로 치우치지 않은 키스트림(0과 1의 개수)  \r\n\r\n\r\n####3) 비동기식 스트림 암호 \r\n\r\n1. 각 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정\r\n2. 블록 암호에서 다른 운영 모드를 생성하기 위해 사용되는 한 방법인 CFB(cipher feedback mode)는 실제로 스트림 암호를 생성  \r\n\r\n\r\n##2. DES(Data Encryption Standard)\r\n\r\n###(1) 개요\r\n\r\n####1) 역사\r\n\r\n1. NIST 표준\r\n2. NIST는 이제 3중 DES 사용 권고\r\n3. AES가 DES 대체하기 위해 새 표준으로 제정됨 \r\n\r\n\r\n####2) 개관\r\n1. 평문 길이 64 bit, 키의 길이 56 bit, 평문이 64 bit보다 길면 블록으로 나눔  \r\n   Feistel 네트워크의 변형 형태, 16 라운드  \r\n   56 bit 원래 키로부터 16개의 서브키를 생성하고 이 것을 각 라운드에서 사용  \r\n2. DES의 복호화 과정은 암호화 과정과 동일   \r\n   암호문을 알고리즘 입력으로, 서브키 $K_{i}$는 순서를 뒤집어서 적용.  \r\n   즉, 첫번째 라운드에 $K_{16}$ 사용, 다음 라운드 $K_{15}$, 마지막 16 라운드에 $K_{1}$ 사용으로 반복\r\n\r\n#####\r\n* DES는 64 bit 평문을 64 bit 암호문으로 암호화하는 대칭키 암호화\r\n* DES의 키는 7 비트마다 오류검출 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트\r\n\r\n\r\n###(2) DES의 구조\r\n\r\n####1) 개요\r\n\r\n1. 암호화 과정은 두 개의 P-box와 16개의 Feistel 라운드 함수로 구성됨  \r\n   두 개의 P-box 중 하나는 초기 전치(initial permutation), 다른 하나는 최종 전치(final permutation)\r\n2. 각 라운드는 라운드 키 생성기에 의해 암호키로부터 생성된 48 bit 라운드 키 사용 \r\n\r\n####2) 라운드 함수 \r\n\r\n__(가) 개요__  \r\n1. DES는 16번 라운드 함수 사용. 각 라운드 함수는 Feistel 암호\r\n\r\n2. 라운드 함수는 이전 라운드 함수(또는 초기 P-box)의 출력 값 $L_{i-1}$과 $R_{i-1}$을 입력 받아, 다음 라운드(또는 최종 P-box)에 입력으로 전송될 $L_{i}$와 $R_{i}$을 생성  \r\n\r\n3. 각 라운드에는 혼합기(mixer)와 교환기(swapper) 존재, 이 것들은 역연산이 가능. 교환기는 명백히 역연산 가능 \r\n\r\n\r\n__(나) DES 함수__  \r\n1. DES의 핵심은 DES 함수. 라운드 함수에 사용된 $f(R_{i-1},K_{i})$를 가리킴.  \r\n   DES 함수는 32비트 출력값을 산출하기 위해 가장 오른쪽 32비트 $(R_{i-1})$에 48키를 적용  \r\n2. DES 함수는 확장 P-box, 키 XOR, 8개의 S-box 그리고 단순 P-box의 4개 부분으로 구성됨  \r\n\r\n#####\r\n* DES  \r\n  키 크기 : 56비트 + parity 8비트 = 64 비트  \r\n  안전성은 주로 비선형 함수로 구성된 8개의 S-box에 의존  \r\n  16라운드의 페이스텔 구조  \r\n  복호화는 암호화의 역순 \r\n\r\n####3) 암호화 알고리즘과 복호화 알고리즘\r\n\r\n__(가) 개요__  \r\n1. mixer, swapper 사용해 16라운드 암호화, 복호화 알고리즘 만듦.\r\n2. 중요한 점은 암호화 키 순서의 역순으로 복호화 시 키 순서 적용  \r\n\r\n\r\n###(3) DES 분석\r\n\r\n####1) 설계 기준\r\n\r\n__(가) S-box__  \r\n1. S-box는 각 라운드에서부터 그 다음 라운드까지 혼돈 만족하도록 설계됨\r\n2. S-box는 비선형 함수\r\n3. 입력값의 한 비트를 바꾼다면 출력값에서는 두 비트 이상이 바뀜 \r\n\r\n__(나) P-box__   \r\n1. 32비트에서 32비트로 가는 하나의 단순 P-box와 32비트에서 48비트로 가는 하나의 확장 P-box 존재.  \r\n   두 개의 P-box는 비트들을 동시에 확산시킴.\r\n\r\n####2) DES의 취약점\r\n\r\n1. 평문 또는 키의 작은 변화가 암호문에 큰 변화를 만드는 쇄도효과(Avalanche Effect)가 매우 큼, 암호문의 각 비트가 평문의 많은 비트들에 의존하는 완비성(completeness)이 높은 것으로 증명되 암호문으로부터 평문 추론 매우 어려움\r\n2. 그러나 56비트 키 사용하므로 최대 키 공간의 크기 $2^{56}( \\cong 7.2 \\times 10^{16})$이 되고,  \r\n   개발 당시는 전사 공격(Brute Force Attack) 불가했지만, 현대에는 더 이상 안전하지 않음 \r\n3. 실제로 전사 공격에 해독되고, 지금은 적용하면 위험  \r\n\r\n\r\n###(4) 다중 DES\r\n\r\n####1) 3중 DES\r\n\r\n__(가) 개요__  \r\n1. 두 가지 버전 : 두 개의 키, 세 개의 키\r\n\r\n2. 3DES는 HW에서 효율적, SW 비효율적  \r\n   전자 여권 바이오 정보 보호, 금융 분야에서 활용\r\n\r\n__(나) 3중 DES 현황__  \r\n1. 3DES 은행 등에서 활용하지만 빠르지 않음  \r\n   과거 DES 암호화 자료와 호환성 중시하는 경우 제외하고 새 용도로 잘 안쓰임  \r\n2. 3DES는 우리나라 표준은 아님, 우리나라 표준은 블록 암호 SEED, 국내 기관 공동 개발한 ARIA는 현재 사용됨\r\n\r\n#####\r\n* DES가 3DES보다 2.5배 정도 빠름, AES-128은 DES보다 3배 정도 빠름, RC4는 AES-128보다 2배 정도 빠름\r\n\r\n\r\n__(다) 두 개의 키를 갖는 3중 DES__  \r\n1. 두 개의 키 $K_{1}$과 $K_{2}$만 사용. 첫 번째와 세번째 단계에서 $K_{1}$사용, 두번째 단계는 $K_{2}$ 사용.\r\n\r\n2. 하나의 DES로 3중 DES를 만들기 위해 두 번째 DES는 복호화 알고리즘 사용, 1, 3 번째 경우 암호화 DES 알고리즘 사용\r\n\r\n__(라) 세 개의 키를 갖는 3중 DES__  \r\n1. 두 개 키를 쓰는 DES는 기지평문공격 가능성이 있어 세 개의 키를 사용하기도 함\r\n2. PGP와 같은 많은 응용프로그램에서 사용  \r\n3. 3DES의 복호화는 암호화의 역이 됨 키3, 키2, 키1 순으로 복호화 -> 암호화 -> 복호화\r\n\r\n__(마) DES와의 호환성__   \r\n1. 트리플 DES에서 모든 키를 동일하게 하면 3DES는 보통의 DES와 같아진다. 1, 2 번째 DES가 암호화 후 복호화 하여 다시 평문이 나오는 꼴  \r\n2. 과거 DES로 암호화된 암호문을 3DES 호환\r\n\r\n|구분(단위 bits)|DES|Triple DES|AES|\r\n|:--------:|:--------:|:--------:|:--------:|\r\n|평문 블록 크기|64|64|128|\r\n|암호문 블록 크기|64|64|128|\r\n|키 크기|56|112 or 168|128, 192, or 256|\r\n\r\n\r\n##3. AES\r\n\r\n###(1) 개요\r\n\r\n####1) 역사 \r\n\r\n1. NIST에서 Rijndael을 AES로 선정\r\n\r\n####2) 선정 기준(Criteria)\r\n\r\n1. 안정성(security), 비용(cost), 효율성(implementation)\r\n\r\n\r\n####3) 라운드\r\n\r\n1. AES는 128비트 평문을 128비트 암호문으로 출력하는 알고리즘으로 non-Feistel  \r\n   10,12,14라운드를 사용, 각 라운드에 대응하는 키 크기 : 128, 192, 256 비트\r\n\r\n\r\n2. 키 크기에 따라 AES의 세가지 버전 존재 AES-(키 크기)  \r\n   그러나 어떤 버전이든 키 확장 알고리즘으로부터 생성되는 라운드 키 크기는 평문과 암호문 크기와 동일한 128 비트\r\n\r\n#####\r\n\r\n* SubBytes 연산은 16개의 독립된 바이트 단위의 변환 수행\r\n* SubBytes 변환과 InvSubBytes 변환은 서로 역변환 관계\r\n* Mixcolumns와 InvMixColumns는 역변환 관계\r\n\r\n###(2) 암호\r\n\r\n####1) 개요\r\n\r\n1. SPN(Substitution-Permutation Network) 구조\r\n2. AES 암호화 각 라운드는 비 선형성을 갖는 S-box를 적용하여 바이트 단위로 치환 수행하는 SubBytes() 연산,  \r\n   행 단위로 순환 시프트(Cyclic shift)를 수행하는 ShiftRows() 연산,  \r\n   높은 확산(diffusion)을 제공하기 위해 열 단위로 혼합(mixing)하는 Mixcolumns 연산,   \r\n   라운드 키와 state를 EX-OR하는 ADDRoundKey() 연산\r\n\r\n3. 암호화 마지막 라운드 MixColumns() 연산 수행 안함\r\n4. 알려진 블록 암호에 대한 공격에 안전하도록 설계됨, HW, SW 구현 시 속도나 코드 압축성 면에서 효율적이므로 스마트카드 등 응용에 적합  \r\n\r\n#####\r\n\r\n* SPN 구조는 라운드 함수가 역변환이 되어야 한다는 제약이 있지만 더 많은 병렬성(parallelism)을 제공하기 때문에 암 * 복호화 알고리즘의 고속화를 요구하며, 컴퓨터 프로세서가 더 많은 병렬성을 지원하게 된 현 추세에 부응하는 방식\r\n* SPN은 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box에 입력하여 치환시키고 S-box의 출력을 P-box로 전치하는 과정을 반복\r\n* AES 4가지 암호화 과정(바이트 치환 변환, 행 이동, 열 혼합, 라운드 키 더하기) : 치환, 시프트, 그리고 DES에는 없는 비트 혼합 \r\n - Feistel : DES, LOKI, CAST, Blowfish, MISTY, RC5, RC6, CAST256, E2, Twofish, Mars\r\n - SPN : SAFER, SHARK, Square, CRYPTION, Rijndael, SAFER+, Serpent, PRESENT\r\n\r\n\r\n##4. 기타 대칭키 암호 알고리즘\r\n\r\n####1) IDEA(International Data Encryption Algorithm)\r\n1. 스위스 연방 기술기관, 128 비트 키, 64 비트 블록 암호, Feistel과 SPN의 중간 형태인 Lai-Massey Scheme\r\n2. 8라운드에 걸쳐 데이터를 변환하고 마지막에 한 번 더 키를 적용시켜 64 비트 암호문을 생성 때문에 보통 8.5라운드라고 말함  \r\n   IDEA는 DES와 달리 S-box를 사용 안하고, 대수적 구조가 서로 다른 연상ㄴ을 교대 사용하여 암호 강도 증가\r\n3. 현재까지 특별한 분석 방법 알려지지 않아 DES에 비해 안전한 것으로 판단, PGP(Pretty Good Privacy)의 데이터 암호 알고리즘으로 채택 사용  \r\n   DES보다 2배 정도 빠르고, 무차별 공격에 더욱 효율적\r\n\r\n####2) RC5\r\n1.  \r\n\r\n\r\n\r\n","fields":{"slug":"/정보보안기사 2장 - (2) 대칭키 암호/"},"frontmatter":{"title":"정보보안기사 2장 - (2) 대칭키 암호","published":true}}},{"node":{"rawMarkdownBody":"\r\n##1. 암호학의 기본개념\r\n\r\n###1) 암호학(Cryptology)의 정의\r\n\r\n1. 암호 : 약속된 당사자나 집단에서만 내포된 내용을 알 수 있게하는 일종의 문서\r\n2. 암호학 : 암호 기술과 암호해독에 관하여 연구하는 학문 \r\n\r\n\r\n###2) 암호학에서 사용하는 이름\r\n\r\n1. 앨리스(Alice), 밥(Bob) : 메시지 송수신 주체\r\n2. 이브(Eve) : 도청자(eavesdropper), 소극적 공격자\r\n3. 맬로리(Mallory) : 악의적인(malicious) 공격자\r\n4. 트렌트(Trent) : 신뢰할 수 있는 중재자(trusted arbitrator)\r\n5. 빅터(Victor) : verifier, 검증인\r\n\r\n\r\n###3) 송신자, 수신자, 도청자\r\n\r\n1. 송신자(sender), 수신자(receiver), 메시지(message)\r\n2. 사람 이름이 사람이 아닌 기계나 프로그램일 수도 있다.\r\n\r\n###4) 암호화와 복호화\r\n\r\n1. 평문(plaintext) : 암호화하기 전 메시지  \r\n   암호문(ciphertext) : 암호화한 메시지 \r\n2. 암호(cryptography) 기술로 기밀성(confidentiality) 유지\r\n\r\n\r\n###5) 암호화와 복호화의 기호적 표현\r\n\r\n1. 주로, \r\n \r\n   평문 : P  \r\n   암호문 : C  \r\n   암호 알고리즘 : E  \r\n   복호화 알고리즘 : D  \r\n   키 : K\r\n\r\n   * 키 스페이스 : 사용하는 키 값의 크기(size)  \r\n\r\n\r\n - $C = E_{k}(P)$ : 평문 P를 키 K로 암호화(E)하여 암호문 C\r\n - $P = D_{k}(C)$ : 암호문 C를 키 K로 복호화(D)하여 평문 P\r\n\r\n2. 또는 $C = E(K,P)$, $P = D(K,C)$로 표현\r\n\r\n* 암호시스템(Cryptosystem) : 암호화와 복호화를 수행하는 시스템\r\n\r\n###6) 암호 알고리즘과 키의 분리\r\n\r\n암호 알고리즘은 반복하고 키만 바꾸어 사용\r\n\r\n\r\n###7) 암호와 보안 상식\r\n\r\n__(가) 비밀 암호 알고리즘 사용하지 말 것__  \r\n암호 알고리즘 구조가 폭로되면 파훼됨  \r\n숨기는 것에 의한 보안(security by obscurity)라 부르고 위험하고 어리석게 간주  \r\n\r\n__(나) 약한 암호는 암호화하지 않는 것보다 위험__  \r\n잘못된 안심을 하고 기밀성 높은 정보 소홀하게 취급할 가능성  \r\n\r\n__(다) 어떤 암호라도 언젠가는 해독됨__  \r\nBrute-force attack  \r\n해독에 들어가는 시간과 암호화할 평문의 중요성의 밸런스(trade-off) 고려  \r\n\r\n__(라) 암호는 보안의 일부분__  \r\n사회공격(social engineering attack)이 최근 자주 행해짐  \r\ne.g.) 피싱(Phshing) : 위장 홈페이지 등으로 접근하도록 하여 개인정보 빼 가는 해킹 방법,  \r\n트로이목마(Trojan Horse) : 정상적인 프로그램으로 가장해 다른 프로그램 안에 숨어 있다가 그 프로그램이 실행될 때 자신을 활성화하는 악성 프로그램,  \r\n키로거(Keylogger) : 키보드 움직임을 탐지해 개인정보를 몰래 빼 가는 해킹 공격  \r\n\r\n\r\n##2. 암호기법의 분류 \r\n\r\n###1) 치환 암호와 전치 암호\r\n\r\n__(가) 치환 암호(대치 암호, Substitution Cipher)__  \r\n비트, 문자 또는 블록을 다른 비트, 문자 또는 블록으로 대체  \r\n평문에서 사용하는 문자의 집합과 암호문에서 사용하는 문자의 집합이 다를 수 있음  \r\n문자를 교환하는 규칙, 일대일 대응이 아닐 수 있음  \r\n\r\n__(나) 전치 암호(Transposition Cipher)__  \r\n비트, 문자 또는 블록이 원래 의미를 감추도록 재배열  \r\n평문과 암호문에서 사용하는 문자 집합이 동일  \r\n문자 집합 내부에서 자리를 바꾸는 규칙, 평문과 암호문의 문자가 일대일 대응 규칙  \r\n\r\n * 키 공간(Key space)의 크기와 키 비트수  \r\n암호화에서 키 공간의 크기는 전사 공격 방지에 매우 중요.  \r\n클 수록 안전.  \r\n하지만 키가 클 수록 키 비트수도 커짐.  \r\n\r\n\r\n###2) 블록 암호와 스트림 암호\r\n\r\n__(가) 블록 암호(Block cipher)__  \r\n블록 암호는 특정 비트 수의 집합인 블록 단위로 암호화하는 알고리즘을 총칭  \r\n블록 비트 수  = 블록 길이(block length)  \r\n평문을 블록으로 나누어 암호화, 블록 크기는 8 또는 16의 배수  \r\n스트림 암호화와 다르게 Round를 사용하고, 반복적으로 암호화 과정을 수행해 암호화  \r\n\r\n__(나) 스트림 암호(Stream cipher)__  \r\n한번에 1비트 혹은 1바이트의 스트림(데이터 흐름)을 순차적으로 처리해 암호화하는 알고리즘 총칭  \r\n평문과 키 스트림을 XOR해서 암호화  \r\n블록 암호화와 다르게 스트림 암호화는 진행 상태를 알기 위해 내부 상태를 가짐  \r\n군사 및 외교용으로 널리 사용, 일부 상용으로  \r\n이동 통신 환경에서 구현 용이, 안전성을 수학적으로 엄밀 분석 가능하여 무선 데이터 보호에 적합  \r\n\r\n| 구분 | 스트림 암호 | 블록 암호 |\r\n| :--------| :--------| :--------|\r\n| 장점 | 암호화 속도 빠름, 에러 전파현상 없음 | 높은 확산, 기밀성 해시함수 등 다양 |\r\n| 단점 | 낮은 확산 | 느린 암호화, 에러 전달 |\r\n| 사례 | LFSR, MUX generator | DES, IDEA, SEED, RC5, AES | \r\n| 암호화 단위 | 비트 | 블록 |\r\n| 주요 대상 | 음성, 오디오/비디오 스트리밍 | 일반 데이터 전송, 스토리지 저장 |\r\n\r\n\r\n\r\n###3) 위치에 따른 암호화의 구분\r\n\r\n__(가) 링크 암호화(Link Encryption)__  \r\n모든 정보는 암호화됨, 홉(라우터)에서 패킷 목적지를 알기 위해 해독됨  \r\n라우터는 패킷 헤더 부분을 해독하여 라우팅과 주소 정보를 읽고 다시 암호화한 후 다음 홉으로 전송  \r\n링크 암호화는 데이터 링크 또는 물리적 계층에서 일어남, 하드웨어 암호화 장치들은 물리적 계층과의 인터페이스를 가지고 통과하는 모든 데이터 암호화  \r\n\r\n\r\n__(나) 종단간 암호화(End-to-End Encryption)__  \r\n종단간 암호화에서는 헤더와 트레일러가 암호화되지 않기 때문에 패킷을 각 홉에서 해독하고 암호화할 필요가 없음  \r\n근원지와 목적지 사이의 장비들은 단지 필요 라우팅 정보만 읽고 진행 방향으로 통과  \r\n보통 근원지 컴퓨터 사용자가 종단간 암호화 시작, 이 점이 사용자가 어떤 메시지를 암호화할지 여부 결정하는 유연성 제공  \r\n종단간 암호화는 애플리케이션 계층에서 암호화 이루어짐  \r\n\r\n| 구분 | 링크 암호화 | 종단간 암호화 |\r\n| :--------| :--------| :--------|\r\n| 특징 | - ISP나 통신업자가 암호화 <br/> - 헤더를 포함한 모든 데이터를 암호화 <br/> - 유저가 알고리즘 통제 불가 | - 사용자가 암호화 <br/> - 헤더(라우팅 정보)는 암호화 안함 <br/> - 알고리즘에 대한 통제를 사용자가 함 |\r\n| 장점 | - User-transparent하게 암호화되므로 운영 간단(유저에게 보이지 않는다는 의미) <br/> - 트래픽분석을 어렵게 함 <br/> - 온라인으로 암호화 | - 사용자 인증 등 높은 수준의 보안 서비를 제공 가능 <br/> - 중간노드에서도 데이터가 암호문으로 존재 |\r\n| 단점 | - 중간 노드에서 데이터가 평문으로 노출 <br/> - 다양한 보안서비스를 제공하는데 한계 <br/> - 모든 노드가 암호화 장비를 갖추어야하므로 네트워크가 커지면 비용 과다 | - 트래픽분석이 취약 <br/> - 오프라인으로 암호화 | \r\n\r\n\r\n###4) 하드웨어와 소프트웨어 암호시스템\r\n\r\n__(가) 하드웨어 암호시스템__  \r\n하드웨어로 구현하기 위해 컴퓨터와 통신기기 내부버스와 외부 인터페이스에 전용 암호처리용 하드웨어 설치  \r\n전용 하드웨어로 암호화함으로써 컴퓨터 CPU에 부담을 주지 않고 빠른 속도로 암호화, 보안성 확보에 바람직  \r\n\r\n__(나) 소프트웨어 암호시스템__  \r\n암호처리용 소프트웨어를 사용한 데이터 암호화  \r\n저렴한 비용으로 실현 가능, 허용범위 내에서 적당한 안정성과 처리속도 얻을 시 상당히 효과적  \r\n개인 PC 성능 증진으로 처리속도 문제되지 않아 최근에는 소프트웨어 암호화가 주류  \r\n\r\n##3. 주요 암호기술에 대한 개괄\r\n\r\n###1) 대칭키 암호와 비대칭키 암호\r\n대칭키 암호(symmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 동일  \r\n비대칭키 암호(asymmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 서로 다름  \r\n비대칭키 암호 알고리즘 사용 시 송신자도 한 쌍의 키를 가지고 있어야 하고 수신자도 자신만의 한 쌍의 키 가져야함  \r\n\r\n###2) 하이브리드 암호 시스템  \r\n대칭키 암호와 공개키 암호를 조합한 암호 방식을 하이브리드 암호 시스템(hybrid cryptosystem)이라고 함  \r\n두 방식의 장점을 조합  \r\n\r\n###3) 일방향 해시함수\r\n해시값은 일방향 해시함수(one-way hash function)를 사용하여 계산한 값  \r\n무결성 제공  \r\n\r\n###4) 메시지 인증코드 \r\n메시지가 예상 통신 상대로부터 온 것을 확인하기 위해 메시지 인증코드(message authentication code)라는 기술 사용  \r\n메시지 인증코드 사용 시 메시지가 전송 도중에 변경되지 않았다는 것과 생각했던 통신 상대로부터 왔다는 것 확인 가능  \r\n메시지 인증코드는 무결성과 인증 제공  \r\n\r\n###5) 전자서명 \r\n거짓 행세(spoofing), 변경, 부인의 위험을 방지하는 기술  \r\n무결성 확인, 인증과 부인방지 제공  \r\n\r\n###6) 의사난수 생성기\r\n의사난수 생성기(PRNG, pseudo random number generator)는 난수열을 생성하는 알고리즘  \r\n난수는 키 생성(key generator)이라는 매우 중요한 역할  \r\n\r\n\r\n##4. 암호 분석(암호 해독)\r\n\r\n###1) 개요\r\n암호 방식의 정규 참여자 외 제3자가 암호문으로부터 평문을 찾으려 하는 것을 암호 해독(cryptanalysis) 또는 공격이라 함   \r\n공격자 = 암호 해독자, 제3자, 침해자  \r\n평문의 통계적 성질, 암호에 관한 지식, 장비 등 통해 암호문에서 평문 또는 키 찾아냄  \r\n\r\n * 케르히호프의 원리(Kerchhoff's principle) : 암호시스템의 안전성은 암호 알고리즘의 비밀을 지키는데 의존되지 말고, 키의 비밀을 지키는데 의존되어야 한다는 원리\r\n\r\n\r\n###2) 암호 분석의 분류\r\n\r\n__(가) 암호문 단독 공격(COA, Ciphertext Only Attack)__  \r\n암호문 단독 공격은 공격자가 암호문을 얻어서 대응되는 평문과 키를 찾는 것  \r\n공격에 암호문만 필요, 공격자의 메시지 복호화를 막기 위해 이런 종류의 공격에 안전해야 함, 다양한 방법이 이 공격에 사용(평문의 통계적 성질, 문장의 특성 등)  \r\n\r\n__(나) 기지 평문 공격 (KPA, Known Plaintext Attack)__  \r\n기지(알려진) 평문 공격에서 공격자는 암호문 외에 추가로 여러 개의 평문/암호문 쌍을 얻음(미리 갖고 있음)  \r\nAlice가 Bob에게 비밀 메시지를 보냈지만 나중에 그 메시지를 공개한다면, 공격자(Eve)가 공개된 평문/암호문 쌍을 사용해 다음 A to B 보내려는 비밀 메시지를 알아내는데 사용  \r\n\r\n__(다) 선택 평문 공격(CPA, Chosen Plaintext Attack)__  \r\n선택 평문 공격은 알려진 평문 공격과 유사하지만 공격자에게 주어지는 평문/암호문 쌍을 공격자가 선택  \r\ne.g.) 공격자가 A의 컴퓨터에 접속하여 어떤 평문을 선택하고 이에 대응하는 암호문을 얻음  \r\n공격자가 평문을 선택하면 대응하는 암호문을 얻을 수 있는 경우    \r\n\r\n__(라) 선택 암호문 공격(CCA, Chosen Ciphertext Attack)__  \r\n선택 암호문 공격은 공격자가 어떤 암호문을 선택하고 그에 대응되는 평문을 얻음(그 외에는 선택 평문 공격과 유사)  \r\n공격자가 수신자의 컴퓨터에 접속 가능할 경우 적용 가능(공격자가 복호기에 접근 가능한 경우 : 암호문 선택시 대응 평문 얻을 수 있을 경우)  \r\n선택된 암호문(임의의 암호문이거나 계획에 의한 암호문 모두)을 복호화할 수 잇는 능력을 갖추고 있는 기계를 일반적으로 [Decryption Oracle, 복호 오라클]이라 부름  \r\n개인키로 암호화된 암호문을 알려진 공개키로 복호화할 수 있는 공개키 암호화 시스템에 대한 해독 공격에 주로 사용됨  \r\n선택 암호문 공격에 견딜 수 있는 알고리즘은 강한 알고리즘이라 말할 수 있음  \r\n\r\n\r\n * Rubber-Hose Cryptanalysis 고무호스 암호분석 : 암호분석가가 키를 얻을 때까지 키를 가진 사람을 공갈, 협박, 고문하여 키를 획득...\r\n\r\n * 임시파일 : 대부분 암호화 시스템은 계산과정에서 임시파일 사용, 임시파일 삭제 혹은 덮어 쓰기 안될 시 이 정보에 의해 암호 해독 가능  \r\n\r\n\r\n##5. 암호 알고리즘의 안전성 평가\r\n\r\n###1) 안전성 개념 \r\n\r\n주어진 암호 시스템의 안전성을 말할 때는 두 가지 관점  \r\n1. 암호시스템 공격을 위해 필요한 계산량이 매우 커 현실적으로 공격 불가한 경우 : __계산적 안전__  \r\n2. 무한한 계산능력에도 공격 불가한 경우 __무조건적으로 안전__  \r\n다음 기준을 만족하는 알고리즘 필요  \r\n * 암호 해독 비용이 암호화된 정보의 가치를 초과\r\n * 암호 해독 시간이 정보의 유효 기간을 초과\r\n\r\n - 워크팩터(Work Factor) : 공격자가 암호화 방법을 깨는데 걸리는 노력(리소스)\r\n\r\n\r\n###2) 암호제품 평가체계 \r\n\r\n정보보호제품의 신뢰기관의 안정성평가 결과 : 가장 대표적인 것이 __CC(Common Criteria)__ 기반의 정보보호제품 평가  \r\nCC기반의 평가 기준은 암호 알고리즘에 대한 평가기준 명시 안됨, 각국이 독자적으로 규정, 평가  \r\n__암호모듈__에 대한 안정성평가로 가장 널리 참조 되는 미국 NIST가 수행하는 __CMVP(Cryptographic Module Validation Program)__, 세계적으로 인정 받음  \r\n\r\n###3) 암호기술 평가\r\n\r\n__(가) 평가 종류__  \r\n1. 암호 알고리즘 평가\r\n  정보보호제품에 탑대된 암호 알고리즘에 대한 안정성 평가\r\n  알고리즘 자체만을 평가, 따라서 제품이나 시스템과 독립적, 일반적으로 알고리즘 자체의 이론적 안정성만을 평가  \r\n\r\n2. 암호모듈 평가 e.g.) __CMVP__    \r\n  암호 알고리즘을 이용하여 제공되는 암호서비스(기밀성 기능 모듈, 무결성 기능 모듈)에 대한 안정성 평가  \r\n  알고리즘 자체의 이론적 안정성과는 별개, 암호모듈의 암호서비스 기능의 안정성 평가  \r\n\r\n3. 정보보호제품 평가  \r\n  암호모듈을 탑재한 정보보호 제품(예 : 침입차단시스템, 침입탐지시스템)에 대한 안정성 평가  \r\n\r\n4. 응용시스템 평가  \r\n  각 제품을 상호 연동하여 구성되는 시스템(예 : 국가기관망의 네트워크에 대한 보안성 평가, 항공관제센터의 안전성 평가)에 대한 안정성 평가  \r\n\r\n\r\n__(나) 평가 과정__  \r\n1. 안전성 평가는 응용시스템을 평가하는게 가장 바람직하나 현실적으로 어려움  \r\n2. 그러므로 응용시스템의 가장 기본이 되는 암호 알고리즘에 대한 안전성 평가 우선되어야함  \r\n3. 알고리즘으로부터 모듈, 제품, 시스템 순으로 안전성 평가 수행 바람직  \r\n\r\n\r\n###4) 암호모듈의 안전성 평가(CMVP)\r\n\r\n__(가) 개요__  \r\nㄱ. 암호기술의 구현 적합성 평가  \r\nㄴ. 암호키 운용 및 관리  \r\nㄷ. 물리적 보안  \r\n\r\n\r\n##6. 지적 재산권 보호\r\n\r\n###(1) 디지털 저작권 관리\r\n\r\n####1) 스테가노그래피(Steganography)\r\n암호화와 다른 개념, 다른 무언가로 감추어 메시지 자체를 은폐  \r\ne.g.) 사진 속에 미세한 변화로 정보 입력  \r\n\r\n####2) 디지털 워터마킹(Digital Watermarking)\r\n워터마킹 : 위조지폐 감별을 위해 물에 젖은 상태에서 인쇄한 그림을 불빛에 비추면 그림이 보이도록 하는 기술에서 유래  \r\n원본 내용 왜곡하지 않는 범위에서 저작권 정보를 디지털 컨텐츠에 삽입하는 기술  \r\n- 강한(강성) 워터마킹 : 공격을 받아도 쉽게 파괴, 손상 없음\r\n- 약한(연성) 워터마킹 : 공격 받을 시 쉽게 파괴, 손상  \r\n\r\n\r\n####3) 핑거프린팅(Fingerprinting) \r\n1. 디지털 컨텐츠 구매 시 구매자의 정보를 삽입, 불법 배포 발견 시 최초 배포자 추적 가능케 하는 기술  \r\n2. 판매되는 컨텐츠마다 구매자의 정보 들어감, 불법 배포 컨텐츠 내에서 핑거프린팅 정보 추출하여 구매자 식별, 법적 조치 가능케 함  \r\n\r\n\r\n####4) 디지털 저작권 관리(DRM, Digital Rights Management)\r\n__(가) 개요__  \r\n1. DRM은 디지털 컨텐츠 소유자가 자신의 컨텐츠에 대한 접근을 자신 또는 자신의 위임자가 지정하는 다양한 방식으로 제어 가능케 하는 기술적 방법 또는 방법의 집합  \r\n2. 컨텐츠 접근을 제한 실행, 보기, 복제, 출력, 변경 등  \r\n\r\n__(나) DRM 구성 요소__  \r\n1. 메타데이터(Metadata)  \r\n\r\n2. 패키저(Packager) : 컨텐츠와 메타데이터를 함께 Secure Container 포맷으로 패키징하는 모듈  \r\n\r\n3. 시큐어 컨테이너(Secure Container) : DRM 보호 범위 내 유통되는 컨텐츠 배포 단위  \r\n\r\n4. 식별자(Identifier) : 컨텐츠 식별  \r\n\r\n5. DRM 제어기(DRM Controller) : 컨텐츠를 이용하는 사용자의 PC 또는 디바이스 플랫폼에서 컨텐츠가 라이센스에 명시된 범위 내에서 지속적으로 보호될 수 있도록 프로세스 제어  \r\n\r\n\r\n__(다) DRM 모델__  \r\n1. 컨텐츠 제공자(Content Provider), 컨텐츠 배포자(Distributer), 컨텐츠 소비자(Content Consumer), 클리어링하우스(ClearingHouse)  \r\n\r\n2. 컨텐츠 제공자  \r\n  컨텐츠의 디지털 권리를 가지고 권리 보호 원하는 DRM 사용자  \r\n  권리 표현 언어(REL, Rights Expression Language) : 컨텐츠 사용 규칙 표현 언어 e.g.) 대표적으로 ODRL(Open Digital Rights Language), MPEG(Moving Picture Expert Group)  \r\n\r\n3. 컨텐츠 배포자  \r\n  컨텐츠 유통 채널(e.g. 온라인 쇼핑몰)\r\n  정당 소비자에게 컨텐츠 안전하게 전달, 클리어링하우스로부터 대금 분배 받음  \r\n\r\n4. 컨텐츠 소비자  \r\n  클리어링하우스를 통해 컨텐츠에 대한 권리 요청, 대금 지불  \r\n\r\n5. 클리어링하우스  \r\n  디지털 허가를 소비자에게 발급, 제공자에게 로열티 수수료 지불, 배급자에게 배급 수수료 지불하는 재정적 거래 취급, 모든 소비자에게 허가된 사용을 기록하는 책임 있음  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/정보보안기사 2장 - (1) 암호학 개요/"},"frontmatter":{"title":"정보보안기사 2장 - (1) 암호학 개요","published":true}}},{"node":{"rawMarkdownBody":"\r\n#커널 소스 구하기\r\n\r\n[http://www.kernel.org](http://www.kernel.org)\r\n\r\n\r\n[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\r\n\r\n\r\n\r\n#커널 소스 설치\r\n\r\nbzip2 형식 압축 해제  \r\n`$ tar xvjf linux-x.y.z.tar.bz2`  \r\n\r\n\r\nGNU zip 형식 압축 해제  \r\n`$ tar xvzf linux-x.y.z.tar.gz`  \r\n\r\n\r\n* 커널 소스는 보통 /usr/src/linux에 설치된다. 여기 접근하려면 루트 권한 필요, 새 커널 설치 시에만 루트 권한 사용하여 접근하고 그때에도 이 디렉토리 내용은 건드리면 안된다.\r\n\r\n\r\n\r\n#패치\r\n\r\n점증적 패치를 적용하려면,   \r\n`$ patch -p1 < ../patch-x.y.z`  \r\n\r\n\r\n#커널 소스 트리\r\n\r\n| 디렉토리 | 설명 |\r\n| :-------- | :-------- |\r\n| arch | 특정 아키텍처와 관련된 소스 |\r\n| block | 블록 입출력 계층 |\r\n| crypto | 암호화 API |\r\n| Documentation | 커널 소스 문서 |\r\n| drivers | 장치 드라이버 |\r\n| firmware | 특정 드라이버를 사용할 때 필요한 장치 펌웨어 |\r\n| fs | 가상 파일시스템 및 개별 파일시스템 |\r\n| include | 커널 헤더 파일 |\r\n| init | 커널 시작 및 초기화 관련 코드 |\r\n| ipc | 프로세스 간 통신 관련 코드 |\r\n| kernel | 스케줄러와 같은 핵심 커널 서브시스템 |\r\n| lib | 유틸리티 루틴 |\r\n| mm | 메모리 관리 서브시스템 및 가상 메모리 |\r\n| net | 네트워크 서브시스템 |\r\n| samples | 예제, 데모 코드 |\r\n| scripts | 커널을 빌드하는 데 사용하는 스크립트 | \r\n| security | 리눅스 보안 모듈 |\r\n| sound | 사운드 서브시스템 |\r\n| usr | 초기 사용자 공간 코드 initramfs |\r\n| tools | 리눅스 개발에 유용한 도구 |\r\n| virt | 가상화 기반 구조 |\r\n\r\n* 소스트리 최상위에 있는 파일 : COPYING 파일은 커널 저작권 파일, CREDITS 파일에는 커널 개발 기여 개발자 명단, MAINTAINERS 파일에는 커널 서브시스템과 드라이버를 관리하는 사람들 명단, Makefile은 커널의 기본 __Makefile__\r\n\r\n\r\n#커널 설정\r\n\r\n커널 설정 옵션은 __CONFIG__으로 시작하는 CONFIG\\_FEATURE과 같은 형태  \r\ne.g.) CONFIG\\_SMP : SMP 지원 여부  \r\n\r\n두가지 혹은 세가지 설정 값(보통 드라이버의 경우 세 가지 선택이 가능)을 지님.  \r\n\r\n__yes__ or __no__ (or __module__)  \r\n\r\n__module__ 값을 가지는 경우 해당 기능은 모듈 형태(동적으로 로드할 수 있는 별도 오브젝트)로 컴파일된다.  \r\n\r\n설정 옵션은 문자열이나 숫자가 될 수도 있음  \r\n이런 옵션은 빌드과정을 조절하는 데 사용하지 않음  \r\n전처리 매크로를 통해 커널 소스가 참조하는 값을 지정하는 데 사용  \r\n정적으로 배열 크기를 지정하는 옵션이 그러한 예  \r\n\r\nUbuntu용으로 Canonical에서 제공하거나, Fedora용으로 Red Hat에서 제공하는 것과 같은 벤더 커널은 컴파일된 상태로 배포본에 들어 있다. \r\n이런 커널에는 많이 사용하는 커널 기능이 모두 들어 있음.  \r\n거의 모든 드라이버를 모듈 형태로 컴파일함.  \r\n이렇게 하면, 모듈을 통해 다양한 하드웨어를 지원하는 기본 커널로 사용 가능  \r\n스스로 커널을 컴파일하고, 어떤 모듈을 포함시킬 것인지 제외할 것인지 배워나가야 한다.\r\n\r\n커널은 설정을 조절하는 여러 가지 도구를 제공  \r\n가장 간단한 도구로 텍스트 기반의 명령행 도구가 있다   \r\n\r\n```$ make config```  \r\n\r\n이 도구는 각 옵션을 하나씩 돌아가면서 대화식으로 사용자에게 yes, no, (세 가지 선택 가능 시) module 중에서 어떤 선택을 할지 물어본다.  \r\n이는 시간이 아주 오래 걸리는 일이므로 시간당 급여를 받는 상황이 아니라면 ncurses 라이브러리 사용하는 그래픽 환경의 도구를 이용하는 편이 좋다. \r\n\r\n```$ make menuconfig```\r\n\r\n또는 gtk+ 기반의 그래픽 환경 도구를 이용할 수도 있다.\r\n\r\n```$ make gconfig```\r\n\r\n이 두가지 도구는 다양한 설정 옵션을 '프로세서 형식 및 기능' 등의 항목으로 분류해 보여줌.  \r\n각 분류항목을 오가면서 커널 옵션을 확인하고 값을 변경할 수 있다. \r\n\r\n다음 명령은 아키텍처에 맞는 기본 설정을 만들어 줌  \r\n\r\n```$ make defconfig```\r\n\r\n이렇게 만들어진 기본 값은 다소 임의적이기는 하지만(i386의 경우 리누스가 사용하는 설정 값이라는 소문 있음.)  \r\n커널을 설정해본 적이 없는 경우에는 좋은 출발점이 될 수 있을 것이다.  \r\n빨리 빌드해서 실행해보고 싶다면, 이 명령을 실행한 다음 하드웨어에 필요한 옵션이 설정되었는지 확인하자.  \r\n\r\n옵션 설정은 커널 소스 트리의 최상위에 있는 .config 파일에 저장된다. (대부분의 커널 개발자가 그렇듯이)  \r\n이 파일을 직접 수정하는 편이 쉽게 느껴질 수 있음.  \r\n이 파일에서 설정 옵션을 찾아 값을 변경하는 일이 그다지 어렵지 않기 때문  \r\n설정파일을 직접 변경한 경우나, 기존의 설정 파일을 새 커널 트리에 사용하는 경우에는 다음 명령을 이용해 설정 확인 및 갱신 가능  \r\n\r\n```$ make oldconfig```\r\n\r\n커널을 빌드하기 전에 항상 이 명령을 실행해야 한다.  \r\nCONFIG\\_IKCONFIG\\_PROC 설정 옵션을 사용하면 전체 커널 설정 파일을 압축해서 /proc/config.gz 파일에 저장한다.  \r\n이를 이용하면 새 커널을 빌드할 때 현재 사용하는 설정을 쉽게 복사 가능  \r\n현재 커널이 이 옵션을 사용하고 있다면, 다음과 같은 방법으로 /proc에 있는 설정 파일을 이용해 새 커널을 빌드할 수 있다.  \r\n\r\n```\r\n$ zcat /proc/config.gz > .config\r\n$ make oldconfig\r\n```\r\n\r\n어떤 방식으로든 커널 설정을 마쳤다면, 다음 명령으로 간단하게 커널을 빌드할 수 있다. \r\n\r\n```$ make```\r\n\r\n이전 버전 커널과는 달리 2.6에서는 의존성 정보 자동 관리됨. => 커널 빌드하기 전 make dep 명령 실행 필요 없음  \r\n또한, bzImage와 같은 특정 빌드 형식을 지정하거나 모듈을 별도로 빌드하지 않아도 된다.  \r\nMakefile이 기본적인 모든 것을 처리함\r\n\r\n\r\n#빌드 메시지 최소화\r\n\r\n빌드 시 쏟아지는 메시지를 최소화하면서도 경고나 오류 메시지를 놓치지 않으려면 make의 출력을 리다이렉트한다.\r\n\r\n```$ make > ../detritus```\r\n\r\n빌드 과정의 출력 메시지를 보고 싶다면 저장된 파일을 보면 된다.  \r\n하지만 경고와 오류 메시지는 표준 에러 장치로 출력되므로 대개 이 파일을 볼 일은 없다.  \r\n대신 다음을 실행  \r\n\r\n```$ make > /dev/null```\r\n\r\n이렇게 하면 모든 불필효한 출력을 다시는 돌아오지 못하는 커다란 하수구인 /dev/null로 보낸다. \r\n\r\n\r\n\r\n#빌드 작업을 동시에 여러 개 실행\r\n\r\nmake 프로그램에는 빌드 과정을 여러 개의 병렬 작업으로 분리해 주는 기능이 있다.  \r\n각각의 작업은 별도로 동시에 실행되므로 다중 프로세서 시스템에서는 빌드 속도를 크게 향상시킬 수 있다.  \r\n커다란 소스를 빌드하는 경우에는 입출력 대기 시간(프로세스가 입출력 요청이 완료되기를 기다리는 시간)이 차지하는 비중이 높으므로 이 기능을 이용해 프로세스 이용도 높일 수 있음  \r\n\r\nMakefile의 의존성 정보가 잘못되어 있는 경우가 너무나 많아 기본적으로는 make는 하나의 작업만 생성한다.  \r\n잘못된 의존성 정보하에서 여러 개의 작업을 생성하면 다른 작업에 영향을 미쳐 전체 빌드 과정에서 오류가 발생할 수 있기 때문 \t\r\n커널 Makefile의 의존성 정보는 정확하므로 여러 개의 작업을 생성해도 문제가 발생하지 않는다.  \r\n다중 make 작업을 통해 커널을 빌드하려면 다음 명령을 이용  \r\n\r\n`$ make -jn`\r\n\r\n여기서 n은 생성할 작업의 개수 의미  \r\n일반적으로 프로세서 하나당 하나 또는 두 개의 작업을 생성하는 것이 적당  \r\n예를 들어 16코어 장비라면 다음과 같이 실행 가능  \r\n\r\n`$ make -j32 > /dev/null`\r\n\r\ndistcc 또는 ccache와 같은 도구 사용 시 커널 빌드 시간을 극적으로 줄일 수 있다. \r\n\r\n\r\n#새 커널 설치\r\n\r\n커널을 빌드하고 나면 커널 설치해야 함  \r\n설치 방법은 아키텍처 및 부트 로더에 따라 다르므로 커널 이미지를 어디에 복사하고, 해당 이미지로 부팅하려면 어떻게 해야 하는지 부트 로더 사용법 참고  \r\n새 커널이 문제를 일으킬 수 있으므로 안전한 것으로 확인된 커널 한두 개를 사용할 수 있도록 해두는 것을 잊지 말 것  \r\n예를 들어, grub을 사용하는 x86 시스템이라면 arch/i386/boot/bzImage 파일을 /boot 디렉토리 안에 vmlinuz-version 같은 이름으로 넣어두고, /boot/grub/grub.conf 파일을 수정해 새 커널을 위한 항목을 추가  \r\n__LILO__를 사용해 부팅하는 시스템이라면 /etc/lilo.conf 파일을 편집하고 lilo 명령을 실행한다.  \r\n\r\n모듈 설치는 자동화되어 있고, 아키텍처에 따른 차이가 없음  \r\n루트 권한으로 다음 명령을 실행하기만 하면 된다.  \r\n\r\n`% make modules_install`\r\n\r\n이렇게 하면 컴파일된 모듈들이 정해진 위치인 /lib/modules 디렉토리에 설치된다.  \r\n빌드 과정에서 커널 소스 트리 최상위에 System.map 파일이 만들어진다.  \r\n이 파일에는 각 커널 심볼의 시작 주소의 위치를 찾을 수 있는 테이블이 들어 있다.  \r\n디버깅 시에 이 정보를 이용해 메모리 주소 값을 그에 해당하는 함수나 변수 이름으로 변환해서 보여줄 수 있음  \r\n\r\n# 다른 성질의 야수\r\n\r\n리눅스 커널은 일반적인 사용자 공간 애플리케이션과 다른 몇 가지 독특한 특징 존재  \r\n이런 차이가 커널 개발 작업을 사용자 프로그램 개발 작업과 다르게 만듬  \r\n\r\n다른 규칙이 적용됨  \r\n당연해 보이는 차이점도 있지만, 명확해 보이지 않는 차이점도 존재\r\n\r\n* 커널은 C 라이브러리나 표준 C 헤더 파일을 사용할 수 없다. \r\n* 커널은 GNU C를 사용한다.\r\n* 커널에는 사용자 공간에서와 같은 메모리 보호 기능이 없다. \r\n* 커널은 부동소수점 연산을 쉽게 실행할 수 없다.\r\n* 커널은 프로세스당 고정된 작은 크기의 스택을 사용한다.\r\n* 커널은 비동기식 인터럽트를 지원하며, 선점형이며, 대칭형 다중 프로세싱을 지원하므로 커널 내에서는 동기화 및 동시성 문제가 매우 중요하다.  \r\n* 이식성이 중요하다. \r\n\r\n# lib와 표준 헤더 파일을 사용할 수 없음\r\n\r\n사용자 공간 애플리케이션과 달리, 커널은 표준 C 라이브러리(또는 그 외의 라이브러리)와도 링크되지 않음  \r\n주요한 이유는 속도와 크기 때문  \r\n전체 C 라이브러리, 아니면 그 중요 일부분이라도 커널 입장에서는 너무 크고 비효율적  \r\n대신 일반적인 libc 함수의 상당수는 커널 안에 구현되어 있으므로 안심해도 좋음  \r\n예를 들어, 보통의 문자열 처리 함수는 lib/string.c에 들어 있음  \r\n<linux/string.h> 헤더 파일 추가 시 해당 함수 사용 가능 \r\n\r\n* 여기서 헤더 파일은 커널 소스 트리 안에 있는 커널 헤더 파일 일컬음.  \r\n  커널 소스에서 외부 라이브러리를 사용할 수 없는 것과 마찬가지로 커널 소스는 외부 헤더 파일을 사용 불가  \r\n  기본 파일은 커널 소스 트리 최상위의  include/ 디렉토리에 있음.  예를 들어, <linux/inotify.h>에 해당하는 파일은 커널 소스 트리의 include/linux/inotify.h에 있다.\r\n  아키텍처별 특정 헤더 파일은 커널 소스 트리의 arch/(아키텍처)/include/asm 디렉토리에 있음.  \r\n  e.g. x86 아키텍처 => arch/x86/include/asm 디렉토리에 있음  \r\n  이 곳의 헤더 파일을 사용하는 경우에는 <asm/ioctl.h>처럼 asm/ 접두사만 사용하면 된다. \r\n\r\n\r\n빠진 함수 중 가장 익숙한 함수 printf()  \r\n커널 코드는 printf()를 사용할 수 없는 대신 printk() 함수를 제공,  \r\n이 함수는 아주 익숙한 printf 함수와 거의 같은 방식으로 작동  \r\nprintk 함수는 형식화한 문자열을 커널 로그 버퍼에 복사하며, 이 메시지는 보통 __syslog__ 프로그램이 처리  \r\n사용법은 printf() 함수와 유사\r\n\r\n`printk(\"Hello wolrd! A string '%s' and an integer '%d'\\n\", str, i);`\r\n\r\nprintf 함수와 printk 함수 사이의 주목할 만한 차이점 하나는 printk 함수에는 우선순위 플래그를 줄 수 있다는 점이다.  \r\n이 플래그를 통해 syslogd(데몬 프로그램)가 커널 메시지를 어느 곳에 표시할지를 결정할 수 있다.  \r\n이 기능을 사용하는 예를 들어보면 다음과 같다.  \r\n\r\n`printk(KERN_ERR \"this is an error!\\n\");`\r\n \r\nKERN\\_ERR과 출력 메시지 사이에 쉼표가 없는 점에 주의  \r\n이는 의도된 표현 방식  \r\n우선순위 플래그는 문자형으로 표시된 선처리 지시자로 컴파일 과정에서 출력 메시지와 합쳐진다.  \r\n\r\n# GNU C\r\n\r\n리눅스 커널은 유닉스 커널과 마찬가지로 C로 프로그램 되어 있음.  \r\n커널은 엄격한 ANSI C로 되어있지 않고, 대신 개발자들은 필요하다고 생각되는 곳에 __gcc__GNU Compiler Collection (커널 및 리눅스 시스템에 있는 C로 작성된 다른 거의 모든 프로그램 컴파일 시 사용하는 C 컴파일러)가 제공하는 다양한 언어 확장 기능 사용  \r\n\r\n커널 개발자들은 C 언어의 ISO C99과 GNU C 확장 기능 모두 사용  \r\ngcc의 기능을 충분히 지원하는 최근 버전의 Intel C 컴파일러로도 리눅스 커널을 컴파일할 수 있지만,  \r\n이런 점들로 인해 리눅스 커널은 gcc 편향되 있음  \r\n지원하는 가장 오래된 gcc 버전은 3.2이며, 4.4 이후 버전을 권장  \r\nISO C99는 C 언어의 공식적인 개정판으로 기존과 큰 차이 없으므로 다른 코드에서도 서서히 이용되는 추세  \r\n표준 ANSI C에 비해 더 생소한 확장 기능은 GNU C가 제공하는 확장 기능들  \r\n\r\n##인라인 함수\r\n\r\nC99와 GNU C 모두 인라인 함수를 지원  \r\n인라인 함수는 이름으로 짐작할 수 있듯이 각 함수 호출이 일어나는 자리의 줄 안에 삽입되는 함수  \r\n이 기능을 통해 함수 호출과 반환 시에 발생하는 부가 비용(레지스터를 저장, 복원 등)을 제거 가능  \r\n컨파일러가 함수를 호출하는 코드와 호출되는 코드를 하나로 보고 최적화 가능해 더 정교한 최적화가 가능  \r\n함수의 내용이 호출하는 자리에 복사되어 들어가기 때문에 코드의 크기가 커지며,  \r\n이로 인해 메모리 사용량과 명령어 캐시 사용량이 늘어남  \r\n커널 개발자들은 일부 실행시간이 중요한 함수에 대해 인라인 함수 사용  \r\n\r\n큰 함수를 인라인으로 만드는 일은 해당 함수가 특별히 자주 사용되거나 실행시간에 극히 민감한 경우가 아니라면 피하는 것 권장  \r\n\r\n인라인 함수는 함수 정의부분에 static과 inline 지시어를 사용해 선언  \r\n\r\n`static inline void wolf(unsigned long tail_size)`\r\n\r\n인라인 함수 정의는 함수를 사용하기 전에 해야 함. 그렇지 않으면 컴파일러가 함수를 인라인으로 만들 수 없음.  \r\n인라인 함수를 헤더 파일에 두고 사용하는 것이 일반적.  인라인 함수는 static으로 지정했으므로 외부에서 사용 불가.  \r\n인라인 함수가 한 파일에서만 사용된다면 해당 파일의 최상단에 둘 수 있음.  \r\n\r\n커널에서는 형__type__ 보호 및 가독성 등의 이유로 복잡한 매크로를 사용하는 것보다 인라인 함수를 사용하는 것을 선호  \r\n   \r\n##인라인 어셈블리\r\n\r\ngcc C 컴파일러는 일반적인 C 함수 안에 어셈블리 명령을 삽입하는 기능을 제공  \r\n이 기능은 특정 시스템 아키텍처에서만 사용하는 커널 소스에서 사용  \r\n\r\n인라인 어셈블리 이용 시 asm() 컴파일러 지시자 사용  \r\ne.g. x86 프로세서의 rdtsc 명령 실행해서 타임스탬프 레지스터(tsc) 내용 받아오는 코드\r\n```\r\nunsigned int low, high;\r\nasm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\r\n/* 이제 low와 high에는 각각 64비트 tsc의 하위 32비트, 상위 32비트의 값이 들어간다. */\r\n```\r\n\r\n리눅스 커널은 C와 어셈블리를 혼합해서 작성되어 있는데, 어셈블리는 주로 하부 아키텍처와 관련되어 있거나 빠른 속도를 요하는 부분에서 사용  \r\n대부분의 커널 코드는 C로 작성 되어 있음  \r\n\r\n\r\n##분기 구문 표시 \r\n\r\ngcc C 컴파일러는 분기 시에 어느 쪽이 발생할 가능성이 높은지를 이용해 분기 구문을 최적화하는 내장 지시자를 가지고 있음  \r\n컴파일러는 이 지시자를 이용해 분기를 예측 가능  \r\n커널은 이 지시자를 사용하기 쉽게 likely()와 unlikely()라는 매크로로 만들어 사용  \r\n\r\n다음과 같은 코드에서\r\n```\r\nif (error) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n다음과 같은 방식으로 이 분기가 거의 실행되지 않음을 표시 가능 \r\n\r\n```\r\n/* error 값이 거의 항상 0일 것으로 생각 가능 */\r\n⁭if (unlikely(error)) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n반면, 항상 실행될 것 같은 경우\r\n\r\n```\r\n/* success 값은 거의 항상 0이 아닐 것으로 간주 */\r\nif (likely(error)) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n분기의 방향이 거의 대부분 알려진 한 방향으로만 일어나는 경우, 또는 다른 경우를 무시하고 한 가지 경우에 대해서만 최적화가 필요한 경우 이 지시자 사용  \r\n매우 중요한 사항으로, 이 지시자 오용 시에 심각한 성능저하  \r\n일반적으로는 앞에서 봤듯이 오류가 발생하는 상황에서 unlikely()와 likely()를 사용  \r\n특별히 예외를 처리하기 위해 if 문을 사용하는 경우 많음,  \r\n커널에서도 주로 unlikely() 지시자 사용  \r\n\r\n##메모리 보호 없음 \r\n\r\n사용자 공간 애플리케이션이 메모리 접근을 잘못하면, 커널은 오류를 탐지해 SIGSEGV 시그널을 보내고 프로세스 종료.  \r\n하지만 커널이 메모리 접근을 잘못한 경우에는 이를 제어하기 어려움  \r\n커널에서의 메모리 침범은 중대한 커널 오류인 oops를 발생시킴  \r\nNULL 포인터 참조와 같이 잘못된 메모리 접근을 해서는 안 된다는 것은 당연하지만 커널에서 그 위험성이 훨씬 큼.\r\n\r\n또한 커널 메모리는 페이징 기능 사용 불가  \r\n커널에서 사용하는 모든 메모리는 실제 물리적인 메모리에 해당  \r\n나중에 커널에 새로운 기능을 추가해야 한다면 이 점 명심해야 함  \r\n\r\n##부동 소수점 쉽게 사용 불가\r\n\t\r\n사용자 공간 애플리케이션이 부동 소수점 연산을 사용할 경우, 커널이 정수와 부동 소수점 연산 모드 전환 관리  \r\n부동 소수점 연산 이용 시 커널이 해야 하는 일은 아키텍처에 따라 다르지만,   \r\n보통 커널이 트랩을 받아 정수 연산에서 부동 소수점 연산 모드로 전환하는 방식으로 동작  \r\n\r\n사용자 공간과 달리 커널은 자신의 트랩을 받을 수 없어 깔끔한 부동 소수점 전환 기능 이용 불가  \r\n커널 내에서 부동 소수점을 사용하려면 수동으로 부동 소수점 레지스터를 저장하고 복원하는 등 잡다한 일을 직접 해야 함.  \r\n사용하지 말아야 함. 아주 드문 경우 제외, 커널에서 부동 소수점 연산 사용 안 함.\r\n\r\n##작은 고정 크기의 스택\r\n\r\n사용자 공간에서는 스택에 커다란 구조체나 수 천 개 크기의 배열 등 많은 변수 정적 할당 가능  \r\n사용자 공간에는 동적으로 확장 가능한 커다란 스택이 있기 때문에 가능  \r\nDOS 같은 구식 OS 경우 사용자 공간에서도 고정 크기 스택 쓰기 때문에 문제 될 수는 있음  \r\n\r\n커널이 사용하는 스택은 크지도 않고, 동적으로 확장 불가  \r\n커널 스택의 정확한 크기는 아키텍처에 따라 다름  \r\nx86 아키텍처의 경우 : 컴파일 시에 4KB 또는 8KB로 정할 수 있음  \r\n관습적으로 커널 스택은 두 페이지로 구성하므로, 이는 커널 스택의 크기가 32비트 아키텍처에서는 8KB, 64비트 아키텍처에서는 16KB로 고정 되 있으며, 바꿀 수 없음을 의미  \r\n각 프로세스별로 각자의 스택이 할당됨  \r\n\r\n##동기화와 동시성\r\n\r\n커널은 경쟁 상태__race condition__에 놓이기 쉬움.  \r\n단일 스레드의 사용자 공간 애플리케이션과 달리, 커널은 공유 자원에 대한 동시 접근 허용해야 하므로 경쟁 방지하기 위한 동기화 필요\r\n\r\n다음과 같은 경우 존재  \r\n* 리눅스는 선점형 멀티태스킹 OS. 커널의 프로세스 스케줄러에 의해 프로세스의 실행 순서가 조정됨. 커널은 이 작업들 간의 동기화를 책임져야 함.\r\n* 리눅스는 대칭형 다중 프로세서(SMP) 지원. 따라서 적절한 보호 장치 없으면 동일한 자원에 하나 이상의 프로세스가 동시에 접근하는 커널 코드 실행할 수 있음. \r\n* 현재 실행하고 있는 코드와 상관없이 비동기식으로 인터럽트가 발생. 따라서 적절한 보호 장치 없을 시 자원 사용 도중 인터럽트가 발생하고 인터럽트 핸들러에서 같은 자원에 접근하는 상황 발생 가능.  \r\n* 리눅스 커널은 선점형. 따라서 적절한 보호 장치가 없을 시 같은 자원에 접근하는 다른 커널 코드가 실행 중인 커널 코드를 선점하는 일이 발생 가능. \r\n\r\n경쟁 상태 해결하는 전형적인 해법은 스핀락__spinlock__이나 세마포어__semaphore__를 이용하는 것.  \r\n\r\n##이식성의 중요성 \r\n\r\n사용자 공간 애플리케이션은 이식성이 그다지 중요하지 않을 수 있음  \r\n리눅스는 이식성이 좋은 OS이며, 그 특성 유지해야 함.  \r\n이는 아키텍처 독립적인 C 코드가 여러 다양한 시스템에서 컴파일되고 실행되어야 한다는 의미이며,  \r\n커널 소스 트리에서 아키텍처 독립적인 코드는 특정 시스템에 의존적인 코드와 적절하게 분리되어 있어야 한다는 뜻.  \r\n\r\n엔디언 중립성, 64비트 지원, 워드 및 페이지 크기 지정 등 몇 가지만 설명해도 방대함.\r\n\r\n##결론\r\n\r\n커널에는 고유한 특징 존재  \r\n커널은 자신만의 규칙을 사용하며 전체 시스템을 관리하는 만큼 분명 그에 따르는 위험도 큼  \r\n하지만 리눅스 커널의 복잡도와 진입장벽은 여타 대규모 소프트웨어 프로젝트와 질적으로 크게 다르지 않음  \r\n\r\n리눅스 개발에 있어 가장 중요한 단계는 커널이 두려움의 존재가 아니라는 것을 깨닫는 것.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/리눅스 커널 (2) - 빌드와 설치, 주의사항/"},"frontmatter":{"title":"리눅스 커널 (2) - 빌드와 설치, 주의사항","published":true}}},{"node":{"rawMarkdownBody":"\r\nLatex 문법으로 수식 표현을 간단하게 할 수 있는 플러그인으로 Katex, MathJax 두 가지가 있는데,  \r\n\r\nMathJax는 dependency도 많고 Katex가 렌더링이 체감될 정도로 빠르므로 Katex 플러그인으로 수식표기를 하기로 결정했다.\r\n\r\n \r\n\r\nKatex 플러그인을 Gatsby 블로그에 적용하기 위해서 우선,  \r\n\r\n`$ npm install --save gatsby-remark-katex katex`  \r\n또는  \r\n`$ yarn add gatsby-remark-katex katex`  \r\n을 통해 katex를 설치해준다.  \r\n\r\nKatex 플러그인을 사용하기 위해 __gatsby-transformer-remark__ 플러그인이 필요한데, 마크다운 설정이 미리 되어있다면 이미 설치되어있을 수 있다.  \r\n\r\n\r\n###gatsby-config.js\r\n```js\r\nmodule.exports = {\r\n  // \r\n  plugins: [\r\n    \r\n    {\r\n      resolve: `gatsby-transformer-remark`,\r\n      options: {\r\n        plugins: [\r\n          \r\n          {\r\n            resolve: `gatsby-remark-katex`,\r\n            options: {\r\n              // Add any KaTeX options from https://github.com/KaTeX/KaTeX/blob/master/docs/options.md here\r\n              strict: `ignore`,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    \r\n  ],\r\n}\r\n```\r\n__gatsby-transformer-remark__ 안에 __gatsby-remark-katex__이 들어가는 꼴로 작성해야 한다.\r\n\r\n\r\n***\r\n\r\n\r\n[공식문서](https://www.gatsbyjs.org/packages/gatsby-remark-katex)에   \r\n\r\nAdd Katex CSS to your template: Katex’s CSS file is required to render the formulas correctly. \r\nInclude the CSS file in your template (example):\r\n\r\n``require(`katex/dist/katex.min.css`)``  \r\n\r\n__katex.min.css__를 참조할 수 있도록 조치하라고 되어있는데,  \r\n\r\nblog post를 띄우는 __src/templates/(포스트 관련.js)__ 파일 안에\r\n\r\n나의 경우에는 `import '../../../node_modules/katex/dist/katex.min.css';`를 추가하여 해결하였다.\r\n\r\n\r\n***\r\n\r\n이제 Katex가 적용된다.\r\n\r\n'$' 문자 하나 사이에 표현하는 inline,\r\n두개 사이에 표현하는 block 방식으로 사용할 수 있다.\r\n\r\n`$a^2 + b^2 = c^2$ 인라인`  \r\n\r\n$a^2 + b^2 = c^2$ 인라인\r\n\r\n```\r\n$$\r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n```\r\n$$\r\na^2 + b^2 = c^2   \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n\r\n","fields":{"slug":"/Gatsby 블로그 수식 표현 플러그인 Katex 적용법/"},"frontmatter":{"title":"Gatsby 블로그 수식 표현 플러그인 Katex 적용법","published":true}}},{"node":{"rawMarkdownBody":"\r\n#01 정보보호관리의 개념\r\n\r\n##1. 정보화 사회의 정보보호\r\n\r\n###(1) 정보사회의 특성과 정보화 역기능\r\n\r\n####1) 정보사회의 특성\r\n 초고속 정보통신 기반구조, 인터넷의 확산과 전자상거래, 사회 모습은 변화, 다양한 특성  \r\n 재택근무가 증가, 홈뱅킹이나 사이버 주식거래   \r\n 미래전쟁 양상으로 떠오르는 정보전쟁, 자동화된 지휘통제시스템과 해커 * 바이러스를 이용하는 사이버 전쟁 개념  \r\n\r\n●\t사이버환경의 특징\r\n-\t비대면성\r\n-\t익명성\r\n-\t시간 및 공간적 운영의 무제한성\r\n-\t무제한적인 정보 및 신속한 전송\r\n-\t미래의 범죄 및 전쟁 공간\r\n\r\n####2) 정보화 역기능\r\n 역기능적인 문제점 또한 갈수록 심각  \r\n 개인의 프라이버시 침해, 해커와 바이러스의 기승, 불법적인 위 * 변조를 통한 각종 컴퓨터 범죄행위, 정보시스템의 파괴에 의한 사회마비 등  \r\n 모바일 환경에서의 정보보호, 중요정보의 노출과 프라이버시 침해 등  \r\n\r\n●\t최근 사이버공격의 특징\r\n-\t공격 기술의 지능화 및 고도화\r\n-\t사이버 공격 전파경로의 다원화\r\n-\t사이버 공격의 초고속화 및 초단기화\r\n-\t사이버 공격의 분산화 및 에이전트화\r\n\r\n\r\n###(2) 정보보호(Information Security)\r\n\r\n####1) 정의 \r\n [정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위]  \r\n 정보보호 : [기밀성, 무결성, 가용성, 인증성 및 부인방지를 보장하기 위하여 기술적 * 물리적 * 관리적 보호대책을 강구하는 것]   \r\n\r\n####2) 정보의 가용성과 안정성(보안성)\r\n 정보의 가용성과 보안 측면에서 정보보호 : [정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위]  \r\n 가용성을 극대화, 정보의 통제는 위협 요소를 줄이고 안정성을 확보  \r\n\r\n●\t가장 쉬운 침투방법 선택 원리(principle of easiest penetration)\r\n-\t침입자는 이용 가능한 모든 침투수단을 이용할 것이다. 침투는 가장 분명한 수단을 이용하여 일어나는 것이 아니고, 침투에 대한 강력한 대비책이 마련되어 있다면 일반적으로 쉽게 이루어지지 않을 것이다. \r\n\r\n●\tNIST의 컴퓨터 보안 정의\r\n-\t정보시스템 자원(하드웨어, 소프트웨어, 펌웨어, 정보/데이터, 통신)의 무결성, 가용성, 기밀성을 보전하고자 하는 목표 달성을 위해 자동화된 정보시스템에 제공하는 보호(컴퓨터 보안에 있어서 가장 핵심이 되는 3가지 주요 목표 제시)\r\n\r\n\r\n####3) 정보보호의 목표\r\n__(가) 기밀성(Confidentiality)__  \r\n직 인가된(authorized) 사람, 인가된 프로세스, 인가된 시스템만이 알 필요성(Need-to-know)에 근거하여 시스템에 접근해야 한다는 원칙  \r\n데이터 처리의 모든 접속점에서 필요한 수준의 비밀 엄수(secrecy)가 강제, 정보 유출을 예방  \r\n접근 제어, 암호화  \r\n\r\n__(나) 무결성(Integrity)__  \r\n네트워크를 통하여 송수신되는 정보의 내용이 불법적으로 생성 또는 변경되거나 삭제되지 않도록 보호  \r\n전력차단과 같은 시스템 중단 경우에도 위반 가능  \r\n접근 제어, 메시지 인증 등으로 보장, 침입 탐지, 백업 등으로 예방\r\n\r\n__(다) 가용성(Availability)__  \r\n시스템이 지체 없이 동작, 합법적 사용자가 서비스 사용  \r\n정보의 비가용성 해로움  \r\n데이터의 백업, 중복성의 유지, 물리적 위협요소로부터의 보호 등  \r\n\r\n__(라) 인증성(인증, Authenticity, Authentication)__  \r\n진짜라는 성질을 확인할 수 있고, 확인 및 신뢰할 수 있다는 것, 출처 유효성에 대한 확신  \r\n\r\n__(마) 책임추적성(책임성, Accountability)__  \r\n개체의 행동을 유일하게 추적해서 찾아낼 수 있음  \r\n부인 봉쇄, 억제, 결함 분리, 침입 탐지 예방, 사후 복구와 법적인 조치 등  \r\n보안 침해에 대한 책임이 있는 곳까지 추적  \r\n시스템은 활동 상황을 기록, 포렌식(forensic) 분석을 하여 보안 침해를 추적하여 전송 관련 분쟁 해결\r\n\r\n●\tCIA Triad(삼각형)\r\n-\t1. 가용성\r\n-\t2. 무결성\r\n-\t3. 기밀성  \r\n●\t정보를 안전하게 보호하기 위해서는 비인가된 접근으로부터 안전하고(기밀성), 비인가된 변경으로부터 보호되어야 하며(무결성), 필요할 때 권한이 있는 사용자가 이용할 수 있어야 한다(가용성).\r\n\r\n●\t추가 정보보호 목표\r\n-\tCIA Triad를 사용해서 보안 목적을 잘 정의했지만, 보안 목적을 완성되게 표현하려면 보안 실무 필드에서 필요한 개념을 추가해야만 한다. 그 중에서 가장 많이 언급되는 개념은 인증성, 책임추적성이다.\r\n\r\n●\t부인 봉쇄(부인방지)\r\n-\t메시지의 송수신이나 교환 후, 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술\r\n\r\n\r\n##2. 정보보호 관리\r\n\r\n###1) 정보보호 관리(Information Security Management)의 개념\r\n\r\n●\t정보보호와 정보보호 관리 시스템\r\n-\t정보보호 : 정보의 수집/가공/저장/검색/송신/수신 중에 발생하는 정보의 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단, 또는 그러한 수단으로 이루어지는 행위. \r\n-\t정보보호 관리 시스템 : 정보통신 서비스 제공자가 정보통신망의 안정성 및 신뢰성을 확보하여 정보자산의 기밀성, 무결성, 가용성을 실현하기 위한 관리적 * 기술적 수단과 절차 및 과정을 체계적으로 관리, 운영하는 체계. 2010년부터 행정 기관은 정보보호관리 시스템(ISMS) 인증을 의무적으로 받아야 한다. \r\n\r\n\r\n###2)  정보보호 관리와 정보보호 대책\r\n__(가) 개요__\r\n1.\t정보보호 관리는 기술적 보호대책, 물리적 보호대책, 관리적 보호대책으로 계층적 구분  \r\n\r\n \r\n__(나) 기술적 보호대책__  \r\n가장 기본적인 대책  \r\n접근통제, 암호기술, 백업 체제, 정보시스템 자체에 보안성이 강화된 시스템 소프트웨어를 사용 등  \r\n\r\n__(다) 물리적 보호대책__  \r\n자연재해로부터 정보시스템이 위치한 정보처리시설을 보호  \r\n불순 세력이나 적의 파괴 대비한 출입통제, 시건(잠금) 장치 등  \r\n\r\n__(라)  관리적 보호대책__  \r\n법 * 제도 * 규정 * 교육 등, 보안계획을 수립(보안등급, 액세스 권한 등), 위험분석 및 보안감사  \r\n제도 * 정책 * 절차 등도 매우 중요  \r\n내부자의 부당행위를 방지하기 위한 교육  \r\n\r\n\r\n●\t기술적 보호대책 : 접근 통제, 암호 기술, 백업 체제 등  \r\n●\t물리적 보호대책 : 화재, 수해, 지진, 태풍 등  \r\n●\t관리적 보호대책 : 법 * 제도 * 규정 *교육 등  \r\n\r\n●\t정보보호 관리는 기업과 조직의 비즈니스 목적을 충족시키면서 수용 가능한 수준으로 위험을 낮추는 것  \r\n●\t위험은 제거대상이 아닌 관리대상  \r\n●\t위험은 식별되거나 감소될 수 있지만 제거될 수는 없음  \r\n●\t정보보호 관리를 위해서는 최고 경영진의 지원과 관심이 반드시 필요  \r\n\r\n\r\n##3. OSI 보안 구조\r\n\r\n###(1) 개요\r\n####1) 기본 개념\r\n ITU-T 권고안 X.800, OSI 보안 구조 : 관리자가 효과적으로 보안 문제를 조직화 하는데에 유용  \r\n●\t보안 공격(Security attack) : 기관이 소유한 정보의 안전성을 침해하는 제반 행위.  \r\n●\t보안 메커니즘(Security mechanism) : 보안 공격을 탐지, 예방하거나 공격으로 인한 침해를 복구하는 절차.  \r\n●\t보안 서비스(Security service) : 조직의 정보 전송과 데이터 처리 시스템의 보안을 강화하기 위한 처리 또는 통신 서비스. 이 서비스는 보안 공격에 대응하기 위한 것이며, 하나 또는 그 이상의 보안 메커니즘을 사용하여 서비스를 제공한다.   \r\n\r\n●\t공격 : 지적인 위협을 수반하는 시스템 보안에 대한 침범을 말한다. 여기서 지적인 위협이란 보안서비스를 교묘히 피하거나 시스템 보안 정책을 위반하는 정교한 시도(특히 방법과 기술 측면에서)를 말한다.  \r\n\r\n###(2) 보안 공격(Security attack)\r\n\r\n####1) 개요\r\n보안의 세 가지 목표(기밀성, 무결성, 가용성)는 보안 공격에 의해 위협  \r\n보안 목표에 관련하여 세 개의 그룹, 공격을 시스템에 미치는 영향에 따라 두 개의 유형  \r\n\r\n●\tOSI 보안 구조는 보안 공격과 보안 기법, 보안 서비스를 체계적으로 정의할 수 있는 틀을 제공한다.   \r\n●\t보안 공격은 소극적 공격과 적극적 공격으로 분류할 수 있다. 소극적 공격에는 파일이나 메시지를 불법적으로 읽거나, 트래픽을 분석하는 것이 포함되고, 적극적 공격에는 파일이나 메시지를 수정하거나, 서비스 거부 공격 등이 포함된다.   \r\n\r\n####2) 기밀성을 위협하는 공격\r\n__(가) 스누핑(Snooping)__  \r\n데이터에 대한 비인가 접근 또는 탈취  \r\n\r\n__(나) 트래픽분석(Traffic Analysis)__  \r\n온라인 트래픽을 분석함으로써 다른 형태의 정보 얻기 가능  \r\nex) 전송의 성향을 추측하는데 도움이 되는 질의와 응답의 쌍을 수집  \r\n\r\n####3) 무결성을 위협하는 공격\r\n__(가) 변경(메시지 수정, Modification)__  \r\n적법한 메시지의 일부를 불법으로 수정하거나 메시지 전송을 지연시키거나 순서를 뒤바꾸어 인가되지 않은 효과를 노리는 행위  \r\n\r\n__(나) 가장(Masquerading)__  \r\n신분위장은 한 개체가 다른 개체의 행세, 다른 형태의 적극적 공격과 병행해서 수행  \r\n\r\n__(다) 재연(재전송, Replaying)__  \r\n적극적 공격의 하나로, 획득한 데이터 단위를 보관하고 있다가 시간이 경과한 후에 재전송  \r\n인가되지 않은 사항에 접근하는 효과를 노리는 행위  \r\n\r\n__(라) 부인(Repudiation)__  \r\n자신이 메시지를 보냈다는 것을 부인 또는 메시지를 받았다는 것을 부인  \r\n부인방지(부인 봉쇄, Nonrepudiation)  \r\n●\t부인 봉쇄란 송신자나 수신자 양측이 메시지를 전송했거나 수신한 사실 자체를 부인하지 못하도록 막는 것을 말한다. \r\n\r\n####4) 가용성을 위협하는 공격\r\n__(가) 서비스 거부(Denial of Service)__  \r\n시스템의 서비스를 느리게 하거나 완전히 차단  \r\n\r\n●\t공격의 발원지에 따른 구분\r\n-\t내부 공격 : 보안 경계 내부의 존재에서 시작된 공격, 내부자에게 시스템 자원접근은 허가되나 허용된 권한 이상으로 사용할 때 발생\r\n-\t외부 공격 : 보안 경계 외부에서 허가되지 않은 불법적인 사용자에 의해 시작된 공격, 공격자는 인터넷상의 아마추어부터 조직화된 범죄자, 국제 테러리스트, 적국의 정부 등일 수 있다.  \r\n\r\n\r\n####5) 소극적 공격과 적극적 공격\r\n __(가) 개요__  \r\n보안 공격(Security attack)을 X.800과 RFC 2828에 따라 분류하면 소극적 공격(passive attack)과 적극적 공격(active attack)으로 나눔  \r\n\r\n| Attack | Passive/Active | Threatening |\r\n|:--------:|:--------:|:--------:|\r\n| Snooping, Traffic analysis | Passive | Confidentiality |\r\n| Modification, Masquerading, Replaying, Repudiation | Active | Integrity |\r\n| Denial of Service | Active | Availability |\r\n\r\n__(나) 소극적 공격(수동적 공격, Passive Attack)__  \r\n목표는 단지 정보를 획득, 공격자가 데이터를 변경하거나 시스템에 해를 끼치지 않는다는 것    \r\n송신자나 수신자는 제3자가 메시지 패턴을 관찰하는지 알 수 없음. 따라서, 탐지보다 예방  \r\n\r\n__(다) 적극적 공격(능동적 공격, Active Attack)__  \r\n데이터를 바꾸거나 시스템에 해를 입힘, 결성과 가용성을 위협하는 공격  \r\n공격자가 다양한 방법을 사용하기 때문에 일반적으로 방어하기보다 탐지  \r\n치명적인 공격의 대부분  \r\n대부분의 능동적 공격은 상당 기간 동안의 수동적 공격 수행을 통해 수집된 정보를 바탕  \r\n\r\n●\tNIST의 정보보호 핵심 5원칙\r\n-\t1. 가용성\r\n-\t2. 무결성\r\n-\t3. 기밀성\r\n-\t4. 책임추적성(Accountability)\r\n-\t5. 보증(Assurance)\r\n\r\n##4. 기본 보안용어 정의\r\n####1) 자산(Asset)\r\n조직이 보호해야 할 대상으로서 데이터 혹은 자산 소유자(Data Owner)가 가치를 부여한 실체  \r\n\r\n####2) 취약점(취약성, Vulnerability)\r\n컴퓨터나 네트워크에 침입하여 환경 내의 리소스에 대한 허가되지 않은 접근을 시도하려는 공격자에게 열린 문을 제공할 수 있는 소프트웨어, 하드웨어, 절차 혹은 인력상의 약점을 가리킨다. 즉, 위협의 이용대상으로 관리적, 물리적, 기술적 약점  \r\n\r\n####3) 위협(Threat) : 위협은 취약성 제어수단에 의하여 차단된다.\r\n손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합  \r\n보안에 해를 끼치는 행동이나 사건  \r\n●\t가로채기(interception) : 비인가된 당사자가 자산으로의 접근을 획득한 것을 의미(불법 복사, 도청  등)  => __기밀성__에 영향   \r\n●\t가로막음(interruption) : 시스템 자산은 손실되거나, 손에 넣을 수 없거나, 사용불가능하게 됨(하드웨어 장치의 악의적 파괴, 파일 삭제, 서비스 거부 등) => __가용성__에 영향     \r\n●\t변조(modification) : 비인가된 당사자가 접근하여 그 내용을 변경(데이터베이스 특정값 변경, 특정 프로그램 변경 등) => __무결성__에 영향  \r\n●\t위조(fabrication) : 비인가된 당사자가 컴퓨팅 시스템상에 불법 객체의 위조 정보를 생성(네트워크 통신에 가짜 거래 정보 만듦 등) => __무결성__에 영향  \r\n\r\n| 분류 | 내용 |\r\n| :--------: | :--------: | \r\n| __자연에 의한 위협__ | 화재, 홍수, 지진, 전력 차단 등 자연에 의한 대표적인 위협으로부터 발생하는 재난을 항상 예방할 수는 없지만 화재경보기, 온도계, 무정전 시스템 등을 설치하여 피해를 최소화할 수 있다. |\r\n| __인간에 의한 위협__ | __비의도적 위협__ : 정보시스템의 보안 사고를 일으키는 가장 큰 위협으로 인간의 실수와 태만이 주된 원인이다. 패스워드의 공유, 데이터에 대한 백업의 부재 등이 대표적인 부주의와 태만으로 간주되며, 이러한 위협은 언론매체에서 크게 다루어지지는 않지만 실제로는 정보보호 문제를 일으키는 가장 중요한 요인이다. <br/>  __의도적 위협__ : 컴퓨터 바이러스, 해커, 사이버 테러리스트 등으로부터 발생하며 도청, 신분위장에 의한 불법 접근, 정당한 정보에 대한 부인, 악의적인 시스템 장애 유발 등이 있다. |\r\n\r\n\r\n####4) 위협주체(위협원, Threat agents)\r\n취약점을 이용하는 존재는 위협 주체(threat agent)  \r\n침입차단시스템의 포트를 통해 네트워크에 접근하는 침입자, 보안 정책을 위반하는 방식으로 데이터에 접근하는 프로세스, 시설물을 파괴하는 태풍, 혹은 의도하지 않은 실수로 기밀 정보를 누설하거나 파일의 무결성을 손상시키는 직원\r\n\r\n####5) 위험(Risk)\r\n위협 주체가 취약성을 활용할 수 있는 가능성과 그와 관련된 비즈니스 영향  \r\n위험은 [자산X위협X취약점]\r\n  \r\n####6) 노출(Exposure)\r\n위협 주체로 인해서 손실이 발생할 수 있는 경우  \r\n취약점은 조직에 있어서 가능한 피해를 노출  \r\n\r\n####7) 대책/안전장치(Countermeasure/Safeguard)\r\n잠재적 위험을 완화시키기 위해 배치  \r\n위험을 감소시키기 위한 소프트웨어 설정, 하드웨어 장비, 또는 절차  \r\n\r\n●\t취약성, 위협, 위험, 노출, 대책  \r\n-\t만약 기업이 백신 소프트웨어를 오직 서버에만 설치하고 바이러스 서명(Signature)을 최신으로 유지하지 않는다면 이는 취약성에 해당되며, 해당 기업은 바이러스 공격에 대하여 취약한 것이다. 위협은 해당 환경에서 발생하여 손해를 유발할 수 있는 가능성은 위험이다. 만약 바이러스가 기업의 환경에 침입한다면 취약성은 이용되었고 기업은 손실에 노출된다. 이 상황에 대한 대책은 바이러스 패턴 정보를 최신으로 갱신하여 백신 소프트웨어를 모든 컴퓨터에 설치하는 것이다. \r\n\r\n\r\n\r\n\r\n####8) 다계층 보안/심층 방어(Defense in Depth)\r\nMulti Layered(Level) Security, 여러 계층의 보안대책이나 대응수단을 구성  \r\n한 가지 통제가 대응에 실패하더라도 전체 시스템을 위험에 빠뜨리지 않음  \r\n가장 최선의 보안 접근 방법으로, 보호 * 탐지 * 대응으로 이루어진 보안 접근법  \r\n\r\n\r\n####9) 직무상의 신의성실, 노력(Due Care, Due Diligence)\r\nDue :  특정 목적을 위하여 필요하거나 요구되는 적절하고 충분한 의무이다.  \r\nDue care :  특정 목적을 위하여 필요하거나 요구되는 충분한 주의이다.  \r\nDue Diligence : 특정 목적을 위하여 필요하거나 요구되는 충분한 노력이다.  \r\n\r\n●\t심층 방어(Defense in Depth) : 다수의 통제를 구현함으로써 성공적 침투와 침해가 발생하는 것을 어렵게 만듦   \r\n●\t사회공학(Social Engineering) : 어떤 사람을 속임으로써 허가되지 않은 접근을 획득하는 것  \r\n  \r\n####10) 사회공학(Social Engineering)\r\n인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상적인 보안 절차를 깨트리기 위한 침입 수단  \r\n\r\n●\t가장 약한 링크 원칙(principle of weakness link)  \r\n-\t보안은 가장 약한 링크보다 더 강할 수 없다. 방화벽에 전력을 공급하는 전원장치이건, 보안 응용 기반으로 동작하는 운영체제이건, 또는 제어수단을 기획 * 실현하고 관리하는 사람들이건 간에 어떤 하나의 제어수단의 실패가 전체 보안실패를 야기한다.  \r\n\r\n●\t보안은 비대칭성(Asymmetrical) : 방어측은 모든 취약점을 알아내야 하지만, 공격자는 하나의 취약점이라도 발견하면 됨.  \r\n\r\n\r\n####11) 시점별 통제(Control)\r\n예방통제(Preventive Control) : 사전에 위협과 취약점에 대처하는 통제\r\n탐지통제(Detective Control) : 위협을 탐지하는 통제로, 빠르게 탐지할수록 대처하기 용이\r\n교정통제(Corrective Control) : 이미 탐지된 위협이나 취약점에 대처하거나, 위협이나 취약점을 감소시키는 통제\r\n\r\n| 구분 | 설명 |\r\n| :--------: | :--------: | \r\n| 공격자 | 시스템을 공격하거나 위협하는 존재 |\r\n| 공격 | 시스템의 보안 서비스를 회피하여 보안 정책을 위반하려는 의도된 시도 | \r\n| 대응 | 피해의 최소화 및 적절한 대응을 위해 탐지, 보고하여 위험, 노출, 공격을 제거하거나 방지하는 행위, 장비, 기법 |\r\n| 위험 | 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실 |\r\n| 보안 정책 | 시스템이나 기관이 민감하고 중요한 시스템 자원에 보안 서비스를 제공하기 위해 명시한 규정과 업무 |\r\n| 자산 | 정보 시스템 내의 데이터, 시스템의 서비스, 처리 기능, 통신 대역폭, 시스템 장비(하드웨어, 펌웨어, 소프트웨어, 문서), 시스템 장비 설비 |\r\n| 위협 | 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 때의 잠재적 보안 위반 |\r\n| 취약점 | 시스템 보안 정책을 위반할 수 있는 시스템 설계, 구현, 혹은 운영, 관리상의 오류 및 약점 |\r\n","fields":{"slug":"/정보보안기사 1장/"},"frontmatter":{"title":"정보보안기사 1장","published":true}}},{"node":{"rawMarkdownBody":"\r\nnpm 설치를 위해 node.js 설치하는 과정에서 \r\n\r\n__C:\\Users\\\\(계정이름)\\AppData\\Roaming\\npm-cache\\\\_libvips__ 의\r\n\r\n__libvips-8.7.4-win32-x64.tar.gz__ 파일이 누락됨.   \r\n(__libvips-8.8.1-win32-x64.tar.gz__을 포함한 다른 버전도 동일.)\r\n\r\n네트워크 문제로 파일을 가져오는데에서 문제가 생긴 것으로 보임.\r\n\r\ngithub realese 페이지에서 직접 받아도 다운링크에 접속을 못하여\r\n\r\n구글링을 통해 libvips 압축파일을 정리해둔 링크를 찾아서 해결.  [http://18.176.30.221/list/libvips](http://18.176.30.221/list/libvips)\r\n\r\n\r\n이를 통해 npm install 명령 실행 도중 getaddrinfo EFNOTFOUND 오류가 나며\r\n\r\n링크에서 파일을 받지 못하는 경우 해결 할 수 있음. \r\n\r\n\r\n***\r\n\r\nnode-gyp 설치가 필요하다면,\r\n\r\n\r\n네이티브 애드온 모듈 컴파일링을 하는 __node-gyp__를 설치\r\n\r\n'node-gyp' is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js\r\n\r\n\r\n`$ npm install -g node-gyp`\r\n\r\n\r\n***\r\n\r\n\r\nnode.js를 윈도우에 설치하고서 필수 요소(python2.7 등) 자동 설치를 위한 빌드 툴을 설치해야함.  \r\n`$ npm install --global --production windows-build-tools`\r\n\r\n이번 블로그 적용 중에는 이 것으로 해결이 안되고 아래와 같은 문제가 생김.\r\n\r\n\r\n***\r\n\r\nnode.js 설치 시 파이썬 등 필수 요소 자동설치를 해줘야하는데 \r\n\r\n실패하여 npm이 Python v2.7을 찾지 못하는 경우 \r\n \r\n기본경로인 __C:\\python27__ 경로로 파이썬2.7을 설치해준다.\r\n\r\n\r\n***\r\n\r\nvisual studio가 2019 버전이라 MSBuild.exe ENOENT 에러가 나는 경우, \r\n\r\n빌드를 위해 Visual C++ Build tools의 2015 또는 2017 버전이 필요한데\r\n\r\n따라서 설치해주면 해결된다. [Visual C++ Build tools 설치](https://go.microsoft.com/fwlink/?LinkId=691126)\r\n\r\nwindows 8.1 sdk만 설치해주면 되고,\r\n\r\n`$ npm config set python python2.7`  \r\n`$ npm config set msvs_version 2015`\r\n\r\n위와 같이 컨픽을 설정해주면 에러 없이 빌드된다.\r\n\r\n이번 경우 npm install 시 이 에러 발생.\r\n\r\n- 참고 : [https://github.com/nodejs/node-gyp/issues/1747](https://github.com/nodejs/node-gyp/issues/1747)\r\n\r\n\r\n***\r\n\r\n```\r\n> gatsby develop\r\n\r\nThe above error occurred in the <StoreStateProvider> component:\r\n    in StoreStateProvider\r\n    in App\r\n```\r\n\r\n위의 오류가 발생하는 경우  \r\n\r\nyarn 설치 후   \r\n\r\n`npm install --global yarn`  \r\n\r\ngatsby의 새 버전 재설치를 yarn으로 해주면  \r\n\r\n`yarn add gatsby`  \r\n\r\n\r\n다시 `gatsby develop`가 정상 작동한다.\r\n\r\n- 참고 : [https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201](https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201)\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/Gatsby 블로그 적용 도중 만난 에러/"},"frontmatter":{"title":"Gatsby 블로그 적용 도중 만난 에러","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n# 운영체제와 커널\r\n\r\n__운영체제__ : 정의 힘듬, but 기술적 관점 => 기본적인 사용과 관리 담당하는 시스템의 일부분\r\n - 커널, 장치 드라이버, 부트로더, 명령행 셸(동등 역할의 사용자 인터페이스 포함), 기본적인 파일 및 시스템 유틸리티 등  \r\n\r\n__시스템__ : 운영체제 + 그 위에서 동작하는 모든 애플리케이션 통틀음    \r\n\r\n__커널__ : (a.k.a 관리자supervisor, 코어core, 내부internals) \r\n - 인터럽트 핸들러, 스케줄러, 메모리 관리 시스템, 네트워크나 프로세스간 통신 처리하는 시스템 서비스 등     \r\n \r\n***\r\n \r\n__커널 공간__kernel-space : 보호 메모리 공간 사용, 제약 없는 하드웨어 접근 등이 가능  \r\n과  \r\n__사용자 공간__user-space :\r\n - 사용자 애플리케이션 실행됨/ 장비의 가용 자원 중 일부만 사용 가능 \r\n - 특정 시스템 함수 실행 가능, 하드웨어 직접 접근 및 커널이 할당한 영역 밖에 메모리 접근은 잘못된 동작  \r\n\r\n은 다른 (시스템)상태를 가짐     \r\n \r\n***\r\n\r\n\r\n커널 코드 실행 시 시스템은 커널 모드로 커널 공간에 있음  \r\n일반적인 프로세스 처리 시 시스템은 사용자 모드로 사용자 공간에 있음  \r\n\r\n실행 애플리케이션은 시스템 호출을 통해 커널과 통신  \r\n주로) 애플리케이션이 라이브러리 함수 호출 => 라이브러리가 시스템 호출 인터페이스 이용 커널이 애플리케이션을 대신해 필요한 작업 수행\r\n\r\n일부 라이브러리 호출은 시스템 호출에는 없는 여러 기능 제공하기도 함, 이 경우 커널 호출은 커다란 함수의 일부 한 단계가 됨     \r\n\r\n\r\nex) printf() : 데이터 출력 형식 지정 or 버퍼링 기능\r\n - 화면에 데이터 출력하기 위해 write() 시스템 호출 이용하는 것은 이 함수의 일부분\r\n\r\n일부 라이브러리 호출은 커널 호출과 일대일 대응\r\n\r\n한편, strcpy() 같은 C 라이브러리 함수는 커널 호출을 직접 사용하지 않음     \r\n\r\n\r\n\r\n* 애플리케이션이 시스템 호출을 실행하는 것을 애플리케이션을 대신에 커널이 실행 중이라고 표현\r\n* 또는 (= 애플리케이션이 커널 공간에서 시스템 호출을 실행 중 = 커널이 프로세스 컨텍스트를 실행 중)\r\n \r\n애플리케이션이 시스템 호출을 통해 커널을 이용하는 방식이 애플리케이션의 작업 수행의 기초적인 방식     \r\n\r\n***\r\n \r\n__커널은 시스템 하드웨어도 관리__ : 인터럽트 개념  \r\n__인터럽트__ : 종류는 숫자로 구분, 커널은 숫자로 인터럽트 처리, 응담할 인터럽트 핸들러 실행  \r\n - 커널이 동기화를 위해 새로운 인터럽트 블락 가능(모든 인터럽트 다 or 특정 인터럽트만)  \r\n - 리눅스 포함 대다수 운영체제 인터럽트 핸들러를 프로세스 컨텍스트에서 실행 안함  \r\n - 대신 프로세스와 분리되어 있는 별도의 인터럽트(전용) 컨텍스트에서 실행      \r\n \r\n \r\n \r\n컨텍스트는 커널의 활동 범주 나타냄  \r\n리눅스에서 프로세스는 세가지 중 한가지 일 하는 중\r\n - 사용자 공간에서 프로세스의 사용자 코드를 실행\r\n - 커널 공간의 프로세스 컨텍스트에서 특정 프로세스를 대신해 코드를 실행\r\n - 커널 공간의 인터럽트 컨텍스트에서 프로세스와 상관없이 인터럽트를 처리\r\n ex) 시스템 유휴상태 = 커널이 커널 모드의 프로세스 컨텍스트에서 idle 프로세스 실행     \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널과 전통적인 유닉스 커널\r\n\r\n* __리눅스는 유닉스와 유사, but 유닉스 아님__ : 유닉스 API(POSIX가 제정한 유일한 유닉스 표준) 구현하고 있지만 소스 물려받지 않음     \r\n\r\n\r\n\r\n리눅스에 __MMU__메모리 관리 장치 필요, 특펼히 없는 버전은 아주 작은 임베디드 시스템용  \r\n\r\n__유닉스 커널__ : 모놀리딕monolithic의 정적 바이너리  \r\n__리눅스 커널__ : 모놀리딕monolithic 커널이지만 마이크로 커널의 장점 수용\r\n - 모듈화 설계, 커널 선점(커널이 자신을 선점), 커널 스레드 지원, 별도의 바이너리(커널 모듈)를 커널 이미지에 동적으로 로드\r\n - 모든 작업은 커널 모드에서 실행, 통신 방식으로 X메세지 전달, O직접 함수 호출     \r\n \r\n*** \r\n \r\n__리눅스 커널 기준 전통적인 유닉스 시스템의 주요 차이점__\r\n - 커널 모듈 동적 로딩, 모노리딕 형식이지만 필요에 따라 동적으로 커널 코드 로드, 제거\r\n - 대칭형 멀티프로세서SMP 지원\r\n - 선점형 : 커널 내부에서 실행 중인 작업도 선점 가능\r\n - 독특한 방식으로 스레드 지원 : 정상 프로세스와 스레드 구분 안함/ 커널 입장에서 동등, but 자원 공유하는 프로세스들이 존재\r\n - 디바이스 클래스, 핫플러그 이벤트, 사용자 공간 디바이스 파일시스템sysfs => 객체지향적인 장치 모델 지원     \r\n \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널 버전\r\n\r\n(주버전).(부버전).(개정판).(안정 버전 일련번호)  \r\n부버전 짝수가 안정 커널\r\n \r\n \r\n\r\n","fields":{"slug":"/리눅스 커널 (1) - 리눅스 커널 입문/"},"frontmatter":{"title":"리눅스 커널 (1) - 리눅스 커널 입문","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}