{"componentChunkName":"component---src-pages-search-js","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n\n- IT = Information Technology = 정보 기술\n    - + 보안!\n\n- 정보화 ← DB 서버 ← Service Provider가 조회\n    - 보안 ← 기술\n        - 기밀성 : 암호화\n        - 무결성 : 인증\n        - 가용성 : 웹, 모바일\n\n- **Gartner** : 리서치, 정보 기술 연구 및 자문 회사\n    - **Gartner Hype-Cycle**\n        - 다섯 개의 단계로 구분\n            - 기술촉발 Technology Trigger\n            - 기대 거품의 정점 The Peak of Inflated Expectations\n            - 환멸의 계곡 Trough of Disillusionment\n            - 깨우침의 단계 Slope of Enlightenment\n            - 생산성의 안정기 Plateau of Productivity\n        - Emerging Tech를 표현\n    - 매년 말 Top10 기술 선정\n\n- Device Mesh : IoT 망 등을 의미\n\n- Ambient User Experience : 반응형 웹 등 유저 친화적 경험\n\n- IoE (Internet of Everything)\n\n- Adaptive Security Architecture : 적응형 보안 구조 ← 지능형 기술 접목\n    - → Contiues Adaptive Risk and Trust Assessment\n        - → Digital Ethics and Privacy\n            - Privacy → Transparency and Traceability\n\n- Intelligent Things → Autonomous Things(AuT)\n\n- Intelligent Apps and Analytics → Augmented Analytics\n\n- Conversation System → Conversational Platforms\n    - e.g. 큰틀에서의 E-mail과 챗봇 등 해당\n    - 실시간 대화형 플랫폼 기술 (e.g. AI 스피커)로 주목받음\n\n- Digital Twins : 디지털 트윈(digital twin)은 미국 제너럴 일렉영(GE)이 주창한 개념으로, 컴퓨터에 현실 속 사물의 쌍둥이를 만들고, 현실에서 발생할 수 있는 상황을 컴퓨터로 시뮬레이션함으로써 결과를 미리 예측하는 기술이다. : [https://ko.wikipedia.org/wiki/디지털_트윈](https://ko.wikipedia.org/wiki/%EB%94%94%EC%A7%80%ED%84%B8_%ED%8A%B8%EC%9C%88)\n\n- Cloud to the Edge (Computing) → Empowered Edge\n    - Edge : 중앙 서버와 같이 데이터 센터 보유\n\n- Multiexperience ← Immersive Experience  ← Virtual & Augmented Reality ← Ambient User Experience\n    - 성숙 과정\n\n- Distributed Ledgers → Blockchain → Practical Blockchain\n\n- Event-Driven ← MASA: Mesh App and Service Architecture ← Mesh app, Iot arch\n\n- 보안 패러다임 변화\n    - 이전 : 데이터 ← 기밀성, 무결성, 가용성\n    - 최근 :  사람, 환경 ← 프라이버시, 안전성, 신뢰성\n\n- Quantum Computing\n    - 폰노이만 아키텍처를 탈피함\n\n- 멀티클라우드 : 여러 벤더가 제공하는 동일한 유형(퍼블릭 또는 프라이빗)의 클라우드를 여러개 배포\n- 하이브리드 클라우드 : 여러 배포 유형(퍼블릭 또는 프라이빗)이 있고 이들 사이에 통합 또는 오케스트레이션을 특정 방식으로 수행\n\n- Democratization of Enterprise : 민주화됨을 의미\n\n- Human Augmentation : 로봇 등으로 인간 증강함 e.g. '엣지 오브 투모로우'의 엑소슈트\n\n- Distributed Cloud\n\n- AI Security\n\n- RPA(로보틱 처리 자동화), Hyperautomation","fields":{"slug":"/Gartner Top10 Technology til 2020/"},"frontmatter":{"title":"Gartner Top10 Technology til 2020","published":true}}},{"node":{"rawMarkdownBody":"\n\n- **Risk** vs **Issue**\n    - risk는 예상(잠재)\n    - issue는 현재 일어난 것\n\n- **Methodology**(방법론) : Method + Knowledge\n\n- DDD(Domain Driven Design) : 도메인 주도 설계\n\n\n\n- 보안 컨설턴트의 요구 역량\n    - 경영진의 마인드, 경영의 흐름 읽기\n    - 보안 기술적인 측면\n    - 문제점과 현 상황 판단 능력, 분석력\n    - 문서 작성 능력\n    - PT(presentation) 능력\n    - 기밀 유지를 위한 '윤리의식'\n        - 보안 컨설턴트는 사내 민감 정보를 많이 파악하게 된다.\n    - 커뮤니케이션 능력\n    - 보안 공격에 대한 방어 능력\n    - 융합보안 트렌드 이해\n    - 자기 감정 조절 능력\n\n- People + Process + Technology 를 통한 보안 컨설팅\n\n- 마스킹 : 법률상 필수는 아니나 권고 사항이므로 불이익을 피하기 위해 대부분 기업들은 이름, 전화번호, 이메일 등을 마스킹함\n    - 마스킹 시 데이터의 특징을 분석해야 함\n\n- 경영진은 숫자로 이야기하고 대안을 제시하는 직원을 원한다.\n\n- 인증\n    - ISO 27001 : 국제 비즈니스 시 필요\n    - ISMS : 국내 기업 대상, ISO 27001 인증 받으면 수수료 감면됨\n    - ISMS-P : 개인정보보호 관리체계가 포함됨\n\n- 벌금, 과태료, 과징금의 차이\n    - 벌금은 사법상의 형벌(경미할 경우 과료)\n    - 과태료는 행정상의 처분\n    - 과징금은 행정상 처분이나 부당 이익의 환수조치 측면\n\n- 취약점, 위협, 위험의 차이\n    - 취약점은 고장난 문\n    - 위협은 도둑\n    - 위험은 손실된 자산","fields":{"slug":"/보안컨설팅과 보안 컨설턴트의 역량/"},"frontmatter":{"title":"보안컨설팅과 보안 컨설턴트의 역량","published":true}}},{"node":{"rawMarkdownBody":"\n- 개인정보인 것(단독으로 또는 다른 정보와 쉽게 조합하여 특정 개인(살아있는)을 식별할 수 있는 것)\n    - 휴대전화번호 뒤 4자리\n    - 컴퓨터 IP주소(단독으로도 개인정보가 될 수 있다!)\n    - 차량번호(법인차량이면 아닐 수도)\n    - 회사에서 부여한 사번\n\n- 개인정보가 아닌 것\n    - 돌아가신 할아버지의 주민등록번호\n    - 대표이사 또는 대표자의 성명(대표자이기 때문, 직원 이름은 개인정보다!)\n\n- [개인정보 보호법] 제2조(정의) ← 개인정보의 법률적 의미\n    - [http://www.law.go.kr/법령/개인정보보호법/(14839,20170726)](http://www.law.go.kr/%EB%B2%95%EB%A0%B9/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%B2%95/(14839,20170726))\n\n- **가명정보**는 개인정보다!\n    - 가명정보 : ~~에 따라 가명처리함으로써 원래의 상태로 복원하기 위한 추가 정보의 사용, 결합 없이는 특정 개인을 알아볼 수 없는 정보\n        - 즉 추가 정보의 사용, 결합으로 특정 개인 식별 가능\n\n- **개인정보 수집 시 알리고 동의 받아**야하는 것\n    - 개인정보의 수집 및 이용 목적\n    - 수집하려는 개인정보의 항목\n    - 개인정보의 보유 및 이용 기간\n    - 동의를 거부할 권리가 있다는 사실 및 동의 거부에 따른 불이익이 있는 경우에는 그 불이익의 내용\n\n- 민감정보 : ① 사상•신념, ② 노동조합•정당의 가입•탈퇴, ③ 정치적 견해, ④ 건강, 성생활 등에 관한 정보, ⑤ 그 밖에 정보주체의 사생활을 현저히 침해할 우려가 있는 개인정보\n\n- **민감정보, 고유식별번호**는 별도 동의를 받고 수집 가능\n- **주민등록번호**는 주체의 별도 동의가 있어도 수집 불가\n    - 법령에 의해서만 수집 가능\n- **중요한 내용은 명확히** 표시해야 함\n    - e.g. 민감정보, 고유식별번호, 불이익의 내용 등을 밑줄, 볼드체 표시\n\n- 개인정보처리자는 보유기간 경과, 개인정보의 처리 목적 달성 등 그 개인정보가 불필요하게 되었을 때에는 지체 없이 **5(영업)일** 이내, 그 개인정보를 파기하여야 한다.\n- 정보통신서비스 제공자 등은 정보통신서비스를 **1년**의 기간 동안 이용 안할 경우 이용자의 개인정보를 기간 만료 **30일** 전까지 개인정보가 파기되는 사실, 기간 만료일 및 파기되는 개인정보 항목 등을 이용자에게 알려야 한다.\n    - 1년 미이용 고객 정보는 파기 혹은 파기에 준하는 별도 분리보관해야 한다.\n    - ID 정도는 남겨놓을 수 있다!\n        - 계정복구를 위해 최소한의 정보만 가능! ← 타당하고 사업자가 입증 가능해야 함\n\n- **개인정보 업무위탁** vs **제3자 제공**\n    - 위탁 시 수탁사에 대해 위탁사가 관리감독하고 책임지도록 되어있음\n        - 법적으로 방문해야하는 것은 아니지만 보통 방문점검함\n    - 위탁자의 업무를 위한 처리가 업무위탁, 제3자의 이익을 위한 처리 시 제3자 제공\n    - 위탁 시에는 동의 받을 필요 없음, 제3자 제공은 제공에 대한 정보 주체의 동의 필요\n\n- [개인정보 보호법]보다 [정보통신망법],[신용정보의 이용 및 보호에 관한 법률]이 우선함\n\n- 병원 내원 환자들에 대해서도 개인정보 수집 동의없이 개인정보 수집 가능 : [의료법]에 명시된 항목\n\n- 영상정보처리기기 설치 및 운영안내에 대한 안내판 설치는 잘 보이는 곳 한 곳(몇 곳)에 붙여도 된다.\n\n- 내부 직원에 대한 교육을 외부 업체에 위탁 시 위탁에 대한 동의를 직원들에게 받을 필요는 없지만 고지는 해야 한다.\n\n- 건물출입시에 출입증 교부를 위해 주민등록증을 받아 보관 시 정보주체로부터 개인정보 및 고유식별정보 수집 동의서 받지 않아도 된다.\n\n- 기업에서 지원자들로부터 입사지원서를 접수받을 때 개인정보 수집, 이용 동의서를 받을 필요 없다.\n    - 관행적으로 동의서를 받기는 한다.\n\n- 개인정보처리자는 비밀번호가 복호화되지 않게  반드시 일방향 암호화하여 저장해야 한다.\n\n- 쇼핑몰 비회원 주문의 경우 성명, 배송지주소 및 연락처, 비밀번호 등 간략한 정보만 수집하더라도 개인정보 안전성 조치 취해야 함\n\n- 콜센터 고객 상담 시 자동으로 통화내용 녹취 시 고객에게 고지하지 않아도 됨\n    - 대화 참여자의 녹취는 합법이다!\n    - 관행적으로 고지하긴 한다.\n\n- 1년 미이용 고객의 개인정보를 별도 분리보관 한 경우, 대상 정보를 통계 등의 목적으로 이용 불가하다.\n    - 별도 분리보관은 파기에 준하는 조치로 특별한 규정이 있는 경우 제외하고 제3자 제공 불가\n    - 하지만 별도 분리보관 전 개인을 식별할 수 없는 상태에서 통계정보를 얻어 보관하는 것은 가능하다.\n\n- 국가법령정보센터\n    - [www.law.go.kr](http://www.law.go.kr)\n- 개인정보보호 종합포털\n    - [www.privacy.go.kr](http://www.privacy.go.kr)\n- ISMS-P 인증 기준 안내서\n\n- 개인정보 유출 : 개인정보처리자가 통제를 상실 또는 권한 없는 자의 접근을 허용할 경우 모두 해당\n    - 해커가 침투해서 빼간 경우\n    - 개인정보가 들어있는 USB를 분실한 경우\n\n- 회사 고객의 개인정보 유출 시\n    - 법에 의한 처벌 - 벌금 최대 5,000만원\n    - 소송에 의한 배상 - 손해배상금 + 소송 비용\n    - 유무형 손실 - 매출 감소, 이미지 손실\n\n- 개인정보의 안정성 확보 조치 기준 ← 개인정보보호법\n    - 제5조(접근 권한의 관리) : ~~에 의한 권한 부여, 변경 또는 말소에 대한 내역을 기록하고, 그 기록을 최소 **3년간** 보관하여야 한다.\n    - 제6조(접근통제) : 개인정보 처리자는 개인정보취급자가 정보통신망을 통해 외부에서 개인정보처리시스템에 접속하려는 경우 가상사설망 또는 전용선 등 **안전한 접속 수단을 적용하거나 안전한 인증수단을 적용**하여야 한다.\n        - sms, 2차 비밀번호, IP접근제한, 문자인증, OTP 등이 안전한 인증수단\n            - 비용이 많이 들어서 안하는 회사가 많다.\n\n    - 제7조(개인정보의 암호화)\n        - **비밀번호 및 바이오 정보 암호화**해야 한다.\n        - **비밀정보를 저장하는 경우에는 복호화되지 아니하도록 일방향 암호화하여 저장**\n        - **고유식별정보를 저장하는 경우에는 이를 암호화**\n        - 개인정보보호법 상에서는 이름, 전화번호, 주소 등은 암호화 의무 없음\n    - 제8조(접속기록의 보관 및 점검)\n        - 개인정보처리자는 개인정보취급자가 개인정보처리시스템에 접속한 기록 **1년 이상** 보관,관리 해야 한다.\n            - 접속한 (일시, ip, 계정, 행위, 주체 정보) 5가지\n        - 고유식별정보 또는 민감정보는 **2년 이상** 보관, 관리 해야 한다.\n        - 개인정보처리자는 개인정보의 오,남용, 분실, 도난, 유출, 위조, 변조 또는 훼손 등에 대응하기 위하여 개인정보처리시스템의 접속기록 등을 **월 1회** 이상 점검해야 한다.\n            - **특히 개인정보를 다운로드한 것이 발견되었을 경우에는 내부관리 계획으로 정하는 바에 따라 그 사유를 반드시 확인하여야 한다.**\n        - **개인정보처리자는 개인정보취급자의 접속기록이 위,변조 및 도난, 분실되지 않도록 해당 사유를 반드시 확인하여야 한다.**\n        - 개인정보처리자는 개인정보취급자의 접속기록이 위,변조 및 도난, 분실되지 않도록 해당 **접속기록을 안전하게 보관**하여야 한다.\n\n    - 개인정보의 기술적,관리적 보호조치 기준 ← 정보통신망법\n        - 제4조(접근통제)\n            - 정보통신서비스 제공자들은 ~~에 의한 권한 부여, 변경 또는 말소에 대한 내역을 기록하고, 그 기록을 최소 **5년** 간 보관한다.\n            - ~~제공자들은 ~~정보통신망을 통해 외부에서 개인정보처리시스템에 접속이 필요한 경우 안전한 인증 수단 적용해야 한다.\n            - 전년도 말 기준 직전 3개월간 그 개인정보가 저장,관리되고 있는 이용자 수가 일일평균 100만명 이상이거나 정보통신서비스 부문 전년도(법인인 경우에는 전 사업연도 의미) 매출액 100억원 이상인 정보통신서비스 제공자등은 개인정보처리시스템에서 **개인정보를 다운로드 또는 파기할 수 있거나 개인정보시스템에 대한 접근권한을 설정**할 수 있는 개인정보취급자의 컴퓨터 등을 **물리적  또는 논리적으로 망분리** 하여야 한다.\n            - 정보통신서비스 제공자등은 개인정보취급자를 대상으로 다음 각 호의 사항을 포함하는 비밀번호 작성규칙을 수립하고, 이를 적용 운용하여야 한다.\n                - **영문, 숫자, 특수문자 중 2종류 이상을 조합하여 최소 10자리 이상 또는 3종류 이상을 조합하여 최소 8자리 이상의 길이로 구성**\n                - **연속적인 숫자나 생일, 전화번호 등 추측하기 쉬운 개인정보 및 아이디와 비슷한 비밀번호는 사용하지 않는 것을 *권고***\n                - **비밀번호에 유효기간을 설정하여 *반기별* 1회 이상 변경**\n        - 제5조(접속기록의 위,변조방지)\n            - 정보통신서비스 제공자들은 개인정보취급자가 개인정보처리시스템에 접속한 기록을 **월 1회 이상** 정기적으로 확인,감독하여야 하며, 시스템 이상 유무의 확인 등을 위해 **최소 1년 이상** 접속기록을 보존,관리하여야 한다.\n            - ~~제공자들은 ~~취급자의 접속기록이 위,변조되지 않도록 별도의 물리적인 저장 장치에 보관하여야 하며 정기적인 백업을 수행하여야 한다.\n        - 제6조(개인정보의 암호화)\n            - 정보통신서비스 제공자들은 비밀번호는 복호화되지 아니하도록 일방향 암호화하여 저장한다.\n            - ~~제공자들은 다음 각 호의 정보에 대해서는 안전한 암호 알고리듬으로 암호화하여 저장한다. (비밀번호, 바이오정보는 일방향 암호화이며, 나머지는 양방향 암호화)\n                - **주민등록번호**\n                - **여권번호**\n                - **운전면허번호**\n                - **외국인등록번호**\n                - **신용카드번호**\n                - **계좌번호**\n                - **바이오정보**\n            - 정보통신서비스 제공자들은 정보통신망을 통해 **이용자의 개인정보 및 인증정보**를 송,수신할 때에는 안전한 보안서버 구축 등의 조치를 통해 이를 암호화해야 한다.","fields":{"slug":"/개인정보 개념 및 개인정보 보호 관련 법규/"},"frontmatter":{"title":"개인정보 개념 및 개인정보 보호 관련 법규","published":true}}},{"node":{"rawMarkdownBody":"\n- 디지털 트랜스포메이션 : e.g. 코로나 언택트 시대 온라인 강의\n\n- 4차 산업혁명의 정의\n    - 디지털, 물리적, 생물학적 영역의 경계가 없어지면서 기술이 융합되는 인류가 한번도 경험하지 못한 새로운 세계\n    - 제조기술 뿐만 아니라 데이터, 현대 사회 전반의 자동화 등의 총칭 Cyber-Physical System(**CPS)**과 Iot, 인터넷 서비스 등의 모든 개념 포괄\n    - 3개 세상의 융합이 만드는 산업혁명 : [현실+가상+인간]세계\n\n- 4차 산업혁명 3가지 특징\n    - 초연결성(IoT진화)\n    - 초지능화(AI, 빅데이터)\n    - 초융합(산업영역과 경계융합)\n\n- 4차 산업혁명의 데이터의 대부분은 비정형 혹은 반정형 데이터\n    - 비정형 데이터 : 텍스트, 이미지, 영상 등\n    - 반정형 데이터 : html, xml 등\n    - 3차 산업혁명까지는 정형 데이터 활용\n\n- 4차 산업 혁명은 소프트 파워 바탕\n    - 하드 파워 : 자원 → 생산품\n    - 소프트 파워  : 상상아이디어 → 혁신적 서비스\n\n- 우리나라는 디지털 뉴딜을 추진 중\n\n- IoT 기술\n    - 초광대역 (Ultra-wideband, UWB)\n    - Bluetooth Low Energy(BLE)\n    - 지그비는 IEEE 802.15.4-2003을 기반으로 한 작고, 저전력의 디지털 라디오를 사용하는 하이레벨 통신 프로토콜\n\n- 3V + 1V (빅데이터)\n    - volume, variety, velocity + value","fields":{"slug":"/제4차 산업혁명의 정의와 특징/"},"frontmatter":{"title":"제4차 산업혁명의 정의와 특징","published":true}}},{"node":{"rawMarkdownBody":"\n- 웹서버 데몬 : 아파치 등\n\n- 로깅 시 풀 패킷 저장하지 않음\n    - 보안 룰 등에 맞춰 일부만 저장\n\n- 네트워크에서 로깅을 할 경우 상위계층 정보는 열어볼 수 없어 알 수 없음\n    - e.g. 방화벽은 port주소까지 볼 수 있지만 응용 계층 정보를 볼 수 없음\n\n- 해커 컴퓨터 압수 시\n    - 웹 브라우저 로그 확인(시크릿 모드 시 할 수 있는 것 없음)\n    - 피들러 등 도구 사용(도구 기록 확인, 기록 저장 안되있을 시 할 수 있는 것 없음)\n    - 직접 작성한 스크립트 사용(소스와 유저가 남긴 로그 없을 시 할 수 있는 것 없음)\n\n- Fiddler : 웹 디버그 툴\n\n- 방화벽 분석은 해커 IP, Port와 접속 시간만 알 수 있음\n    - 웹 방화벽(WAF, Web Application Firewall)은 http(s) 패킷만 로깅\n    - 알 수 있는 정보가 별로 없다.\n\n- IDS/IPS (L4 이상 주로 L7)\n    - 모든 프로토콜(TCP/IP) 패킷 데이터 확인(웹 방화벽 로깅의 상위 호환)\n    - IDS는 차단하지 않기 때문에 강경한 정책 적용 가능\n    - IPS는 차단 시 가용성에 문제\n    - 최근 AI 도입 추세\n\n- 로깅은 룰 위반 시에만 일어나기 때문에 룰 우회 시 로그 안 생김\n\n- UTM(Unified Threat Management) : 통합위협관리\n\n- http 대신 https 사용 시 공격이 성공하는 경우\n    - IPS가 고객으로부터 SSL 복호화 키를 제공받지 못한 경우(보안 정책을 우회)\n    - SSL 복호화 키를 받을 수도 있고, 키 제공을 꺼리는 고객도 있다.\n\n- 보안 업체는 IDS/IPS 룰셋에 많은 자원(인력)을 투자함\n    - 고객 요구 사항에 맞춰(발생하는 공격에 대응하여 지속적인) 룰셋 추가/수정\n    - 룰 셋을 만드는 것이 업체의 실력의 척도\n\n- 모든 사이버 공격들이 사이버킬체인 7단계의 모든 단계를 수행하지는 않음\n\n- '/bin/sh'  문자열의 정규표현식 탐지 시 사용자가 예를들어 '/bin/sh' 문자열 포함한  게시글을 작성하면 오탐이 발생\n    - 쉘 코드 아니어도 탐지하기 때문\n\n- AI의 IDS/IPS의 적용은 상업적 목적이 크다.\n    - 사업상 새로운 제품 개발 필요성\n\n- Supervised AI IDS/IPS의 경우 데이터 라벨링과 데이터 확보가 중요함\n    - 자체 또는 원격 보안 관제 시스템의 로그를 보고 공격인지 구분\n    - ids에 남은 로그는 ids/ips에 남은 로그 전제에 기반하기 때문에 전제에 부합해야 로깅됨\n    - IDS와 AI IPS의 제작 업체가 다른 경우 AI의 학습이 자사 IDS 로그 기반이기 때문에 성능이 안좋다.\n    - 결론적으로 AI가 잘 적용 안되고 탐지가 잘 안된다.\n    - 업체에서 정오탐 판별만 AI를 활용하는 추세\n\n- Unsupervised AI IDS/IPS\n    - 세션 수(어느 소스에서 목적지로 몇개의 패킷이 전달됬는지, 패킷 크기 등)를 탐지\n    - Anomaly Detection : 공격 패턴을 학습하지 않고, 정상적 상황을 학습하여 이상한 상태를 탐지\n    - 장비 구입 바로 사용하지 못하고 2~3달 간정상 상태를 학습하고서 사용할 수 있음(고객에 맞춰 학습해야되기 때문)\n\n- BMT(Benchmark Test)","fields":{"slug":"/해킹 공격과 포렌식/"},"frontmatter":{"title":"해킹 공격과 포렌식","published":true}}},{"node":{"rawMarkdownBody":"\n\n- Digital Forensics and Incident Response\n    - [https://zeltser.com/digital-forensics-and-incident-response-disciplines/](https://zeltser.com/digital-forensics-and-incident-response-disciplines/)\n\n- Global Cybersecurity Camp : [https://www.div0.sg/gcc](https://www.div0.sg/gcc), [https://www.horangi.com/blog/horangi-and-global-cybersecurity-camp-gcc-empower](https://www.horangi.com/blog/horangi-and-global-cybersecurity-camp-gcc-empower)\n\n- **Shotgun Forensics**\n\t- “Old school”\n\t- Image everything\n\t- Reliance on tools – autopilot\n\t- Pull the plug\n\n- **Sniper Forensics**\n    - The process of taking a targeted, deliberate approach to\n    forensic investigations\n\n     ****\n\n- **SOC2 Compliance** (compliance like iso 27001)\n\n- Tools and Samples\n    - Fast IR\n    - Yara\n    - Open IOC(Indicators of Compromise, 침해지표)\n\n- Cloud floyd is the deep learning platform : [https://www.floydhub.com/](https://www.floydhub.com/)\n\n- **CISO**(Chief Information Security Officer) : 최고정보보호책임자\n\n- Open source projects (e.g. androguard)\n\n- Security Monitoring\n    - SIEM(Security information and event management)\n    - EDR(Endpoint Detection & Response)\n    - SOC(Security Operation Center)\n\n- 컴퓨터 비상 대응팀(computer emergency response team, CERT)\n\n- CSIRT, Computer Security Incident Response Team : 컴퓨터 보안사고 대응팀\n    - Red team : focused on penetration testing of different systems and their levels of security programs.\n    - Blue team : it also assesses network security and identifies any possible vulnerabilities. (지속적인 특성)\n\n- CERT vs. CSIRT vs. SOC: A look at the similarities, differences\n    - [https://searchsecurity.techtarget.com/tip/CERT-vs-CSIRT-vs-SOC-Whats-the-difference](https://searchsecurity.techtarget.com/tip/CERT-vs-CSIRT-vs-SOC-Whats-the-difference)","fields":{"slug":"/DFIR and Cyber Risk Leaders/"},"frontmatter":{"title":"DFIR and Cyber Risk Leaders","published":true}}},{"node":{"rawMarkdownBody":"\n- 조사와 수사는 강제성의 차이\n\n- 증거 능력 요건 중 분석가의 전문성에 대한 요건 있음\n\n- 정보보안의 추적 및 기소 방식에 디지털포렌식이 활용됨.\n\n- e-디스커버리 : [https://ko.wikipedia.org/wiki/전자_디스커버리](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%9E%90_%EB%94%94%EC%8A%A4%EC%BB%A4%EB%B2%84%EB%A6%AC) (민사 소송)\n    - hero(디지털포렌식 전문가를 일컬음) sheet 작성\n\n- 어원 forum에서 forensic이 발생됨.\n\n- 디지털포렌식: **법적 목적으로 사용을 위한 디지털 증거 분석과 관련된 컴퓨터 과학 및 법적(수사) 절차의 적용**\n    - 디지털포렌식은 증거 사용을 위해 법정까지 증거를 가져다놓는 절차의 적용\n\n- 데이터 복구와 디스크 포렌식의 차이\n    - 디스크 포렌식 안에 데이터 복구라는 기술이 포함됨\n\n- **디지털포렌식의 일반원칙**\n    - **정당성(Legitimacy)의 원칙** : 위법수집증거배제법칙(형사소송법에 명시), 독수독과론\n        - df에서 자료수집(data collection)이 가장 중요한 단계\n        - 증거능력(유무)과 증명력(강약)(weight)의 구분\n    - **무결성(Integrity)의 원칙** : **증거가 최초 수집된 이후** 법정에 제출될 때까지 변경이나 훼손 없이 보호되어야 한다. 디지털 증거는 위*변조가 쉽고, 위*변조 탐지가 어려운 특징\n        - 이미징 : 저장매체 물리적 데이터 (*.dd, *.ewf 등 )파일로 이미지 파일 내부 편집 불가 특징\n        - 해시 함수 : 일방향 함수로 입력 데이터 변경되지 않음을 입증\n            - 현재 법정에서 md5 사용 : md5의 안전성은 깨졌지만 단기간내 위조는 어렵다고 여겨짐\n    - **연계보관성(Chain of Custody, CoC)의 원칙** : 보관의 사슬이라는 뜻, 일련의 과정 및 과정 마다의 담당자, 증거 상태가 명확해야 한다는 원칙\n        - **실제로는 무결성과 관련 없지만**(디지털 증거의 경우 Hash가 존재하기 때문에 CoC 문서의 연계보관성의 무결성에는 관계가 없다,하지만 전원 인가 시 트림 등 무결성 침해 요소 있을때에는 필요)**,** 유체물 증거를 담당자가 육안으로 상태 확인하여 무결성 확인한다는 점에서 **무결성과 밀접한 관계가 있다고 답해야 한다.**\n        - 증거 능력이 없는 경우에도 (e.g. 해시 값이 변경될 수 있는 상황이 있어도) 판결 시 증거 채택될 수 있음(자유 심증 주의)\n        - 연계보관성은 증거의 하자의 치유, 하자의 보수에 있어서 중요함\n    - **재현성(Reproducibility)의 원칙** :  동일한 조건과 동일한 상황에서의 디지털포렌식 분석은 항상 같은 결과를 도출해야 함, 분석 도구 및 방법, 분석자의 신뢰성(Reliability) 검증을 위한 방법으로 사용\n        - NIST의 CFTT를 통해 도구의 신뢰성 검증 가능\n\n    - **신뢰성(Immediacy)의 원칙** :  디지털포렌식 수행의 전 과정은 지체없이 신속하게 수행되어야 한다.\n        - 변하기 쉬운 데이터에 대응, 피해에 빠른 대응\n\n- 디지털포렌식 전문가 : 학회에서 능력을 인정하는 경우 인정됨\n    - 침해사고, 악성코드, 컴퓨터, 네트워크, 포렌식전문가 등\n\n- 회계법인의 디지털포렌식(3~4달 소요)\n    - 외부감사인이 부정 징후를 발견한 것을 회사가 외부전문가 고용, 외부전문가가 감사하고 그것을 감사인측 전문가가 다시 감사\n        - Positive Assurance\n        - Negative Assurance : 지금까지는 문제가 없다고 감사\n\n- De-NIST : 화이트리스트에 들어있는 파일 제외\n- De-Dup : 중복 파일 제외\n- Scope Limitation : 스코프 제한","fields":{"slug":"/수사 및 조사와 포렌식/"},"frontmatter":{"title":"수사 및 조사와 포렌식","published":true}}},{"node":{"rawMarkdownBody":"\n슬라이드 자료 : [https://github.com/proneer/Slides](https://github.com/proneer/Slides)\n\n- 디지털 데이터\n    - 파일시스템\n    - 로그 : 정형적 산물\n    - 아티팩트 : 경험적 산물, 절대적 지표가 아니므로 재현을 하여 입증\n\n- 사실 관계 규명\n    - 타임라인 분석\n    - 연관 분석\n\n- 증거가 제출되면 민사, 형사 경우 모두 기본적으로 상대측이 부동의하지 않으면 증거능력 가짐\n\n- 아이폰의 경우 brute-force로 암호 해제하여 분석\n\n- 포렌식 수사 시 압수 수색에서 선별하여 분석(시간 많이 소요)\n\n- **SANS**DFIR : df 교육기관\n\n- 디지털 포렌식 학습\n    - 자주 접하는 파일시스템 우선 학습\n    - 세부 데이터 구조 이해 → 큰 그림의 이해\n\n- BitLocker : brute-force 거의 불가\n\n- THIS WEEK IN 4N6 : 포렌식 뉴스 사이트\n\n- 실제 로그 분석 시 CentOS 많이 사용","fields":{"slug":"/디지털 포렌식의 학습/"},"frontmatter":{"title":"디지털 포렌식의 학습","published":true}}},{"node":{"rawMarkdownBody":"\n- 정보보안에는 우선순위가 필요\n    - 자산(Asset)의 가치 고려\n\n- 피싱과 파밍의 차이\n    - 파밍은 도메인 주소 조작하여 정상 주소 접속하여 공격 당함\n    - 피싱은 가짜 도메인 주소에 접속하여 공격 당함\n\n- OSINT : [https://ko.wikipedia.org/wiki/오신트](https://ko.wikipedia.org/wiki/%EC%98%A4%EC%8B%A0%ED%8A%B8)\n\n- 스피어 피싱과 APT 공격\n\n- RAT(Remote Access Trojan, Remote Administration Tool)\n\n- 랜섬웨어\n    - 가상화폐 등장으로 부각됨\n\n","fields":{"slug":"/정보 보안과 포렌식/"},"frontmatter":{"title":"정보보안과 포렌식","published":true}}},{"node":{"rawMarkdownBody":"\r\n__바이러스__ : 프로그램에 기생해서 자신의 복제를 다른 프로그램으로 확산\r\n\r\n__웜__ : 자신의 복제를 다른 컴퓨터로 확산\r\n\r\n__논리 폭탄__ : 조건 충족 시 트리거 작동함\r\n\r\n__트로이목마__ : 생각지 못한 추가 기능(악의적) 포함하는 프로그램\r\n\r\n__백도어(트랩 도어)__ : 기능에 허가받지 않은 접근 허용하는 프로그램의 변형\r\n\r\n__모바일 코드__ : 스크립트, 매크로나 다른 이동성 명령어 같은 SW, 서로 성격이 다른 많은 플랫폼으로 옮겨서 실행 가능하고 같은 기능 수행\r\n\r\n__Exploit__ : 하나 혹은 여러 개의 취약점을 노리는 코드로 공격 시 타이밍 문제 또는 반복 작업 피하기 위해 적성된 자동화된 스크립트, 프로그램을 통칭\r\n\r\n__Downloaders__ : 공격을 받는 컴퓨터에 다른 아이템을 설치하는 프로그램으로 보통 전자우편을 통해 전달됨\r\n\r\n__Dropper__ : 공격 받는 컴퓨터에 설치되어 자신 내부에 있는 데이터 이용하여 악성코드 생성\r\n\r\n__Auto-rooter__ : 악성 해킹 도구로 새로운 시스템에 원격으로 침입할 때 사용하는 툴\r\n\r\n__Kit(Virus generator)__ : 바이러스를 자동으로 생성하는 도구 모음\r\n\r\n__스패머 프로그램__ : 원하지 않는 대량의 전자우편물을 보내는 데 사용\r\n\r\n__플러더(Flooders)(Dos Client)__ : 네트워크 컴퓨터 시스템에 대량의 자료를 보내어 서비스 거부 공격을 감행하는 데 사용하는 코드\r\n\r\n__Keyloggers__ : 피해를 입은 시스템의 키 입력 갈취\r\n\r\n__Rootkit__ : 컴퓨터 시스템에 침입 후 루트 수준의 접근허락을 얻기 위해 사용하는 해커 도구모음\r\n\r\n__공격 킷(Attack kit)__ : 다양한 번식 방법과 payload 기술을 사용하는 새로운 악성코드를 자동으로 만들어 주는 툴의 모음\r\n\r\n__좀비(Zombie)__ : 감염된 컴퓨터에서 활성화되는 프로그램으로 다른 컴퓨터에 대한 공격을 시작하는 데 사용됨\r\n\r\n__스파이웨어__ : 컴퓨터에서 정보를 수집해서 다른 시스템으로 전송하는 SW\r\n\r\n__애드웨어__ : SW에 내장된 광고, 감염 시 팝업 광고가 뜨거나 브라우저가 광고 사이트로 연결함\r\n\r\n__크라임웨어__ : 온라인을 통해 불법적인 행동을 하기 위해 만들어진 프로그램\r\n\r\n__브라우저 하이재커__ : 브라우저를 하이재킹하여 홈페이지와 검색 페이지, 툴바를 통제하고 조작하는 프로그램(잘못된 주소 입력 시 해커가 만들어논 사이트로 이동시킴)\r\n\r\n__다이얼러(Dialers)__ : 모뎀이 특정 번호(1-900)로 연결되도록 하여 전화 걸 때마다 공격자가 수익 얻게 만드는 프로그램\r\n\r\n__조크__ : 실제 바이러스는 아니지만 사용자에게 심리적 위협을 주고 불안 조장하는 프로그램\r\n\r\n__Hoax__ : 남을 속이거나 장난을 목적으로 퍼트리는 가짜 바이러스로, 일반적으로 허위 바이러스 경고 메일형태","fields":{"slug":"/악성 소프트웨어 유형/"},"frontmatter":{"title":"악성 소프트웨어 유형","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n__읽기 쉬운 코드__ : 간결, 효율적, 디버깅 쉬워짐, 코드 완성도 높아짐\r\n\r\n\r\n#알고리즘 문제 풀이에서 좋은 코드 원칙\r\n\r\n__전역 변수 광범위한 사용__: 프로그램 흐름 파악에 안 좋지만,  \r\n\t\t    알고리즘 문제 풀이 시 작성 코드가 단순, 변수 사용하는 부분 파악이 명확해 잃는 것이 적음\r\n\r\n\r\n__foreach 구문 사용__: 범위 기반 for문\r\n\r\n\r\n__3항 조건 연산자 활용__\r\n\r\n__반복되는 코드를 함수나 클래스로 분리__: 알고리즘 문제 풀이에서는 활용할 경우 적음\r\n\r\n\r\n__표준 라이브러리 숙지__:  C++ STL(또는 JAVA Collection/Collections)에 이미 구현된 문자열, 동적 배열, 스택, 큐, 리스트, 사전 등 자료구조를 숙지해야 스스로 구현하는 실수 막을 수 있음\r\n\r\n\r\n__일관적이고 명료한 명명법 사용__: (e.g.) isDoSomething(int doing, int what)\r\n\r\n__같은 자료는 같은 형태로 저장__: 형태, 단위 등 하나로 통일\r\n\r\n__코드와 데이터 분리__: 월을 출력 시 숫자 대신 \"Jan\", \"Feb\" 등으로 출력,  \r\n                연산으로만 표현하는 대신 `int move_left[2] = {1, -1};`와 같이 왼쪽 이동을 배열로 저장함 \r\n\r\n\r\n\r\n#실수 주의\r\n\r\n__산술 오버플로우__\r\n\r\n__배열 밖 원소 접근__: C/C++ 컴파일러가 확인해 주지 않음(성능을 위해)\r\n\r\n__스택 오버플로우__: call stack 오버플로우로 프로그램 강제종료됨, 재귀 함수 사용 시 재귀 호출 깊이 주의, 지역 변수는 스택 메모리 사용하므로 배열을 지역 변수로 사용하면 스택 오버플로우 나기 쉬움, 전역 변수 또는 힙에 메모리 할당하는 STL 컨테이너 사용\r\n\r\n__너무 느린 입출력 방식__: C++ cin, cout 등 고수준 입출력 방식 대신 printf, scanf 사용 권장(입출력 1만개 이상일 때 권장)\r\n\r\n__변수 초기화__: 초기화 안하면 쓰레기 값 들어 있음 명심\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/알고리즘 기본 - 코딩, 디버깅/"},"frontmatter":{"title":"알고리즘 기본 - 코딩, 디버깅","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n#프로세스 스케줄러\r\n어떤 프로세스 얼마나 오랫동안 실행할지 결정  \r\n실행 중인 시스템 프로세스에 프로세서 동작 시간이라는 유한한 자원 분배  \r\n리눅스 같은 멀티태스킹 OS의 기본 요소  \r\n실행 프로세스 선택 과정을 통해, 시스템 최대 사용률 끌어내야 하고,  \r\n사용자에게 여러 개의 프로세스가 동시에 실행되는 느낌을 줘야 함\r\n\r\n원리는 간단  \r\n실행 가능한 프로세스가 있다면, 그 중 어떤 것이던 실행되야 함  \r\n프로세서 개수보다 프로세스의 개수가 많다면 특정 순간에 일부 프로세스는 실행 중 아니게 됨  \r\n이 경우 실행되기를 기다림  \r\n스케줄러가 해결할 근본적 문제는 실행 가능한 프로세스 여러 개가 있을 때 어떤 프로세스를 다음에 실행할 것인가 결정하는 것  \r\n\r\n\r\n\r\n\r\n\r\n#멀티태스킹 \r\n\r\n멀티태스킹 OS : 하나 이상의 프로세스를 동시에 중첩 형태로 실행할 수 있는 OS\r\n\r\n멀티태스킹을 통해 프로세서 하나인 시스템에서도 여러 개의 프로세스를 동시 실행하는 느낌 줄 수 있음  \r\n프로세서가 여러 개면 실제로 여러 프로세스 동시 실행 가능\r\n\r\n많은 프로세스 대기 상태 혹은 잠든 상태 될 수 있음(이 경우 메모리상에는 있지만 실행 가능한 상태 아님)  \r\n커널은 이런 프로세스를 특정 조건(인터럽트) 발생전까지 대기 상태로 둠 \r\n\r\n메모리상엔 많은 프로세스 있을 수 있지만 현대 리눅스 시스템에서 실행 중인 프로세스는 하나뿐  \r\n\r\n* 멀티태스킹 운영체제\r\n\t- 협동형 멀티태스킹__cooperative multitasking__\r\n\t- 선점형 멀티태스킹__preemptive multitasking__ : 프로세스 실행을 언제 중단하고 다른 프로세스 실행할지 스케줄러가 결정하는데 실행 중인 프로세스 강제 중지하는 작업을 선점__preemption__이라 함, 리눅스도 이것 지원함\r\n\r\n##선점형 멀티태스킹__preemptive multitasking__ \t\r\n프로세스가 선점되기 전까지 프로세스에 주어지는 시간 보통 미리 정해지고 프로세스의 타임슬라이스__timeslice__라고 함  \r\n타임슬라이스 관리하는 방식으로 전체적인 시스템 스케줄링 결정  \r\n한 프로세스가 프로세서 독점 방지  \r\n\r\n요즘 OS 시스템 정책과 프로세스 동작 관련 함수 이용 동적으로 타임슬라이스 계산  \r\n\r\n리눅스 특유 '공정__fair__' 스케줄러는 타임슬라이스 값을 그 자체로 적용 안하는 방식으로 동작  \r\n\r\n대부분 OS 선점형 멀티태스킹 지원\r\n유닉스는 태초부터 선점형 멀티태스킹 지원\r\n\r\n##협동형 멀티태스킹__cooperative multitasking__\r\n프로세스가 자발적으로 실행 중단 안하면 한 프로세스 중지 불가능  \r\n프로세스가 자발적으로 동작 중단하는 행동을 양보__yield__라고 함  \r\n이상적으로 프로세스가 자주 양보해서 실행 중인 프로세스가 충분한 프로세서 동작 시간 확보 가능하지만 OS가 이것을 강제 불가함  \r\n스케줄러가 실행 시간에 관해 전체적 결정 불가함  \r\n사용자 의도보다 더 오래 독점할 가능성 있음  \r\n양보하지 않는 큰 프로세스가 전체 시스템 먹통 만들 수 있음  \r\n\r\nMac OS 9, 윈도우 3.1과 이것들의 이전버전이 해당됨\r\n\r\n\r\n\r\n#리눅스의 프로세스 스케줄러\r\n\r\n2.5 커널에 도입된 O(1) 스케줄러 : 상수 시간 알고리즘 사용, 프로세서마다 별도의 실행 대기열__queue__ 사용으로 이전 스케줄러의 설계상 제약 제거함\r\n\r\n잘 동작하다 이후 문제 발견됨  \r\n커다란 서버 작업에는 이상적이나  \r\n응답시간에 민감한 애플리케이션인 대화형__interactive__ 프로세스가 중요한 데스크톱 시스템에서 평균 이하 성능 보임\r\n\r\n\r\n2.6 커널에 도입된 새로운 프로세스 스케줄러\r\n회전 계단식 기한__Rotating Staircase Deadline__ 스케줄러 : 공정 스케줄링 개념을 큐잉 이론에서 빌려 적용함  \r\n위로부터 영감을 받아 2.6.23 커널부터 __CFS__라고 부르는 완전 공정 스케줄러가 O(1) 스케줄러 대신하게 됨\r\n\r\n#정책\r\n\r\n정책__Policy__는 스케줄러가 무엇을 언제 실행할 것인지를 정하는 동작을 말함  \r\n스케줄러의 정책을 통해 시스템의 전체적인 느낌 정해지는 경향  \r\n프로세서 시간의 사용을 최적화하는 책임이 있어 매우 중요함\r\n\r\n\r\n##입출력중심 프로세스와 프로세서중심 프로세스\r\n\r\n* 프로세스를 두 가지로 분류 가능\r\n\t- 입출력중심 프로세스 : 입출력 요청 후 기다리는데 대부분 시간 사용, 실제 실행시간 매우 짧음, (디스크, 키보드, 네트워크 등 대기 상태 발생 가능한 모든 시스템 자원의 입출력 대상) \r\n\t- 프로세서중심 프로세스 : 대부분의 시간 코드 실행에 사용, 보통 선점될때까지 계속 실행됨, 이런 프로세스 자주 실행할수록 시스템 반응 나빠짐, 좀 더 긴시간 덜 자주 실행하는게 좋음, 많은 양 수학적 계산 실행하는 ssh-keygen, MATLAB이 예시\r\n위 분류는 상호배타적이지는 않음  \r\n동시에 두 가지 특성 가질 수 있음 (e.g. X 윈도우 서버, 워드 프로세서)\r\n\r\n\r\n시스템의 스케줄링 정책은 상충되는 두 가지 목적 달성하고자 함  \r\n프로세스 응답시간(지연시간) 빠르게, 시스템 사용률 최대화(산출물__throughput__ 극대화) \r\n\r\n유닉스 시스템 스케줄러 정책은 입출력중심 프로세스에 관대한 경향 => 빠른 프로세스 응답시간  \r\n리눅스도 대화형 작업에 쾌적한 응답시간과 데스크톱 성능 제공 목적으로 입출력중심 프로세스에 관대함 => 빠른 프로세스 응답시간  \r\n리눅스는 독창적 방식으로 이 작업 구현하여 프로세서 중심 프로세스 소홀히 하지 않음\r\n\r\n\r\n##프로세스 우선순위\r\n\r\n스케줄링 알고리즘 일반적 형태 : 우선순위 기반 스케줄링 = 가치와 필요에 따라 프로세스의 순위 매겨 프로세스 시간 할당  \r\n일반적으로 우선순위 높은 프로세스 낮은 것보다 먼저 실행, 같은 경우 순환방식__round-robin__\r\n\r\n일부 시스템은 우선순위 높은 프로세스 타임슬라이스 길게 함\r\n\r\n시스템은 물론 사용자도 프로세스 우선순위 조작 가능\r\n\r\n리눅스 커널은 두 가지 별개의 우선순위 단위 가짐\r\n1. 나이스__nice__ 값 : -20 ~ +19 사이의 값 가짐, 기본값 0\r\n\t- 클수록 우선순위 낮음(더 친절nice해짐)\r\n\t- 낮은 값 프로세스가 높은 것보다 프로세서 사용 시간 더 많이 할당받음\r\n\t- 유닉스 시스템 우선순위 표기 형식이지만 활용은 알고리즘마다 다르게 함(e.g. Mac OS X 등 유닉스 기반 OS는 nice 값으로 타임슬라이스 절대값 조절, 리눅스는 타임슬라이스 비율 조절, `$ps -el`로 시스템 ps목록과 각각의 나이스 값(NI 항목) 확인 가능)\r\n2. 실시간 우선순위 : 0 ~ 99 사이의 값, 설정으로 범위 조절 가능\r\n\t- 클수록 우선순위 높음\r\n\t- 모든 실시간 프로세스가 일반적 프로세스보다 높은값 가짐\r\n\t- 나이스 값과 별도의 값\r\n\t- 유닉스 표준 POSIX.1b에 따라 구현\r\n\t- `$ps -eo state,uid,pid,ppid,rtprio,time,comm.`의 rtprio항목으로 실시간 우선순위 확인 가능 ('-' 표시된 경우 실시간 프로세스 아님)\r\n\r\n##타임슬라이스\r\n\r\n타임슬라이스 너무 길면 시스템 대화형 성능 저하  \r\n너무 짧으면 프로세스 전환 오버헤드 커짐(프로세서중심인 경우 불리함)  \r\n입출력중심인지 프로세서중심인지 고려해야 함  \r\n\r\n많은 OS에서 기본 타임슬라이스 10ms로 설정\r\n\r\n리눅스 CFS 스케줄러 프로세스별로 프로세서 할당 비율 지정  \r\n리눅스 프로세스 시간은 시스템 부하에 따른 함수로 결정됨  \r\n이 할당값은 나이스 값에 영향 받음  \r\n나이스 값은 가중치로 비율에 영향을 줌  \r\n\r\n리눅스는 새 프로세스가 현재 실행 중인 프로세스보다 낮은 비율의 프로세서 시간 사용 시 선점하고 즉시 실행됨  \r\n그렇지 않으면 나중에 실행  \r\n\r\n\r\n\r\n##스케줄러 정책의 동작 \r\n\r\n대화형 작업에 많은 비율의 가용 프로세서 할당 : 프로세서 많이 필요하지 않지만 필요한 순간에 항상 프로세서 시간 얻기 위함, 깨어나는 순간 프로세서중심 프로세스 실행하는 프로세서 선점해야 함  \r\n=> 이렇게 해야 좋은 대화형 성능 보장 가능 \r\n\r\n많은 OS는 대화형 작업에 높은 우선순위, 긴 타임슬라이스 할당해 해결  \r\n발전된 OS는 대화형 작업인지 자동 탐지하여 이 과정 수행  \r\n리눅스는 다른 방법 사용  \r\n\r\n리눅스는 대화형 작업에 특정 우선순위, 타임슬라이스 할당하지 않고,  \r\n일정 비율의 프로세서 시간 보장함  \r\n\r\n같은 나이스 값 가진 프로세스가 대화형 작업 A, 프로세서중심 작업 B 둘뿐이라면 이 비율은 50%임  \r\n각 프로세스는 절반의 프로세서 시간 보장받음  \r\n자연스럽게 대화형 작업이 입출력 기다리며 사용 시간 덜 사용하여 비율 커짐\r\n대화형 작업이 깨어났을 때, CFS가 비율 차이를 알게 되고 A가 선점할 수 있게함\r\nA가 다시 입출력 대기 상태로 들어가면 B가 실행됨\r\n\r\n\r\n\r\n#리눅스 스케줄링 알고리즘\r\n\r\n##스케줄러 클래스 \r\n\r\n리눅스 스케줄러는 모듈화되어 있음  \r\n여러 유형의 프로세스를 각기 다른 알고리즘 적용 스케줄링 가능  \r\n\r\n스케줄러 클래스 이용 교체 가능한 여러 알고리즘 동시 사용하며 클래스별로 독자적 방식 프로세스 스케줄링 가능\r\n\r\n각 스케줄러 클래스에 우선순위 존재  \r\nkernel/sched.c에 정의된 기본 스케줄러 코드는 각 스케줄러 클래스를 우선순위에 따라 차례대로 실행함  \r\n실행 가능한 프로세스가 있는 가장 우선순위 높은 스케줄러가 다음에 실행할 프로세스 선택함  \r\n\r\nCFS는 SCHED\\_NORMAL로 정의된(POSIX 표준에서는 SCHED\\_OTHER) 리눅스의 일반 프로세스용 스케줄러 클래스 \r\nCFS는 kernel/sched_fair.c에 정의됨  \r\n\r\n##유닉스 시스템의 프로세스 스케줄링 \r\n\r\n현대 프로세스 스케줄러의 두 가지 공통 개념 : 프로세스 우선순위, 타임슬라이스\r\n\r\n유닉스에서 우선순위 : 나이스 값 형태로 사용자 공간에 개방됨  \r\n=> 방법론적인 문제 존재 \r\n1. 나이스 값과 타임슬라이스 연계시키려면 각 나이스 값에 할당할 타임슬라이스 절대값 정해야 함\r\n\t- 작업 전환이 최적화 잘 안됨 : 같은 우선순위 두 개 프로세스만 존재 시 두 프로세스의 우선순위가 높은 경우는 오래, 낮은 경우는 짧게 실행됨  \r\n\t\t\t\t  하지만 높은 우선순위인 경우 포어그라운드 사용자 작업, 낮은 우선순위 경우 백그라운드 프로세서중심 작업일 가능성 커서 비이상적\r\n2. 나이스 값 1 차이가 5ms의 타임슬라이스 차이를 만듬\r\n\t- 10ms와 5ms간의 차이와 100ms와 95ms간의 차이의 간극 존재\r\n\r\n3. 대부분 OS에서 타이머 클럭의 일정 배수로 타임슬라이스 단위 정해야 함\r\n\t- 타이머 틱이 10ms일수도 1ms일수도 있으므로, 타이머 틱보다 타임슬라이스 작아질 수 없고, 시스템 타이머에 타임슬라이스 차이가 의존적이게 됨\r\n4. 깨어난 즉시 해당 작업 실행될 수 있도록 타임슬라이스 소진한 경우에도 해당 프로세스 우선순위 끌어올려 주고 싶은 경우 존재 \r\n\t- 한 프로세스가 나머지를 희생시키게 되는 불공정한 상황 만드는 방법론적 허점 야기함  \r\n\r\n나이스 값에 따른 타임슬라이스 값을 선형이 아닌 기하적인 값 사용 시 2번째 문제 해결 가능\r\n\r\n나이스 값에 할당하는 타임슬라이스 단위를 타이머 틱에 영향 받지 않도록 정하여 3번째 문제 해결 가능\r\n\r\n하지만 타임슬라이스 값을 지정하는 고정된 전환 비율 사용 시 궁극적 해결책이 될 수 없음\r\n\r\nCFS는 작업 전환 비율 조정(타임슬라이스 값 무시하고 각 프로세스에 할당할 프로세서 비율 정함)을 통해 일정한 공정성 유지 \r\n\r\n\r\n##공정 스케줄링\r\n\r\n단순한 개념 바탕   \r\n이상적이고 완벽한 멀티태스킹 프로세서 가진 시스템의 프로세스 스케줄링 추구  \r\n\r\n실행 가능한 프로세스 n개 시,  \r\n이상적 시스템 각 프로세스에 1/n의 프로세서 시간 할당,  \r\n이런 프로세스를 무한히 작은 시간 단위로 스케줄링하여 특정 시간 안에 n개 프로세스 모두 동일 시간 동안 실행되게 할 수 있음\r\n\r\n표준 유닉스 방식에선 한 프로세스 5ms 실행 후 다른 것 5ms 실행(실행중인 프로세스가 프로세서 100% 사용하며)\r\n이상적 완벽한 멀티태스킹 프로세서라면 10ms 동안 프로세서 50%씩 사용하는 두 프로세스 동시 실행 가능 <= 완전 멀티태스킹이라고 함\r\n\r\n하지만 한 프로세서에서 여러 개 프로세스 동시 실행 불가능하므로 비현실적인 방식임  \r\n프로세스 전환 비용 때문에 극단적 짧은 시간 간격 실행은 비효율적  \r\n\r\nCFS는 각 프로세스 순차적으로 일정 시간 동안 실행하고, 가장 실행 덜 된 프로세스를 다음에 실행할 프로세스로 선택  \r\nCFS는 프로세스별로 타임슬라이스 할당하기보다 실행 가능한 전체 프로세스 개수와 관련된 함수 이용 프로세스 실행 시간 계산  \r\nCFS는 나이스 값 대신 프로세스에 할당할 프로세서 시간 비율의 가중치로 나이스 값을 사용함  \r\n우선순위 낮고 나이스 값 높을수록 프로세스는 낮은 가중치를 받고, 우선순위 높고 나이스 값 낮을수록 높은 비율 가중치 받음\r\n\r\n각 프로세스 실행 시간 =  (자신의 가중치)/(실행 가능한 전체 프로세스 가중치 총합) 비율 해당하는 크기만큼의 타임슬라이스 동안\r\n\r\nCFS는 실제 타임슬라이스 값 계산 위해 완전 멀티태스킹의 무한히 작은 스케줄링 단위를 근사할 수 있는 목표치 정해 놓음  \r\n이 목표치(전체 프로세스에 대한 시간)를 목표 응답시간이라고 함  \r\n목표치가 작을수록 대화형 성능 좋아지고 완전 멀티태스킹에 가까워짐  \r\n하지만 전환비용 커지기 때문에 전체 시스템 효율 나빠짐\r\n\r\nCFS는 타임슬라이스 최소 한계 가짐 = 최소 세밀도__minimum granularity__ <= 기본값 1ms  \r\n비율이 최소 세밀도보다 낮아지면 완벽히 공정하게 작동 못함, 개선 방법 존재하긴 함\r\n\r\nCFS는 나이스 값의 절대적 크기가 아닌 상대적 차이가 시간 할당 비율에 영향 줌\r\n\r\n#리눅스 스케줄링 구현\r\n\r\nCFS 실제 구현은 kernel/sched\\_fair.c에 있음\r\n\r\nCFS의 네가지 구성요소\r\n\t- 시간 기록\r\n\t- 프로세스 선택\r\n\t- 스케줄러 진입 위치\r\n\t- 휴면 및 깨어남\r\n\r\n##시간 기록\r\n\r\n모든 프로세스 스케줄러는 각 프로세스 실행시간 기록해야 함  \r\n대부분 유닉스 시프템은 프로세스에 타임슬라이스 할당하며 기록함  \r\n\r\n###스케줄러 단위 구조체\r\n\r\nCFS에는 타임슬라이스 개념 없지만 실행시간 기록해 두어야 함  \r\n<linux/sched.h>에 정의된 struct sched\\_entity라는 스케줄러 단위 구조체 사용해 관련 정보 저장\r\n\r\n```c\r\nstruct sched_entity {\r\n\tstruct load_weight\tload;\r\n\tstruct rb_node\t\trun_node;\r\n\tstruct list_head \tgroup_node;\r\n\tunsigned int \t\ton_rq;\r\n\tu64\t\t\texec_start;\r\n\tu64\t\t\tsum_exec_runtime;\r\n\tu64\t\t\tvruntime;\r\n\tu64\t\t\tprev_sum_exec_runtime;\r\n\tu64\t\t\tlast_wakeup;\r\n\tu64\t\t\tavg_overlap;\r\n\tu64\t\t\tnr_migrations;\r\n\tu64\t\t\tstart_runtime;\r\n\tu64\t\t\tavg_wakeup;\r\n // CONFIG_SCHEDSTATS 값 설정 시 사용하는 통계용 변수 생략됨\r\n};\r\n```\r\n\r\n스케줄러 단위 구조체는 프로세스 서술자인 struct task\\_struct 구조체에 se 항목으로 들어 있음\r\n\r\n\r\n###가상 실행시간\r\nvruntime 변수에는 프로세스의 가상 실행시간 저장됨  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/리눅스 커널 (4) - 프로세스 스케줄링/"},"frontmatter":{"title":"리눅스 커널 (4) - 프로세스 스케줄링","published":true}}},{"node":{"rawMarkdownBody":"\r\n#애자일 프로세스\r\n[출처 : https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C](https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C)\r\n\r\n아무런 계획이 없는 개발 방법과 계획이 지나치게 많은 개발 방법들 사이에서 타협점을 찾고자 하는 방법론\r\n\r\n계획이 없는 방법론의 경우, 앞으로의 일을 예측하기 힘들고 효율적이지 못하다는 점에서 취약점을 가지고 있으며,  \r\n계획에 너무 의존하는 경우는 그 형식적인 절차를 따르는데 필요한 시간과 비용을 무시할 수 없으며, 전체적인 개발의 흐름 자체를 느리게 하는 단점\r\n\r\n폭포수 모델 또는 나선 모형과 구별되는 가장 큰 차이점은  \r\nless document-oriented, 즉 문서를 통한 개발 방법이 아니라,  \r\ncode-oriented, 실질적인 코딩을 통한 방법론이라는 점\r\n\r\n소프트웨어를 포함한 IT의 개발은 경험적 프로세스 제어 모델로 접근할 필요가 있다.  \r\n경험적 프로세스 제어 모델은 항상 불확실성을 수반하고 포용하고 있다.  \r\n애자일 개발 프로세스는 경험적 프로세스 제어모델로 개발을 관리한다.\r\n\r\n#스크럼\r\n[출처 : https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4))  \r\n\r\n일본 히토츠바시 대학의 노나카 이쿠지로와 타케우지 히로타카가 1986년 1~2월 Harvard Business Review에 올린 \"The New New Product Developement Game\"에서 시작된다. \r\n\r\n\r\n프로젝트관리를 위한 상호,점진적 개발방법론이며, 애자일 소프트웨어 공학 중의 하나이다.  \r\n스크럼(Scrum)은 소프트웨어 개발 프로젝트를 위하여 고안되었지만,  \r\n소프트웨어 유지보수 팀이나 일반적인 프로젝트/프로그램 관리에서도 적용될 수 있다.\r\n\r\n스크럼은 특정 언어나 방법론에 의존적이지 않으며, 개발 언어는 물론이고 객체지향 언어와도 관련이 없는 넓은 응용 범위의 개발 기법이다.\r\n\r\n- 솔루션에 포함할 기능/개선점에 대한 우선 순위를 부여한다.\r\n- 개발 주기는 30일 정도로 조절하고 개발 주기마다 실제 동작할 수 있는 결과를 제공하라.\r\n- 개발 주기마다 적용할 기능이나 개선에 대한 목록을 제공하라.\r\n- 날마다 15분 정도 회의를 가져라.\r\n- 항상 팀 단위로 생각하라.\r\n- 원활한 의사소통을 위하여, 구분 없는 열린 공간을 유지하라.\r\n\r\n\r\n##스크럼의 기반(일본의 조직론에 이론적 기반) - 지식 창조 프로세스를 촉진시키는 5가지 요소\r\n * 조직의 의도 \r\n\t- 지식 창조의 목표나 팀을 지탱하는 축\r\n * 자율성 \r\n\t- 팀의 멤버에게 자유로운 행동을 인정하는 열린 환경(시스템)\r\n * 역동적이고 창조적인 카오스 \r\n\t- 조직 내 외부 간의 역동적인 상호작용을 통한 지식창조 환경\r\n * 잉여성 \r\n\t- 의도적으로 조직에 넘쳐나는 여분의 정보\r\n * 최소 유효 다양성 \r\n\t- 복잡하고 다양한 환경에 기민하게 대응하기 위해서는 조직 구성원이 가져야 하는 다양성\r\n\r\n\r\n##스크럼이 추구하는 가치\r\n스크럼은 다음의 5가지 가치에 중점을 두어 진행된다.\r\n * 확약 \r\n\t- 약속한 것을 확실히 실현하는 것\r\n * 전념 \r\n\t- 확약한 것의 실현에 전념하는 것\r\n * 정직 \r\n\t- 어떤 것이 자신에게 불리해도 숨기지 않는 것\r\n * 존중 \r\n\t- 자신과 다른 사람에게 경의를 표하는 것\r\n * 용기 \r\n\t- 팀 구성원 은 자신이 옳은 일을 할 수 있도록 팀원간 갈등과 도전을 통해 작업 할 수있는 용기\r\n\r\n\r\n##스크럼의 진행\r\n\r\n스크럼에서는, 30일간의 주기로 실제 동작하는 제품을 만들면서 개발을 진행시킨다.  \r\n\t- 일반적인 권장기간은 30일 이지만, 스크럼 적응도 및 진행 상황에 따라 1주~4주의 유연성을 가진다.\r\n\r\n* 제품 백로그(Product Backlog) \r\n\t- 개발할 제품에 대한 요구 사항 목록\r\n* 스프린트(Sprint) \r\n\t- 반복적인 개발 주기 (회사에서 정하는 이터레이션이 개발 주기가 된다. 계획 회의 부터 제품 리뷰가 진행 되는 날짜 까지의 기간이 1스프린트 이다)\r\n* 스프린트 계획 회의(Sprint Planning Meeting) \r\n\t- 스프린트 목표와 스프린트 백로그를 계획하는 회의\r\n* 스프린트 백로그(Sprint Backlog) \r\n\t- 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록\r\n* 일일 스크럼 회의(Daily Scrum Meeting) \r\n\t- 날마다 진행되는 미팅 (어제 한일, 오늘 할일, 장애 현상 등을 공유)\r\n* 실행 가능한 제품(shippable product) 개발 \r\n\t- 스프린트의 결과로써 나오는 실행 가능한 제품\r\n\r\n상기 요소들을 아래와 같은 순서에 따라 사용하여 스크럼을 진행시킨다.\r\n\r\n1. 제품에서 요구하는 기능과 우선순위를 제품 백로그로 정한다.\r\n2. PO가 정한 제품의 우선순위에서 어디까지 작업을 할지 팀과 조율 한다. 조율하여 선정된 제품 백로그가 이번 스프린트의 목표가 된다.\r\n3. 스프린트 목표를 구현 가능 하도록 팀에서 스프린트 백로그를 작성한 뒤 작업을 할당한다.\r\n4. 스프린트를 진행하는 동안, 매일 정해진 장소와 시간에 모든 개발 팀원이 참여하는 일일 스크럼 회의를 가진다.\r\n5. 매회의 스프린트가 종료할 때마다, 스프린트 리뷰 미팅을 통해 만들어진 제품을 학습하고 이해 한다.\r\n6. 제품의 학습과 이해가 끝나면, 스프린트 회고를 통해 팀의 개발 프로세스에 대한 개선의 시간을 갖는다.\r\n7. 스프린트 기간 중 다음 스프린트를 준비 하기 위해 PO와 필요 인원이 모여 백로그를 준비하는 시간을 갖는다.\r\n\r\n\r\n###\r\n\r\n* 제품 책임자(Product Owner) \r\n\t- 제품 백 로그를 정의하여 우선순위를 정해 준다.  제품 책임자는 스프린트 목표와 백로그등의 결정에 있어 중심이 되는 상위 관리자로, 제품 책임자가 독단적으로 목표를 결정하지 않고, 고객과 관리자 및 팀원들이 모여서 목표를 정한다.\r\n* 스크럼 마스터(ScrumMaster) \r\n\t- 프로젝트 관리자(코치), 일반적인 관리를 수행하는 프로젝트 관리자들과는 달리 팀원을 코칭하고 프로젝트의 문제 상황을 해결하는 역할을 함\r\n\r\n\r\n이런 과정을 거친 뒤, 개발 팀원들이 주도적으로 스프린트 목표를 달성하기 위한 작업을 정해 나가게 된다. 보통, 각 작업들은 4시간에서 16시간 정도 걸리도록 정한다. 물론, 작업을 정하고 할당하는데는 고객이나 제품 책임자와는 상관 없이 팀원 자율로 진행된다. 이와 같은 자율적인 행위를 통해서 팀원들은 의사를 활발하게 주고 받게 되고, 끈끈한 협업체계를 가지게 된다.\r\n\r\n애자일 프로세스는 외부로부터의 질서보다는 팀원 스스로가 만들어나가는 자기 조직화를 중요하게 여기고 있다. 하지만, 이러한 부분과 더불어 애자일 프로세스는 무질서해 보이기 때문에 전통적인 프로세스 개선과 마찰이 생기게 된다.\r\n\r\n\r\n\r\n","fields":{"slug":"/소프트웨어 공학 - 애자일 프로세스, 스크럼/"},"frontmatter":{"title":"소프트웨어 공학 - 애자일 프로세스, 스크럼","published":true}}},{"node":{"rawMarkdownBody":"#캐시 컬러링__Cache coloring__(=페이지 컬러링__Page coloring__)\r\n\r\n출처 : [위키피디아](https://en.wikipedia.org/wiki/Cache_coloring)\r\n\r\n프로세서에 의해 캐시된 총 페이지 수를 최대화하기 위해,  \r\nCPU 캐시에게 인접한 free page를 할당하려는 시도의 과정  \r\nOS의 low-level dynamic memory allocation code에 가상 메모리를 물리 메모리로 매핑할 때 자주 사용됨  \r\n한 프로그램에서 다음 것까지로의 페이지 할당에서의 차이는 프로그램 퍼모먼스의 큰 차이로 이어질 수 있음에 따라,  \r\n캐시 컬러링이 안되는 가상 메모리 서브시스템은 캐시 퍼포먼스 관련하여 덜 deteministic 함  \r\n  \r\n물리적으로 인덱스된 CPU 캐시는 인접한 주소의 물리 메모리 블럭들이 다른 위치에 캐시되도록 디자인되어 있지만, 가상 메모리 경우는 아니다.  \r\n가상 메모리에서 인접했지만 물리 메모리에서 인접하지 않은 메모리 블럭들이 할당될 때, 그들은 잠재적으로 같은 위치에 캐시될 수 있다.  \r\n컬러링은 이웃 페이지들과 경쟁하지 않을 페이지를 선택하는 방법으로 위 문제를 해결하는 메모리 관리 소프트웨어에 적용되는 기법이다.   \r\n캐시 컬러링에서 물리 메모리 페이지들은 다른 \"colors\"의 페이지들이 CPU 캐시 메모리의 다른 위치에 캐시되도록 \"colored\"된다.  \r\n가상 메모리에 프로세스들을 위해 연속된 페이지를 할당할 때, 커널은 다른 \"colors\"의 페이지들을 모으고 그것들을 가상 메모리에 매핑한다.  \r\n이 방법으로, 연속된 페이지들은 가상 메모리에서 같은 캐시 라인에 캐시되기 위해 경쟁하지 않게 된다.  \r\n","fields":{"slug":"/캐시 컬러링(페이지 컬러링)/"},"frontmatter":{"title":"캐시 컬러링(페이지 컬러링)","published":true}}},{"node":{"rawMarkdownBody":"\r\n#프로세스\r\n\r\n프로세스는 실행 중인 프로그램(특정 매체에 저장된 오브젝트 코드)  \r\n하지만 프로세스는 사용 중인 파일, 대기 중인 시그널, 커널 내부 데이터, 프로세서 상태, 하나 이상의 물리적 메모리 영역이 할당된 메모리 주소 공간, 실행 중인 하나 이상의 스레드 정보, 전역 데이터가 저장된 데이터 부분 등 모든 자원을 포함하는 개념\r\n\r\n사실상 프로세스는 프로그램 코드를 실행하면서 생기는 모든 결과물\r\n\r\n커널은 이 모든 세부 사항을 투명하고 효율적인 방식으로 관리해야 함\r\n\r\n실행 중인 스레드(보통 줄여서 스레드라 칭하는)는 프로세스 내부에서 동작하는 객체  \r\n각 스레드는 개별적인 프로그램 카운터와 프로세스 스택, 프로세서 레지스터를 가지고 있음  \r\n\r\n커널은 프로세스가 아니라 이러한 각각의 스레드를 스케줄링 함\r\n\r\n전통적인 유닉스 시스템 : 프로세스가 하나의 스레드로 구성  \r\n현대 시스템 : 여러 개의 스레드로 구성된 다중 스레드 프로그램 만연  \r\n\r\n리눅스는 독특한 방식으로 스레드 구현  \r\n리눅스는 프로세스와 스레드 구분 안함  \r\n리눅스에서 스레드는 조금 특별한 형태의 프로세스일 뿐\r\n\r\n현대 운영체제에서 프로세스는 가상 프로세서와 가상 메모리라는 두 가지 가상 환경 제공  \r\n가상 프로세서는 실제로 수백 개의 프로세스가 프로세서를 공유하는 상황이라도, 프로세스가 혼자 시스템을 사용하는 듯한 가상 환경 제공  \r\n가상 메모리는 프로세스가 시스템의 전체 메모리를 혼자 차지하고 있는 것처럼 메모리를 할당하고 관리할 수 있게 해줌  \r\n\r\n스레드는 각자 고유한 가상 프로세서를 할당받지만 가상 메모리는 공유함 \r\n\r\n프로그램 자체는 프로세스가 아님  \r\n프로세스는 작동 중인 프로그램 및 그와 관련된 자원을 뜻함  \r\n같은 프로그램 실행하는 둘 이상의 프로세스 존재 가능  \r\n여러 프로세스가 같이 파일 사용, 주소 공간 등의 자원 공유 가능\r\n\r\n프로세스는 생성되면서 생을 시작  \r\n리눅스에서는 기존 프로세스를 복사해서 새 프로세스를 만드는 fork() 시스템 호출을 통해 프로세스가 만들어짐  \r\nfork()를 호출하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 됨  \r\n부모 프로세스는 fork() 시스템 호출이 반환된 지점에서 실행을 계속, 자식 프로세스도 같은 위치에서 실행 시작  \r\n즉, fork() 시스템 호출은 부모 프로세스에서 한 번, 자식 프로세스에서 한 번, 총 두 번 반환이 일어남  \r\n\r\n대개의 경우 fork한 직후 다른 새 프로그램 실행  \r\nexec() 계열의 함수를 호출해 새로운 주소 공간 만들고 새 프로그램 불러들일 수 있음  \r\n리눅스 커널의 fork() 시스템 호출은 실제로는 clone() 시스템 호출을 이용해 구현됨  \r\n\r\n프로그램은 exit() 시스템 호출을 통해 종료됨  \r\n이 함수는 프로세스를 종료하고 프로세스의 모든 자원 반납  \r\n부모 프로세스는 특정 프로세스가 종료할 때까지 기다리는 wait4() 시스템 호출을 이용해 자식 프로세스의 종료 상태 확인 가능\r\n\r\n* 커널이 구현하는 것은 wait4() 시스템 호출. 리눅스 시스템은 C 라이브러리를 통해 일반적인 wait(), waitpid(), wait3(), wait4() 함수를 제공함. 각 함수는 조금씩 다르지만 모두 종료된 프로세스의 상태 정보 제공함\r\n\r\n* 프로세스를 다른 말로 태스크(task, 작업)라고도 부름. 리눅스 커널 내부에서는 프로세스를 태스크라고 부르는 경우 많음. 보통 커널 관점에서 프로세스 지칭 시 태스크라는 용어 사용 \r\n\r\n\r\n#프로세스 서술자와 태스크 구조체\r\n\r\n커널은 프로세스 목록을 태스크 리스트라고 부르는 환형 양방향 연결 리스트 형태로 저장(태스크 배열로 부르는 경우도 있지만 연결 리스트이므로 태스크 리스트가 적절)  \r\n태스크 리스트의 각 항목은 <linux/sched.h>에 정의된 struct task_struct 형식으로 되어 있으며, 프로세스 서술자라고 부름  \r\n프로세스 서술자에는 해당 프로세스와 관련된 모든 정보가 들어 있음  \r\n\r\ntask_struct 구조체는 32비트 시스템에서 약 1.7KB의 상당히 큰 구조체  \r\n커널이 프로세스를 관리하는데 필요한 모든 정보를 가지고 있다는 점을 감안 시 이 크기는 작은 것  \r\n\r\n프로세스 서술자에는 사용 중인 파일, 프로세스의 주소 공간, 대기 중인 시그널, 프로세스의 상태 등 실행 중인 프로그램을 설명하는 많은 정보가 들어 있음\r\n\r\n\r\n##프로세스 서술자의 할당\r\n\r\ntask\\_struct 구조체는 객체 재사용 및 [캐시 컬러링](http://kmkmi.github.io/%EC%BA%90%EC%8B%9C%20%EC%BB%AC%EB%9F%AC%EB%A7%81(%ED%8E%98%EC%9D%B4%EC%A7%80%20%EC%BB%AC%EB%9F%AC%EB%A7%81)/) 기능을 지원하는 슬랩 할당자__slab allocator__를 사용해 할당  \r\n\r\n\r\n2.6 커널 이전에는 task\\_struct 구조체를 각 프로세스의 커널 스택 끝 부분에 저장했음  \r\n(이렇게 하면 x86처럼 레지스터가 적은 아키텍처에서는 구조체 위치를 저장하는 레지스터를 별도로 사용하지 않고도 스택 포인터 통해 프로세스 서술자 위치 계산 가능했었음)  \r\n이제는 슬랩 할당자 이용 동적으로 프로세스 서술자 만들기 때문에 thread_info라는 새로운 구조체를 스택이 아래쪽으로 확장 시 스택 밑바닥, 위쪽으로 확장 시 스택 꼭대기에 대신 둠\r\n\r\n* 레지스터 부족 시스템 위해서만 아니라 thread_info 구조체 사용으로 어셈블리 코드에서 사용하는 값 오프셋 계산을 쉽게 할 수 있도록 함 \r\n\r\n각 태스크의 thread\\_info 구조체는 프로세스 스택의 제일 끝부분에 할당됨  \r\n구조체의 task 포인터가 태스크의 실제 task_struct 구조체를 가리킴  \r\n\r\n## 프로세스 서술자 저장\r\n\r\n시스템은 고유한 프로세스 인식 번호(PID)를 이용해 프로세스 구별함  \r\nPID는 pid_t라는 부정형__opaque__의 숫자 값으로, 보통은 실제로 int 형 사용함  \r\n하지만 초기 유닉스 및 리눅스와의 하위 호환성 문제로 PID 최대값은 기본적으로 (short int 최대값인) 32,768이며, 이 값은 선택적으로(<linux/thread.h> 파일을 통해) 400만으로 상향 조정 가능  \r\n커널은 PID 값을 프로세스 서술자의 pid 항목에 저장  \r\n\r\n* 부정형은 실제 물리적인 표현형 알려지지 않았거나 실제 표현형 노출할 필요 없을 때 사용하는 형이다.\r\n\r\n###\r\n근본적으로 PID 최대값은 시스템에 동시에 존재할 수 이쓴 최대 프로세스 수  \r\n일반 데스크탑 시스템은 32,768개 충분하지만, 대용량 서버에서는 더 많은 프로세스 필요할 수 있음  \r\n최대값이 낮을수록 상항을 넘어 다시 낮은 PID값 할당되는 상황 빨리 돌아옴  \r\n=> 이 경우 나중에 만든 프로세스 PID가 큰 값을 갖는다는 유용한 정보 사라짐\r\n\r\n오래된 애플리케이션과의 호환성 고려할 필요 없다면, 시스템 관리자가 /proc/sys/kernel/pid_max 값 수정해 최대값 증가 가능  \r\n\r\n커널 내부에서 태스크에 접근할 때 보통 task_struct 구조체의 포인터를 사용함  \r\n따라서 현재 실행 중인 태스크의 프로세스 서술자를 빠르게 찾는 방법 필요 => current 매크로가 이 역할을 함  \r\n\r\ncurrent 매크로 : 아키텍처별로 다른 방식으로 구현됨  \r\n어떤 아키텍처는 현재 실행 중인 프로세스의 task\\_struct 포인터를 레지스터에 저장해 두고 접근하는 효율적인 방식을 쓸 수 있음  \r\n(레지스터를 아껴야 하는)x86 같은 아키텍처에서는 thread\\_info 구조체가 커널 스택에 저장된다는 사실을 이용해 thread\\_info 구조체의 위치를 계산해내고, 이를 통해 task\\_struct의 위치 알아냄  \r\n\r\nx86의 current 매크로는 스택 포인터의 하위 13비트를 덮어쓰는 방식으로 thread\\_info 구조체 위치 계산해냄  \r\ncurrent\\_thread\\_info() 함수가 이 역할을 담당함\r\n```nasm\r\nmovl $-8192, %eax\r\nandl %esp, %esp\r\n```\r\n이 코드는 스택 크기가 8KB라고 가정함. 4KB 스택 사용 시 8192 대신 4096을 사용.\r\n\r\n마지막으로, 이 current 매크로는 thread\\_info의 항목을 참조해 task\\_struct 구조체를 반환\r\n```c\r\ncurrent_thread_info()->task;\r\n```\r\n\r\nIBM의 RISC기반 PowerPC에서는 이와 다른 방식 사용하는데, 레지스터에 현재 task\\_struct 포인터를 저장하는 방식 사용함  \r\n따라서 PPC에서 current 매크로는 r2 레지스터에 저장된 값을 반환하기만 하면 된다.  \r\n프로세스 서술자에 접근하는 것은 매우 빈번하고 중요한 작업이기 때문에 이를 별도 레지스터를 할당할 만한 작업이라고 판단했기 때문\r\n\r\n\r\n##프로세스 상태 \r\n\r\n프로세스 서술자의 state 항목은 현재 프로세스가 처한 환경을 알려줌  \r\n시스템의 프로세스는 정확히 다섯 가지 상태 중 하나에 있음  \r\n각 상태값은 다음 다섯 가지 플래그를 이용해 표현\r\n\r\n* TASK\\_RUNNING - 프로세스가 실행 가능한 상태. 현재 실행 중이거나 실행되기 위해 실행 대기열에 있는 상태. 사용자 공간에서 실행된 프로세스는 이 상태만 가질 수 있음. 커널 공간에서 실행 중인 프로세스도 이 상태에 속함.\r\n* TASK\\_INTERRUPTIBLE - 프로세스가 특정 조건이 발생하기를 기다리며 쉬는 중임(중단). 기다리는 조건이 발생하면 커널은 프로세스의 상태를 TASK\\_RUNNING으로 바꾼다. 프로세스가 시그널을 받은 경우에는 조건에 상관없이 실행 가능한 상태로 바뀜.\r\n* TASK\\_UNINTERRUPTIBLE - 시그널을 받아도 실행 가능 상태로 바뀌지 않는 점 제외하면 TASK\\_INTERRUPTIBLE 상태와 같음. 이 상태는 프로세스가 방해받지 않고 특정 조건을 기다려야 하는 경우, 기다리는 조건이 금방 발생하는 경우에 사용. 이 상태에 있는 태스크는 시그널에 응답 안 하므로(이것 때문에 ps(1) 명령 결과에 D 상태로 ㅍ시되는 죽일 수 없는 프로세스가 등장하는 이유. 작업이 시그널에 응답 안 하므로 SIGKILL 시그널 보낼 수 없음. 게다가, 작업 종료가 가능해도 중요한 동작을 수행 중이거나 세마포어 사용 작업일 수 있으므로 종료 안 하는 것이 바람직), 이 플래그는 TASK_INTERRUPTIBLE만큼 자주 사용 안 함.\r\n* \\_\\_TASK\\_TRACED - 디버거 등의 다른 프로세스가 ptrace를 통해 해당 프로세스를 추적하는 상태\r\n* \\_\\_TASK\\_STOPPED - 프로세스 실행이 정지된 상태. 해당 태스크는 실행 중이지도 않고 실행 가능한 상태도 아님. 작업이 SIGSTOP, SGTSTP, SIGTTIN, SIGTTOU 같은 시그널을 받은 경우 디버그 중에 시그널을 받은 경우에 이 상태가 이 상태가 됨.\r\n\r\n##현재 프로세스 상태 조작\r\n\r\n커널 코드에서 프로세스의 상태를 바꿀 필요가 생기는 경우 많음.  \r\n다음 함수를 사용하기를 권장\r\n```c\r\nset_task_state(task, state); // 태스크 'task'의 상태를 'state' 상태로 설정\r\n```\r\n이 함수는 특정 태스크의 상태를 지정한 상태로 변경. 그리고 필요한 경우, 이 함수는 메모리 보호 기능 이용 다른 프로세서와 작업 순서 겹치는 것 방지(대칭형 다중 프로세스 시스템에서 이 기능 필요).  \r\n\r\n대칭형 다중 프로세스 시스템 경우 고려할 것을 빼면 이 함수는 다음 동작을 함\r\n```c\r\ntask->state = state;\r\n```\r\nset\\_current\\_state(state) 함수는 set\\_task\\_state(current, state) 함수와 같음.  \r\n해당 함수 구현은 <linux/sched.h> 참고 \r\n\r\n\r\n##프로세스 컨텍스트\r\n\r\n프로세스의 중요한 부분 중 하나는 실행 중인 프로그램 코드  \r\n실행 파일에서 이 코드를 읽어 들이고, 프로그램 주소 공간에서 코드 실행함  \r\n일반적인 프로그램은 사용자 공간에서 실행됨  \r\n프로그램이 시스템 호출을 사용하거나 예외 처리 발생 시, 프로그램은 커널 공간으로 진입함  \r\n이런 상황을 커널이 '프로세스를 대신해 실행 중' 또는 '커널이 프로세스 컨텍스트에 있음'이라고 함  \r\n프로세스 컨텍스트에 있을 때 current 매크로 사용 가능  \r\n그 사이에 우선순위가 높은 프로세스가 실행 가능한 상태가 되어 스케줄러가 그 프로세스 먼저 실행하지 않으면, 커널이 작업 끝내면 프로세스는 사용자 공간에서 실행 계속함  \r\n\r\n시스템 호출과 예외 처리기는 잘 정의된 커널 진입 인터페이스임  \r\n프로세스는 이 두 가지 인터페이스 중 하나를 통해 커널 공간에 들어갈 수 있음  \r\n즉, 커널에 대한 접근은 이 두 인터페이스를 통해야만 함\r\n\r\n\r\n##프로세스 계층 트리\r\n\r\n유닉스 시스템처럼 리눅스도 프로세스 간 독특한 계층 구조 존재  \r\n모든 프로세스는 PID가 1인 init 프로세스의 자손임  \r\ninit 프로세스는 부트 과정의 최종 단계에서 커널이 실행하는 프로세스임  \r\n그 다음 init 프로세스는 시스템의 초기화 스크립트를 읽어 더 많은 프로그램 실행시켜 부트 과정 완료함  \r\n\r\n시스템의 모든 프로세스는 정확히 하나의 부모 프로세스를 가짐  \r\n또한 모든 프로세스는 하나 이상의 자식 프로세스를 가질 수 있음  \r\n같은 부모 프로세스를 가지는 자식 프로세스를 형제 프로세스__sibling__라고 부름  \r\n프로세스간의 관계는 프로세스 서술자에 저장됨  \r\n각 task\\_struct 구조체에는 부모의 task\\_struct를 가리키는 parent라는 포인터와 자식의 task\\_struct 리스트를 가리키는 children 포인터가 들어 있음  \r\n\r\n현재 프로세스에 대해 다음과 같은 코드를 이용 시 부모 프로세스의 프로세스 서술자 얻기 가능 \r\n```c\r\nstruct task_struct *my_parent = current->parent;\r\n```\r\n\r\n다음과 같은 코드로 프로세스의 모든 자식 프로세스에 접근 가능\r\n```c\r\nstruct task_struct *task;\r\nstruct list_head *list;\r\n\r\nlist_for_each(list, &current->children) {\r\n\ttask = list_entry(list, struct task_struct, sibling);\r\n\t// 이제 task는 현재 프로세스의 자식 프로세스 중 하나를 가리킴 \r\n}\r\n```\r\n\r\ninit 태스크의 프로세스 서술자는 init\\_task라는 이름으로 정적으로 할당됨  \r\n\r\n다음 코드는 모든 프로세스 사이의 관계를 보여줌\r\n```c\r\nstruct task_struct *task;\r\n\r\nfor (task = current; task != &init_task; task = task->parent)\r\n\t;\r\n// task가 init을 가리킬 때까지 반복\r\n```\r\n\r\n프로세스 계층 구조 이용 시 시스템의 어떤 프로세스에서도 다른 특정 프로세스 찾아갈 수 있음  \r\n시스템의 모든 프로세스를 훑고 싶을 때에는 작업(태스크) 리스트가 환형 양방향 리스트이므로 매우 쉽게 작업 가능  \r\n\r\n어떤 태스크가 주어졌을 때 리스트에서 다음 태스크를 얻기 위해서는 다음 코드를 실행하면 됨\r\n```c\r\nlist_entry(task->tasks.next,  struct task_struct, tasks)\r\n```\r\n이전 태스크를 얻기 위해서는 다음 코드 실행\r\n```c\r\nlist_entry(task->tasks.prev,  struct task_struct, tasks)\r\n```\r\n\r\n위 두 가지 루틴은 next\\_task(task)와 prev\\_task(task)라는 매크로로 제공됨  \r\n\r\n전체 태스크 열거하는 for\\_each\\_process(task) 매크로(반복 단계마다 task 포인터는 리스트의 다음 태스크 가리킴)\r\n```c\r\nstruct task_struct *task;\r\n\r\nfor_each_process(task) {\r\n\t// 매크로의 각 반복마다 각 태스크의 이름과 PID 출력됨\r\n\tprintk(\"%s[%d]\\n\", task->comm, task->pid);\r\n}\r\n```\r\n모든 태스크 열거하는 일은 매우 부하가 큰 작업임\r\n\r\n\r\n#프로세스 생성\r\n\r\n대부분 OS는 스폰__spawn__ 방식으로 새로운 주소 공간에 새 프로세스 만들고, 실행 파일 읽은 후 그 코드를 실행하여 프로세스 생성  \r\n\r\n유닉스는 독특하게 이 과정을 fork()와 exec()이라는 두 함수로 분리  \r\n\r\n* 여기서 exec() 함수는 exec() 함수 군을 일컬음. 커널은 execve() 시스템 호출을 바탕으로 execlp(), execle(), execv(), execvp() 함수를 구현함.\r\n\r\n#####\r\n\r\n먼저 fork()는 현재 태스크를 복제해 자식 프로세스를 만듦  \r\n이렇게 만들어진 프로세스는 (고유값을 갖는)PID와 (부모 프로세스 PID인)PPID, 상속되지 않는 지연된 시그널과 같은 일부 자원과 통계 수치 제외하고는 부모와 같은 값을 가짐  \r\n다음 함수인 exec()은 새로운 실행파일을 주소 공간에 불러오고 이를 실행  \r\nfork() 다음에 exec()을 실행하는 조합은 대부분 OS에서는 하나의 함수로 제공\r\n\r\n\r\n##Copy-on-Write\r\n\r\n전통적인 fork()는 부모 프로세스의 모든 자원 복사해 자식 프로세스에게 넘겨줌  \r\n이런 방식은 공규 가능한 많은 데이터를 복사하므로 단순하고 비효율적  \r\n게다가 새로 만든 프로세스가 바로 다른 프로그램 실행하는 경우 복사 작업이 모두 헛수고가 됨  \r\n리눅스에서는 'copy-on-write(기록사항 발생 시 복사)' 페이지를 이용해 fork() 함수 구현했음  \r\n기록사항 발생 시 복사__COW__, __Copy-on-Write__ 기능은 데이터 복사를 지연 또는 방지하는 기능임  \r\n프로세스 주소 공간을 복사하는 대신 부모와 자식 프로세스가 같은 공간 공유함  \r\n\r\n그러나 기록사항 발생해 데이터 변경 필요 시 그 순간 사본을 만들어 각 프로세스가 별도의 내용 가지게 됨  \r\n따라서 리소스 복사는 해당 리소스에 대한 기록이 발생하는 경우에만 일어남  \r\n그때까지는 읽기전용 상태로 공유 가능  \r\n이 기법은 주소 공간에 실제 기록 작업 일어날 때까지 각 페이지의 복사 작업을 지연시킴  \r\n프로세스가 절대 기록을 하지 않는 경우, e.g. fork() 직후에 exec() 함수가 호출되는 경우에는 복사가 필요 없어짐  \r\n\r\nfork() 함수가 해야 할 일은 프로세스의 페이지 테이블을 복사하는 것, 자식 프로세스용 프로세스 서술자를 만들어 주는 것뿐임  \r\n일반적으로 프로세스는 생성된 다음 다른 실행파일 실행하므로, 이 같은 최적화를 통해 많은 데이터 복사 낭비를 막음  \r\n유닉스의 철학인 빠른 프로세스 실행에 부합  \r\n\r\n\r\n##프로세스 생성 \r\n\r\n리눅스는 clone() 시스템 호출 이용 fork() 구현  \r\nclone() 시스템 호출은 다양한 플래그 사용해 부모와 자식 프로세스간 공유가 필요한 자원 지정  \r\nfork(), vfork(), \\_\\_clone() 라이브러리 함수는 각자 적절한 플래그 사용해 clone()을 호출함  \r\nclone() 시스템 호출은 다시 do\\_fork() 함수를 호출  \r\n\r\n실제 프로세스 생성 작업은 kernel/fork.c에 정의된 do\\_fork() 함수에서 처리함  \r\n이 함수는 copy\\_process() 함수 호출하고 프로세스 실행을 시작함  \r\ncopy\\_process() 함수가 하는 일은 다음과 같음  \r\n\r\n1. dup\\_task\\_struct() 함수를 호출해 커널 스택 새로 만들고, 새 프로세스용 thread\\_info, task\\_struct 구조체 만듦. 새로 만들어진 데이터의 값은 현재 태스크와 동일함. 이 시점에 부모와 자식 프로세스의 프로세스 서술자는 같음.\r\n2. 새로 만든 자식 프로세스로 인해 현재 사용자의 프로세스 개수 제한을 넘어가지 않는지 확인.\r\n3. 이제 자식 프로세스를 부모와 구별해야 함. 프로세스 서술자의 다양한 항목의 값을 초기화함. 프로세스 서술자에서 부모 프로세스의 값을 물려받지 않는 항목은 주로 통계 정보. 대부분의 task\\_struct 항목 값은 바뀌지 않음. \r\n4. 자식 프로세스의 상태를 TASK\\_UNINTERRUPTIBLE로 설정해 아직 실행되지 않게 함.\r\n5. copy\\_process()는 copy\\_flag() 함수를 호출해 task\\_struct 구조체의 flags 내용을 정리함. 작업이 관리자 권한을 가지고 있음을 뜻하는 PF\\_SUPERPRIV 플래그를 초기화함. 프로세스가 exec() 함수를 호출하지 않았음을 뜻하는 PF\\_FORKNOEXEC 플래그를 설정함.\r\n6. alloc_pid() 함수를 호출해 새로 만든 태스크에 새로운 PID 값을 할당함.\r\n7. clone() 함수에 전달된 플래그 값에 따라 copy\\_process()는 열린 파일 및 파일시스템 정보, 시그널 핸들러, 프로세스 주소 공간, 네임스페이스__namespace__ 등을 복제하거나 공유함. 보통 스레드 사이에서는 이런 자원을 공유하며, 그 외의 경우에는 개별적으로 사용하므로 이 단계에서 복제함.\r\n8. 마지막으로 copy\\_process()는 나머지 정리 작업을 수행하고 호출한 쪽에 새로 만든 자식 프로세스의 포인터를 반환함.\r\n\r\n\r\ndo\\_fork()로 반환되어 돌아오면 copy\\_process()가 성공한 경우에 새로 만든 자식 프로세스를 깨워서 실행함  \r\n커널은 의도적으로 자식 프로세스를 먼저 실행함(제대로 동작 안 되는 경우 있음)  \r\n일반적으로 자식 프로세스는 바로 exec() 함수 호출하므로, 부모 프로세스가 먼저 실행될 시 주소 공간에 쓰기 작업이 생겨 발생하는 COW 작업 막을 수 있음  \r\n\r\n\r\n##vfork()\r\n\r\nvfork() 시스템 호출은 부모 프로세스의 페이지 테이블을 복사하지 않는다는 점만 빼면 fork()와 똑같이 동작함  \r\n대신 자식 프로세스는 부모 프로세스의 주소 공간 속에서 별개의 스레드 형태로 실행되고, 부모 프로세스는 자식 프로세스가 exec()을 호출하거나 종료할 때까지 대기함  \r\n자식 프로세스는 주소 공간의 내용을 바꿀 수 없음  \r\nCOW를 이용해 fork()를 구현할 수 없었던 옛날 3BSD 시절 상당히 좋은 최적화 기법이었음  \r\n2.6 버전 기준 COW, 자식 프로세스 우선 실행 방식을 사용하기 때문에, vfork() 사용으로 얻을 수 있는 이점은 부모 프로세스의 페이지 테이블 복사 안 하는 것뿐임  \r\n리눅스 페이지 테이블 항목에 대해서도 COW 기능 제공 시 이 장점도 사라짐  \r\nvfork()의 작동 방식 상당히 까다로움(e.g. exec() 실패 시 대처 방법?)\r\n이상적인 시스템이라면 vfork() 필요 없음으로 커널에서 꼭 이를 구현 안 해도 됨  \r\n일반적인 fork() 이용해 vfork() 구현해도 문제 없음, 실제로 2.2 버전 커널까지 이 방식 사용  \r\n\r\nvfork() 시스템 호출은 clone() 시스템 호출에 특별한 플래그를 지정해 구현함  \r\n1. copy\\_process()에서 task\\_struct의 vfork\\_done 항목을 NULL로 설정함.\r\n2. 특별한 플래그가 지정된 경우 do\\_fork()에서 vfork\\_done 포인터가 특정 주소를 가리키도록 함.\r\n3. 부모 프로세스는 자식 프로세스를 우선 실행시킨 다음 반환하지 않고 자식 프로세스가 vfork\\_done 포인터 이용해 신호를 보낼 때까지 대기.\r\n4. 태스크가 메모리 주소 공간을 반환할 때 호출되는 mm\\_release() 함수에서 vfork\\_done 포인터가 NULL인지 아닌지 확인함. NULL이 아니면 부모 프로세스에 신호 보냄. \r\n5. do\\_fork() 함수로 돌아가서 부모 프로세스 깨우고 반환함.\r\n\r\n계획대로 진행 시 자식 프로세스는 새 주소 공간에서 실행되고, 부모 프로세스는 원래 주소 공간에서 실행됨  \r\n부담은 적지만 깔끔한 구현은 아님\r\n\r\n\r\n#리눅스의 스레드 구현\r\n\r\n스레드는 널리 쓰이는 현대적 프로그래밍 기법  \r\n스레드를 이용해 메모리 주소 공간을 공유하는 같은 프로그램 여러 개 동시에 실행 가능  \r\n스레드는 사용 중인 파일 및 기타 자원을 공유함  \r\n스레드를 통해 동시 프로그래밍__concurrent programming__이 가능해지고, 다중 프로세서 시스템에서는 진정한 병렬처리를 구현 가능함 \r\n\r\n리눅스는 독특한 스레드 구현 방식 가짐  \r\n리눅스 커널에는 별도의 스레드 개념 없음  \r\n기본적인 프로세스로 모든 스레드를 구현  \r\n\r\n리눅스 커널은 스레드를 위한 별도의 자료구조, 특별한 스케줄링 기법 없음  \r\n리눅스의 스레드는 특정 자원을 다른 프로세스와 공유하는 특별한 프로세스일 뿐  \r\n각 스레드는 별도의 task\\_struct 구조체 가짐, 커널 입장에서 주소 공간과 같은 자원을 다른 프로세스와 공유하고 있는 정상적인 프로세스\r\n\r\n스레드에 대한 이런 접근 방식은 윈도우나 솔라리스처럼 커널에서 별도의 스레드(lightweigh process=경량 프로세스라 부르기도 함)를 지원하는 방식과 크게 다름  \r\n경량 프로세스라는 이름이 시스템간 철학적 차이 보여줌  \r\n리눅스 외 다른 OS에서 스레드는 무거운 프로세스에 비해 가볍고 빠륵 실행하는 기능을 제공하는 무언가  \r\n리눅스에서는 다른 프로세스와 자원을 공유하는(이미 충분히 경량화된) 프로세스에 불과함  \r\ne.g. 네 개의 스레드로 구성된 프로세스 경우  \r\n\t리눅스 : 네 개의 프로세스에 각각 네 개의 프로세스 서술자, 프로세스간 일부 자원 공유  \r\n\t다른 OS : 하나의 프로세스 서술자 안에 네 개의 스레드 가리키는 정보, 주소 공간이나 사용 중인 파일 등 공유 자원 정보는 서술자 내에 존재  \r\n\t=> 리눅스가 매우 명쾌한 구조  \r\n\r\n\r\n##스레드 생성\r\n\r\n스레드는 정상적인 태스크와 마찬가지 방식으로 만들어짐  \r\n다만, clone() 시스템 호출 시 특정 자원 공유하도록 플래그 지정해줌  \r\n```c\r\nclone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);\r\n```\r\n\r\n위의 코드는 주소 공간, 파일시스템 자원, 파일 서술자, 시그널 핸들러 공유한다는 점 제외하면 정상적 fork() 시스템 호출과 결과가 같음  \r\n즉, 새 태스크와 그 부모 프로세스는 흔히 말하는 스레드 관계가 됨  \r\n\r\n반면, 일반적인 fork()는 다음과 같은 방식으로 구현됨\r\n```c\r\nclone(SIGHAND,0);\r\n```\r\n\r\nvfork()는 다음과 같이 구현됨\r\n```c\r\nclone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0);\r\n```\r\n\r\nclone()에 넘겨주는 플래그를 통해 새로운 프로세스의 동작을 정의   \r\n부모 프로세스와 자식 프로세스간에 공유할 자원을 자세히 지어함  \r\nclone에서 사용하는 플래그는 <linux/sched.h>에 정의되어 있음 \r\n\r\n***\r\n\r\n__clone()의 시스템 호출 플래그__\r\n\r\n|플래그|의미|\r\n|:--------|:--------|\r\n|CLONE_FILES|부모 프로세스와 자식 프로세스간 사용 중인 파일 공유|\r\n|CLONE_FS|부모 프로세스와 자식 프로세스간 파일시스템 정보를 공유|\r\n|CLONE_IDLETASK|PID를 0으로 설정(유휴 상태의 태스크에서만 사용)|\r\n|CLONE_NEWNS|자식 프로세스를 위한 새 네임스페이스 생성|\r\n|CLONE_PARENT|자식 프로세스가 부모 프로세스와 동일한 부모를 가지도록 설정|\r\n|CLONE_PTRACE|자식 프로세스에 대해서도 추적 기능을 활성화|\r\n|CLONE_SETTID|TID(Thread ID)를 사용자 공간에도 기록|\r\n|CLONE_SETTLS|자식 프로세스를 위한 새 TLS(스레드별 저장공간 thread-local storage)를 생성|\r\n|CLONE_SIGHAND|부모 프로세스와 자식 프로세스간 시그널 핸들러 및 시그널 차단 사항을 공유|\r\n|CLONE_SYSVSEM|부모 프로세스와 자식 프로세스간 시스템 V SEM_UNDO 방식을 공유|\r\n|CLONE_THREAD|부모 프로세스와 자식 프로세스가 동일한 스레드군에 속하게 설정|\r\n|CLONE_VFORK|vfork() 방식을 사용해 자식 프로세스가 깨울 때까지 부모 프로세스를 중지|\r\n|CLONE_UNTRACED|추적 프로세스가 자식 프로세스에 CLONE_PTRACE를 지정하지 못하게 함|\r\n|CLONE_STOP|프로세스를 TASK_STOPPED 상태에서 시작|\r\n|CLONE\\_CHILD_CLEARTID|자식 프로세스의 TID를 초기화|\r\n|CLONE\\_CHILD_SETTID|자식 프로세스의 TID를 설정|\r\n|CLONE\\_PARENT_SETTID|부모 프로세스의 TID를 설정|\r\n|CLONE_VM|부모 프로세스와 자식 프로세스간 주소 공간 공유|\r\n\r\n\r\n##커널 스레드\r\n\r\n커널도 일부 동작을 백그라운드에서 실행하는 것이 좋을 때가 있음  \r\n커널 공간에서만 존재하는 표준 프로세스인 커널 스레드 이용해 이런 작업 가능  \r\n커널 스레드와 정상 프로세스간 주요 차이점은 커널 스레드에는 주소 공간이 없다는 점(프로세스 주소 공간 가리키는 mm 포인터가 NULL임)  \r\n커널 스레드는 커널 공간에서만 동작하며 사용자 공간으로 컨텍스트 전환 안 일어남  \r\n하지만 정상 프로세스와 마찬가지로 커널 스레드도 스케줄링되며 선점 가능  \r\n\r\n리눅스는 일부 작업을 커널 스레드를 통해 처리함  \r\n대표적으로 __flush__ 및 __ksoftirqd__ 작업이 있음  \r\n`ps -ef` 명령 이용하면 리눅스 시스템의 커널 스레드 확인 가능  \r\n커널 스레드는 매우 많음  \r\n커널 스레드는 시스템 부팅 시 다른 커널 스레드에 의해 만들어짐  \r\n커널 스레드는 다른 커널 스레드를 통해서만 만들 수 있음  \r\n리눅스는 __kthreadd__ 커널 프로세스가 모든 커널 스레드를 만드는 방식으로 커널 스레드 관리함  \r\n\r\n새 커널 스레드 만들려면 <linux/kthread.h>에 정의된 다음 인터페이스 사용\r\n```c\r\nstruct task_struct *kthread_create(int (*threadfn) (void *data), void *data, const char namefmt[], ...)\r\n``` \r\n\r\nkthread 커널 프로세스는 clone() 시스템 호출을 이용해 새 태스크를 만듦  \r\n새로 만들어진 프로세스는 data 매개변수를 통해 전달된 threadfn 함수를 실행함  \r\n새 프로세스는 printf 스타일로 여러 개의 매개 변수로 형식화한 namefmt 문자열에 해당하는 이름 가짐  \r\n처음 프로세스는 실행할 수 없는 상태로 만들어짐  \r\nwake\\_up\\_process() 함수를 통해 명시적으로 깨워주지 않으면 실행되지 않음  \r\nkthread\\_run() 함수를 이용하면 실행 가능한 프로세스를 바로 만들 수 있음  \r\n\r\n```c\r\nstruct task_struct *kthread_run(int (*threadfn) (void *data), void *data, const char namefmt[], ...)\r\n```\r\n\r\n이 함수는 매크로로 구현되었고, kthread\\_create()와 wake\\_up\\_process()를 호출하는 단순한 함수  \r\n\r\n```c\r\n#define kthread_run(threadfn, data, namefmt, ...)\r\n({\r\n\tstruct task_struct *k;\r\n\r\n\tk = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);\r\n\tif (!IS_ERR(k))\r\n\t\twake_up_process(k);\r\n\tk;\r\n})\r\n\r\n```\r\n\r\n커널 스레드는 한번 시작되면 스스로 do\\_exit() 함수를 호출하거나, 커널의 다른 부분에서 kthread\\_create()가 반환한 task\\_struct 구조체의 주소와 함께 kthread\\_stop() 함수를 호출할 때까지 계속 실행됨  \r\n```c\r\nint kthread_stop(struct task_struct *k)\r\n```\r\n\r\n\r\n#프로세스 종료\r\n\r\n프로세스가 종료되면 커널은 프로세스가 가지고 있던 자원 반납 후 부모 프로세스에 자식 프로세스의 종료를 알려줌  \r\n\r\n일반적으로 프로세스 종료는 자발적 발생  \r\n프로세스가 준비됬을 때 명시적으로 exit() 함수를 호출하거나, 프로그램의 main 함수 반환 시에 묵시적으로 exit() 함수가 호출되면서(즉 main 함수를 반환하는 곳에 C 컴파일러가 exit() 함수를 호출하는 코드를 삽입) 종료 작업이 시작됨  \r\n물론 프로세스가 비자발적으로 종료되기도 함  \r\n위에 경우는 프로세스가 처리할 수도 무시할 수도 없는 시그널이나 예외를 만나는 경우가 해당  \r\n어떤 방식으로 프로세스가 종료되든 프로세스를 종료하는 일련의 작업이 kernel/exit.c에 정의된 do\\_exit() 함수를 통해 진행됨  \r\n\r\n1. task\\_struct 구조체의 flags 항목에 PF_EXITING 플래그를 설정함. \r\n2. del\\_timer\\_sync() 함수를 호출해 커널 타이머를 제거함. 이 함수가 반환되면, 대기 중인 타이머와 실행 중인 타이머가 없다는 것 보장됨.  \r\n3. BSD 방식의 프로세스 정보 기록 기능 사용 시 do\\_exit() 함수는 acct\\_update\\_integrals() 함수를 호출해 관련 정보 기록함. \r\n4. exit\\_mm() 함수를 호출해 해당 프로세스가 가지고 있는 mm\\_struct를 반환함. 다른 프로세스에서 이 주소 공간 사용하지 않으면(이 주소 공간 공유되어 있지 않으면) 커널은 해당 자원 해제함.\r\n5. exit\\_sem() 함수를 호출함. 프로세스가 IPC 세마포어를 얻기 위해 대기하고 있었다면, 이 시점에 대기 상태가 해제됨. \r\n6. exit\\_files() 및 exit\\_fs() 함수를 호출해 관련 파일 서술자 및 파일시스템의 참조 횟수를 줄임. 참조 횟수가 0이 되면 해당 객체를 사용하는 프로세스가 없다는 뜻이므로 해당 자원을 반환함.\r\n7. 태스크의 종료 코드를 task\\_struct의 exit\\_code 항목에 저장함. exit() 함수에서 지정한 값, 또는 커널의 종료 방식에 의해 종료 코드 값이 결정된다. 이 곳에 저장된 종료 코드 값은 부모 프로세스가 사용할 수 없음.\r\n8. exit\\_notify() 함수를 호출해 부모 프로세스에 시그널 보내고, 해당 프로세스가 속한 스레드군의 다른 스레드 또는 init 프로세스를 자식 프로세스의 새로운 부모로 설정함. task\\_struct 구조체의 exit\\_state 항목에 태스크 종료 상태를 EXIT\\_ZOMBIE로 설정함. \r\n9. do\\_exit() 함수는 schedule() 함수를 호출해 새로운 프로세스로 전환함. 이제 이 프로세스는 스케줄링 대상이 아니므로 이 코드가 종료되는 태스크가 실행하는 마지막 코드가 됨. do\\_exit() 함수는 반환 과정이 없음.\r\n\r\n이 시점에서 태스크와 관련된 모든 객체가 반환됨(이 태스크만 해당 자원 사용 시)  \r\n이 태스크는 더 이상 실행 가능하지 않고(실행할 주소 공간도 없어짐), EXIT\\_ZOMBIE 상태가 됨  \r\n종료된 태스크가 차지하고 있는 메모리는 커널 스택, thread\\_info 구조체, task\\_struct 구조체가 전부다  \r\n이제 태스크는 부모 프로세스에 전달이 필요한 정보를 보관하기 위해서만 존재함  \r\n부모 프로세스가 해당 정보를 처리하거나 커널이 정보가 더 이상 필요 없다고 알려주면 프로세스가 차지하고 있던 나머지 메모리도 차지하고 있던 나머지 메모리도 반환돼 시스템의 가용 메모리로 돌아감\r\n\r\n\r\n##프로세스 서술자 제거\r\n\r\ndo\\_exit() 함수가 완료되고 프로세스가 좀비 상태가 되어 더 이상 실행 가능하지 않더라도 프로세스 서술자는 여전히 남음  \r\n이는 종료 후에도 시스템이 자식 프로세스의 정보를 얻을 수 있게 해주기 위함  \r\n결국 프로세스 종료를 위한 정리작업과 프로세스 서술자 제거 작업은 분리된 별도의 작업  \r\n부모 프로세스가 종료된 자식 프로세스의 정보를 처리하거나 커널이 해당 정보가 필요 없다고 알려주면, 자식 프로세스의 task\\_struct 구조체에 할당된 메모리가 해제됨  \r\n\r\nwait() 계열 함수는 하나의 복잡한 wait4() 시스템 호출을 통해 구현되어 있음  \r\n기본적인 동작은 함수를 호출한 프로세스의 동작을 자식 프로세스가 종료될 때까지 정지시키는 것, 종료된 자식 프로세스의 PID 값을 반환값으로 가짐  \r\n또한 종료된 자식 프로세스의 종료 코드를 저장할 포인터도 제공함  \r\n\r\n프로세스 서술자에 할당된 메모리를 제거해야 할 때가 되면 release\\_task() 함수를 호출해 다음 작업을 수행함\r\n1. \\_\\_exit\\_signal() 함수를 호출하고, 이 함수는 \\_\\_unhash\\_process() 함수를 호출하며, 이어서 detach\\_pid() 함수에서 해당 프로세스를 __pidhash__와 태스크 리스트에서 제거함.\r\n2. \\_\\_exit\\_signal() 함수는 종료된 프로세스가 사용하던 남은 자원 반환하고, 통계값과 기타 정보를 기록함.\r\n3. 해당 태스크가 스레드군의 마지막 스레드였다면 대표 스레드가 좀비가 된 것이므로, release\\_task() 함수는 대표 스레드의 부모 프로세스에 이 사실을 알림  \r\n4. release\\_task() 함수는 put\\_task\\_struct() 함수를 호출해 프로세스의 커널 스택 및 thread\\_info 구조체가 들어 있던 페이지를 반환하고, task\\_struct 구조체가 들어 있던 슬랩 캐시를 반환함\r\n\r\n이 시점에서 프로세스 서술자와 해당 프로세스와 연관된 모든 자원이 해제됨 \r\n\r\n\r\n##부모 없는 태스크의 딜레마\r\n\r\n부모 프로세스가 자식 프로세스보다 먼저 종료된 경우 다른 프로세스를 자식 프로세스의 부모로 지정하는 수단 반드시 필요함  \r\n그렇지 않으면, 부모를 잃고 종료된 프로세스는 영원히 좀비 프로세스로 남아 시스템 메모리 낭비하게 됨  \r\n해결책은 해당 프로세스가 속한 스레드군의 다른 프로세스를 부모 프로세스로 지정하거나, 이것이 불가능할 경우엔 init 프로세스를 부모 프로세스로 지정하는 것  \r\n\r\ndo\\_exit() 함수는 exit\\_notify() 함수를 호출하고, 이 함수에서 forget\\_original\\_parent() 함수를 호출함, 여기서 find\\_new\\_reaper() 함수를 호출하는데, 이 곳에서 부모 프로세스 재지정이 처리됨  \r\n\r\n```c\r\nstatic struct task_struct *find_new_reaper(struct task_struct *father)\r\n{\r\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\r\n\tstruct task_struct *thread;\r\n\r\n\tthread = father;\r\n\twhile_each_thread(father, thread) {\r\n\t\tif (thread->flags & PF_EXITING)\r\n\t\t\tcontinue;\r\n\t\r\n\tif (unlikely(pid_ns->child_reaper == father))\r\n\t\tpid_ns->child_reaper = thread;\r\n\treturn thread;\r\n\t}\r\n\r\n\tif (unlikely(pid_ns->child_reaper == father)) {\r\n\t\twrite_unlock_irq(&tasklist_lock);\r\n\t\tif (unlikely(pid_ns == &init_pid_ns))\r\n\t\t\tpanic(\"Attempted to kill init!\");\r\n\r\n\t\tzap_pid_ns_processes(pid_ns);\r\n\t\twrite_lock_irq(&tasklist_lock);\r\n\r\n\t\t// child_reaper 항목을 그대로 두거나 그냥 지워버릴 수 없음\r\n\t\t// children 포인터 내용 중에 EXIT_DEAD 상태인 태스크가\r\n\t\t// 들어있을 수 있으므로, forget_original_parent() 함수는\r\n\t\t// 이들을 어딘가로 옮겨야 함\r\n\r\n\t\tpid_ns->child_reaper = init_pid_ns.child_reaper;\r\n\t}\r\n\treturn pid_ns->child_reaper;\r\n}\r\n```\r\n\r\n위의 코드는 해당 프로세스가 속한 스레드군의 다른 태스크를 찾아봄  \r\n만약 스레드군에 다른 태스크가 없다면 init 프로세스를 찾아서 반환함  \r\n위 코드로 새 부모를 찾았으니, 모든 자식 프로세스의 부모 프로세스를 reaper로 다시 지정해주는 작업 필요함\r\n\r\n```c\r\nreaper = find_new_reaper(father);\r\nlist_for_each_entry_safe(p, n, &father->children, sibling) {\r\n\tp->real_parent = reaper;\r\n\tif (p->parent == father) {\r\n\t\tBUG_ON(p->ptrace);\r\n\t\tp->parent = p->real_parent;\r\n\t}\r\n\treparent_thread(p, father);\r\n}\r\n```\r\n\r\n그 다음 ptrace\\_exit\\_finish() 함수를 호출해 추적 기능을 사용하는 자식 프로세스에 대해 마찬가지로 부모 프로세스를 다시 지정해줌\r\n```c\r\nvoid exit_ptrace(struct task_struct *tracer)\r\n{\r\n\tstruct task_struct *p, *n;\r\n\tLIST_HEAD(ptrace_dead);\r\n\r\n\twrite_lock_irq(&tasklist_lock);\r\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry){\r\n\t\tif (__ptrace_detach(tracer, p))\r\n\t\t\tlist_add(&p->ptrace_entry, &ptrace_dead);\r\n\t}\r\n\twrite_unlock_irq(&tasklist_lock);\r\n\r\n\tBUG_ON(!list_empty(&tracer->ptraced));\r\n\r\n\tlist_for_each_entry_safe(p, n, &ptrace_dead, ptrace_entry) {\r\n\t\tlsit_del_init(&p->ptrace_entry);\r\n\trelease_task(p);\r\n\t}\r\n}\r\n```\r\n\r\n자식 프로세스 리스트와 추적 리스트 두 리스트가 만들어진 배경이 있음  \r\n태스크가 추적 상태에 있는 경우, 해당 프로세스는 디버깅 프로세스를 부모 프로세스로 임시 변경함  \r\n그러나 태스크의 원 부모 프로세스가 종료되면, 다른 형제 프로세스와 같이 새 부모 프로세스로 돌아갈 수 있어야 함  \r\n이전 커널에서는 이런 조치가 필요한 자식 프로세스를 찾기 위해 시스템의 모든 프로세스 조사함  \r\n이에 대한 해결책으로 나온 것이 추적 상태에 있는 자식 프로세스 리스트를 별도로 관리하는 간단한 방법  \r\n이를 통해 자식 프로세스를 찾으려고 모든 프로세스 리스트를 뒤지던 작업을 상대적으로 작은 두 개의 프로세스 리스트를 탐색하는 작업으로 줄임  \r\n\r\n부모 프로세스를 재지정하면, 좀비 프로세스가 남아 있을 위험성 사라짐  \r\ninit 프로세스는 주기적으로 wait() 함수를 호출해 자신에게 할당된 좀비 프로세스를 정리함  \r\n\r\n","fields":{"slug":"/리눅스 커널 (3) - 프로세스 관리/"},"frontmatter":{"title":"리눅스 커널 (3) - 프로세스 관리","published":true}}},{"node":{"rawMarkdownBody":"\r\n#커널 소스 구하기\r\n\r\n[http://www.kernel.org](http://www.kernel.org)\r\n\r\n\r\n[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\r\n\r\n\r\n\r\n#커널 소스 설치\r\n\r\nbzip2 형식 압축 해제  \r\n`$ tar xvjf linux-x.y.z.tar.bz2`  \r\n\r\n\r\nGNU zip 형식 압축 해제  \r\n`$ tar xvzf linux-x.y.z.tar.gz`  \r\n\r\n\r\n* 커널 소스는 보통 /usr/src/linux에 설치된다. 여기 접근하려면 루트 권한 필요, 새 커널 설치 시에만 루트 권한 사용하여 접근하고 그때에도 이 디렉토리 내용은 건드리면 안된다.\r\n\r\n\r\n\r\n#패치\r\n\r\n점증적 패치를 적용하려면,   \r\n`$ patch -p1 < ../patch-x.y.z`  \r\n\r\n\r\n#커널 소스 트리\r\n\r\n| 디렉토리 | 설명 |\r\n| :-------- | :-------- |\r\n| arch | 특정 아키텍처와 관련된 소스 |\r\n| block | 블록 입출력 계층 |\r\n| crypto | 암호화 API |\r\n| Documentation | 커널 소스 문서 |\r\n| drivers | 장치 드라이버 |\r\n| firmware | 특정 드라이버를 사용할 때 필요한 장치 펌웨어 |\r\n| fs | 가상 파일시스템 및 개별 파일시스템 |\r\n| include | 커널 헤더 파일 |\r\n| init | 커널 시작 및 초기화 관련 코드 |\r\n| ipc | 프로세스 간 통신 관련 코드 |\r\n| kernel | 스케줄러와 같은 핵심 커널 서브시스템 |\r\n| lib | 유틸리티 루틴 |\r\n| mm | 메모리 관리 서브시스템 및 가상 메모리 |\r\n| net | 네트워크 서브시스템 |\r\n| samples | 예제, 데모 코드 |\r\n| scripts | 커널을 빌드하는 데 사용하는 스크립트 | \r\n| security | 리눅스 보안 모듈 |\r\n| sound | 사운드 서브시스템 |\r\n| usr | 초기 사용자 공간 코드 initramfs |\r\n| tools | 리눅스 개발에 유용한 도구 |\r\n| virt | 가상화 기반 구조 |\r\n\r\n* 소스트리 최상위에 있는 파일 : COPYING 파일은 커널 저작권 파일, CREDITS 파일에는 커널 개발 기여 개발자 명단, MAINTAINERS 파일에는 커널 서브시스템과 드라이버를 관리하는 사람들 명단, Makefile은 커널의 기본 __Makefile__\r\n\r\n\r\n#커널 설정\r\n\r\n커널 설정 옵션은 __CONFIG__으로 시작하는 CONFIG\\_FEATURE과 같은 형태  \r\ne.g.) CONFIG\\_SMP : SMP 지원 여부  \r\n\r\n두가지 혹은 세가지 설정 값(보통 드라이버의 경우 세 가지 선택이 가능)을 지님.  \r\n\r\n__yes__ or __no__ (or __module__)  \r\n\r\n__module__ 값을 가지는 경우 해당 기능은 모듈 형태(동적으로 로드할 수 있는 별도 오브젝트)로 컴파일된다.  \r\n\r\n설정 옵션은 문자열이나 숫자가 될 수도 있음  \r\n이런 옵션은 빌드과정을 조절하는 데 사용하지 않음  \r\n전처리 매크로를 통해 커널 소스가 참조하는 값을 지정하는 데 사용  \r\n정적으로 배열 크기를 지정하는 옵션이 그러한 예  \r\n\r\nUbuntu용으로 Canonical에서 제공하거나, Fedora용으로 Red Hat에서 제공하는 것과 같은 벤더 커널은 컴파일된 상태로 배포본에 들어 있다. \r\n이런 커널에는 많이 사용하는 커널 기능이 모두 들어 있음.  \r\n거의 모든 드라이버를 모듈 형태로 컴파일함.  \r\n이렇게 하면, 모듈을 통해 다양한 하드웨어를 지원하는 기본 커널로 사용 가능  \r\n스스로 커널을 컴파일하고, 어떤 모듈을 포함시킬 것인지 제외할 것인지 배워나가야 한다.\r\n\r\n커널은 설정을 조절하는 여러 가지 도구를 제공  \r\n가장 간단한 도구로 텍스트 기반의 명령행 도구가 있다   \r\n\r\n```$ make config```  \r\n\r\n이 도구는 각 옵션을 하나씩 돌아가면서 대화식으로 사용자에게 yes, no, (세 가지 선택 가능 시) module 중에서 어떤 선택을 할지 물어본다.  \r\n이는 시간이 아주 오래 걸리는 일이므로 시간당 급여를 받는 상황이 아니라면 ncurses 라이브러리 사용하는 그래픽 환경의 도구를 이용하는 편이 좋다. \r\n\r\n```$ make menuconfig```\r\n\r\n또는 gtk+ 기반의 그래픽 환경 도구를 이용할 수도 있다.\r\n\r\n```$ make gconfig```\r\n\r\n이 두가지 도구는 다양한 설정 옵션을 '프로세서 형식 및 기능' 등의 항목으로 분류해 보여줌.  \r\n각 분류항목을 오가면서 커널 옵션을 확인하고 값을 변경할 수 있다. \r\n\r\n다음 명령은 아키텍처에 맞는 기본 설정을 만들어 줌  \r\n\r\n```$ make defconfig```\r\n\r\n이렇게 만들어진 기본 값은 다소 임의적이기는 하지만(i386의 경우 리누스가 사용하는 설정 값이라는 소문 있음.)  \r\n커널을 설정해본 적이 없는 경우에는 좋은 출발점이 될 수 있을 것이다.  \r\n빨리 빌드해서 실행해보고 싶다면, 이 명령을 실행한 다음 하드웨어에 필요한 옵션이 설정되었는지 확인하자.  \r\n\r\n옵션 설정은 커널 소스 트리의 최상위에 있는 .config 파일에 저장된다. (대부분의 커널 개발자가 그렇듯이)  \r\n이 파일을 직접 수정하는 편이 쉽게 느껴질 수 있음.  \r\n이 파일에서 설정 옵션을 찾아 값을 변경하는 일이 그다지 어렵지 않기 때문  \r\n설정파일을 직접 변경한 경우나, 기존의 설정 파일을 새 커널 트리에 사용하는 경우에는 다음 명령을 이용해 설정 확인 및 갱신 가능  \r\n\r\n```$ make oldconfig```\r\n\r\n커널을 빌드하기 전에 항상 이 명령을 실행해야 한다.  \r\nCONFIG\\_IKCONFIG\\_PROC 설정 옵션을 사용하면 전체 커널 설정 파일을 압축해서 /proc/config.gz 파일에 저장한다.  \r\n이를 이용하면 새 커널을 빌드할 때 현재 사용하는 설정을 쉽게 복사 가능  \r\n현재 커널이 이 옵션을 사용하고 있다면, 다음과 같은 방법으로 /proc에 있는 설정 파일을 이용해 새 커널을 빌드할 수 있다.  \r\n\r\n```\r\n$ zcat /proc/config.gz > .config\r\n$ make oldconfig\r\n```\r\n\r\n어떤 방식으로든 커널 설정을 마쳤다면, 다음 명령으로 간단하게 커널을 빌드할 수 있다. \r\n\r\n```$ make```\r\n\r\n이전 버전 커널과는 달리 2.6에서는 의존성 정보 자동 관리됨. => 커널 빌드하기 전 make dep 명령 실행 필요 없음  \r\n또한, bzImage와 같은 특정 빌드 형식을 지정하거나 모듈을 별도로 빌드하지 않아도 된다.  \r\nMakefile이 기본적인 모든 것을 처리함\r\n\r\n\r\n#빌드 메시지 최소화\r\n\r\n빌드 시 쏟아지는 메시지를 최소화하면서도 경고나 오류 메시지를 놓치지 않으려면 make의 출력을 리다이렉트한다.\r\n\r\n```$ make > ../detritus```\r\n\r\n빌드 과정의 출력 메시지를 보고 싶다면 저장된 파일을 보면 된다.  \r\n하지만 경고와 오류 메시지는 표준 에러 장치로 출력되므로 대개 이 파일을 볼 일은 없다.  \r\n대신 다음을 실행  \r\n\r\n```$ make > /dev/null```\r\n\r\n이렇게 하면 모든 불필효한 출력을 다시는 돌아오지 못하는 커다란 하수구인 /dev/null로 보낸다. \r\n\r\n\r\n\r\n#빌드 작업을 동시에 여러 개 실행\r\n\r\nmake 프로그램에는 빌드 과정을 여러 개의 병렬 작업으로 분리해 주는 기능이 있다.  \r\n각각의 작업은 별도로 동시에 실행되므로 다중 프로세서 시스템에서는 빌드 속도를 크게 향상시킬 수 있다.  \r\n커다란 소스를 빌드하는 경우에는 입출력 대기 시간(프로세스가 입출력 요청이 완료되기를 기다리는 시간)이 차지하는 비중이 높으므로 이 기능을 이용해 프로세스 이용도 높일 수 있음  \r\n\r\nMakefile의 의존성 정보가 잘못되어 있는 경우가 너무나 많아 기본적으로는 make는 하나의 작업만 생성한다.  \r\n잘못된 의존성 정보하에서 여러 개의 작업을 생성하면 다른 작업에 영향을 미쳐 전체 빌드 과정에서 오류가 발생할 수 있기 때문 \t\r\n커널 Makefile의 의존성 정보는 정확하므로 여러 개의 작업을 생성해도 문제가 발생하지 않는다.  \r\n다중 make 작업을 통해 커널을 빌드하려면 다음 명령을 이용  \r\n\r\n`$ make -jn`\r\n\r\n여기서 n은 생성할 작업의 개수 의미  \r\n일반적으로 프로세서 하나당 하나 또는 두 개의 작업을 생성하는 것이 적당  \r\n예를 들어 16코어 장비라면 다음과 같이 실행 가능  \r\n\r\n`$ make -j32 > /dev/null`\r\n\r\ndistcc 또는 ccache와 같은 도구 사용 시 커널 빌드 시간을 극적으로 줄일 수 있다. \r\n\r\n\r\n#새 커널 설치\r\n\r\n커널을 빌드하고 나면 커널 설치해야 함  \r\n설치 방법은 아키텍처 및 부트 로더에 따라 다르므로 커널 이미지를 어디에 복사하고, 해당 이미지로 부팅하려면 어떻게 해야 하는지 부트 로더 사용법 참고  \r\n새 커널이 문제를 일으킬 수 있으므로 안전한 것으로 확인된 커널 한두 개를 사용할 수 있도록 해두는 것을 잊지 말 것  \r\n예를 들어, grub을 사용하는 x86 시스템이라면 arch/i386/boot/bzImage 파일을 /boot 디렉토리 안에 vmlinuz-version 같은 이름으로 넣어두고, /boot/grub/grub.conf 파일을 수정해 새 커널을 위한 항목을 추가  \r\n__LILO__를 사용해 부팅하는 시스템이라면 /etc/lilo.conf 파일을 편집하고 lilo 명령을 실행한다.  \r\n\r\n모듈 설치는 자동화되어 있고, 아키텍처에 따른 차이가 없음  \r\n루트 권한으로 다음 명령을 실행하기만 하면 된다.  \r\n\r\n`% make modules_install`\r\n\r\n이렇게 하면 컴파일된 모듈들이 정해진 위치인 /lib/modules 디렉토리에 설치된다.  \r\n빌드 과정에서 커널 소스 트리 최상위에 System.map 파일이 만들어진다.  \r\n이 파일에는 각 커널 심볼의 시작 주소의 위치를 찾을 수 있는 테이블이 들어 있다.  \r\n디버깅 시에 이 정보를 이용해 메모리 주소 값을 그에 해당하는 함수나 변수 이름으로 변환해서 보여줄 수 있음  \r\n\r\n# 다른 성질의 야수\r\n\r\n리눅스 커널은 일반적인 사용자 공간 애플리케이션과 다른 몇 가지 독특한 특징 존재  \r\n이런 차이가 커널 개발 작업을 사용자 프로그램 개발 작업과 다르게 만듬  \r\n\r\n다른 규칙이 적용됨  \r\n당연해 보이는 차이점도 있지만, 명확해 보이지 않는 차이점도 존재\r\n\r\n* 커널은 C 라이브러리나 표준 C 헤더 파일을 사용할 수 없다. \r\n* 커널은 GNU C를 사용한다.\r\n* 커널에는 사용자 공간에서와 같은 메모리 보호 기능이 없다. \r\n* 커널은 부동소수점 연산을 쉽게 실행할 수 없다.\r\n* 커널은 프로세스당 고정된 작은 크기의 스택을 사용한다.\r\n* 커널은 비동기식 인터럽트를 지원하며, 선점형이며, 대칭형 다중 프로세싱을 지원하므로 커널 내에서는 동기화 및 동시성 문제가 매우 중요하다.  \r\n* 이식성이 중요하다. \r\n\r\n# lib와 표준 헤더 파일을 사용할 수 없음\r\n\r\n사용자 공간 애플리케이션과 달리, 커널은 표준 C 라이브러리(또는 그 외의 라이브러리)와도 링크되지 않음  \r\n주요한 이유는 속도와 크기 때문  \r\n전체 C 라이브러리, 아니면 그 중요 일부분이라도 커널 입장에서는 너무 크고 비효율적  \r\n대신 일반적인 libc 함수의 상당수는 커널 안에 구현되어 있으므로 안심해도 좋음  \r\n예를 들어, 보통의 문자열 처리 함수는 lib/string.c에 들어 있음  \r\n<linux/string.h> 헤더 파일 추가 시 해당 함수 사용 가능 \r\n\r\n* 여기서 헤더 파일은 커널 소스 트리 안에 있는 커널 헤더 파일 일컬음.  \r\n  커널 소스에서 외부 라이브러리를 사용할 수 없는 것과 마찬가지로 커널 소스는 외부 헤더 파일을 사용 불가  \r\n  기본 파일은 커널 소스 트리 최상위의  include/ 디렉토리에 있음.  예를 들어, <linux/inotify.h>에 해당하는 파일은 커널 소스 트리의 include/linux/inotify.h에 있다.\r\n  아키텍처별 특정 헤더 파일은 커널 소스 트리의 arch/(아키텍처)/include/asm 디렉토리에 있음.  \r\n  e.g. x86 아키텍처 => arch/x86/include/asm 디렉토리에 있음  \r\n  이 곳의 헤더 파일을 사용하는 경우에는 <asm/ioctl.h>처럼 asm/ 접두사만 사용하면 된다. \r\n\r\n\r\n빠진 함수 중 가장 익숙한 함수 printf()  \r\n커널 코드는 printf()를 사용할 수 없는 대신 printk() 함수를 제공,  \r\n이 함수는 아주 익숙한 printf 함수와 거의 같은 방식으로 작동  \r\nprintk 함수는 형식화한 문자열을 커널 로그 버퍼에 복사하며, 이 메시지는 보통 __syslog__ 프로그램이 처리  \r\n사용법은 printf() 함수와 유사\r\n\r\n```c\r\nprintk(\"Hello wolrd! A string '%s' and an integer '%d'\\n\", str, i);\r\n```\r\n\r\nprintf 함수와 printk 함수 사이의 주목할 만한 차이점 하나는 printk 함수에는 우선순위 플래그를 줄 수 있다는 점이다.  \r\n이 플래그를 통해 syslogd(데몬 프로그램)가 커널 메시지를 어느 곳에 표시할지를 결정할 수 있다.  \r\n이 기능을 사용하는 예를 들어보면 다음과 같다.  \r\n\r\n```c\r\nprintk(KERN_ERR \"this is an error!\\n\");\r\n```\r\n \r\nKERN\\_ERR과 출력 메시지 사이에 쉼표가 없는 점에 주의  \r\n이는 의도된 표현 방식  \r\n우선순위 플래그는 문자형으로 표시된 선처리 지시자로 컴파일 과정에서 출력 메시지와 합쳐진다.  \r\n\r\n# GNU C\r\n\r\n리눅스 커널은 유닉스 커널과 마찬가지로 C로 프로그램 되어 있음.  \r\n커널은 엄격한 ANSI C로 되어있지 않고, 대신 개발자들은 필요하다고 생각되는 곳에 __gcc__GNU Compiler Collection (커널 및 리눅스 시스템에 있는 C로 작성된 다른 거의 모든 프로그램 컴파일 시 사용하는 C 컴파일러)가 제공하는 다양한 언어 확장 기능 사용  \r\n\r\n커널 개발자들은 C 언어의 ISO C99과 GNU C 확장 기능 모두 사용  \r\ngcc의 기능을 충분히 지원하는 최근 버전의 Intel C 컴파일러로도 리눅스 커널을 컴파일할 수 있지만,  \r\n이런 점들로 인해 리눅스 커널은 gcc 편향되 있음  \r\n지원하는 가장 오래된 gcc 버전은 3.2이며, 4.4 이후 버전을 권장  \r\nISO C99는 C 언어의 공식적인 개정판으로 기존과 큰 차이 없으므로 다른 코드에서도 서서히 이용되는 추세  \r\n표준 ANSI C에 비해 더 생소한 확장 기능은 GNU C가 제공하는 확장 기능들  \r\n\r\n##인라인 함수\r\n\r\nC99와 GNU C 모두 인라인 함수를 지원  \r\n인라인 함수는 이름으로 짐작할 수 있듯이 각 함수 호출이 일어나는 자리의 줄 안에 삽입되는 함수  \r\n이 기능을 통해 함수 호출과 반환 시에 발생하는 부가 비용(레지스터를 저장, 복원 등)을 제거 가능  \r\n컨파일러가 함수를 호출하는 코드와 호출되는 코드를 하나로 보고 최적화 가능해 더 정교한 최적화가 가능  \r\n함수의 내용이 호출하는 자리에 복사되어 들어가기 때문에 코드의 크기가 커지며,  \r\n이로 인해 메모리 사용량과 명령어 캐시 사용량이 늘어남  \r\n커널 개발자들은 일부 실행시간이 중요한 함수에 대해 인라인 함수 사용  \r\n\r\n큰 함수를 인라인으로 만드는 일은 해당 함수가 특별히 자주 사용되거나 실행시간에 극히 민감한 경우가 아니라면 피하는 것 권장  \r\n\r\n인라인 함수는 함수 정의부분에 static과 inline 지시어를 사용해 선언  \r\n\r\n```c\r\nstatic inline void wolf(unsigned long tail_size)\r\n```\r\n\r\n인라인 함수 정의는 함수를 사용하기 전에 해야 함. 그렇지 않으면 컴파일러가 함수를 인라인으로 만들 수 없음.  \r\n인라인 함수를 헤더 파일에 두고 사용하는 것이 일반적.  인라인 함수는 static으로 지정했으므로 외부에서 사용 불가.  \r\n인라인 함수가 한 파일에서만 사용된다면 해당 파일의 최상단에 둘 수 있음.  \r\n\r\n커널에서는 형__type__ 보호 및 가독성 등의 이유로 복잡한 매크로를 사용하는 것보다 인라인 함수를 사용하는 것을 선호  \r\n   \r\n##인라인 어셈블리\r\n\r\ngcc C 컴파일러는 일반적인 C 함수 안에 어셈블리 명령을 삽입하는 기능을 제공  \r\n이 기능은 특정 시스템 아키텍처에서만 사용하는 커널 소스에서 사용  \r\n\r\n인라인 어셈블리 이용 시 asm() 컴파일러 지시자 사용  \r\ne.g. x86 프로세서의 rdtsc 명령 실행해서 타임스탬프 레지스터(tsc) 내용 받아오는 코드\r\n```c\r\nunsigned int low, high;\r\nasm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\r\n/* 이제 low와 high에는 각각 64비트 tsc의 하위 32비트, 상위 32비트의 값이 들어간다. */\r\n```\r\n\r\n리눅스 커널은 C와 어셈블리를 혼합해서 작성되어 있는데, 어셈블리는 주로 하부 아키텍처와 관련되어 있거나 빠른 속도를 요하는 부분에서 사용  \r\n대부분의 커널 코드는 C로 작성 되어 있음  \r\n\r\n\r\n##분기 구문 표시 \r\n\r\ngcc C 컴파일러는 분기 시에 어느 쪽이 발생할 가능성이 높은지를 이용해 분기 구문을 최적화하는 내장 지시자를 가지고 있음  \r\n컴파일러는 이 지시자를 이용해 분기를 예측 가능  \r\n커널은 이 지시자를 사용하기 쉽게 likely()와 unlikely()라는 매크로로 만들어 사용  \r\n\r\n다음과 같은 코드에서\r\n```c\r\nif (error) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n다음과 같은 방식으로 이 분기가 거의 실행되지 않음을 표시 가능 \r\n\r\n```c\r\n/* error 값이 거의 항상 0일 것으로 생각 가능 */\r\n⁭if (unlikely(error)) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n반면, 항상 실행될 것 같은 경우\r\n\r\n```c\r\n/* success 값은 거의 항상 0이 아닐 것으로 간주 */\r\nif (likely(error)) {\r\n\t/* ... */\r\n}\r\n```\r\n\r\n분기의 방향이 거의 대부분 알려진 한 방향으로만 일어나는 경우, 또는 다른 경우를 무시하고 한 가지 경우에 대해서만 최적화가 필요한 경우 이 지시자 사용  \r\n매우 중요한 사항으로, 이 지시자 오용 시에 심각한 성능저하  \r\n일반적으로는 앞에서 봤듯이 오류가 발생하는 상황에서 unlikely()와 likely()를 사용  \r\n특별히 예외를 처리하기 위해 if 문을 사용하는 경우 많음,  \r\n커널에서도 주로 unlikely() 지시자 사용  \r\n\r\n##메모리 보호 없음 \r\n\r\n사용자 공간 애플리케이션이 메모리 접근을 잘못하면, 커널은 오류를 탐지해 SIGSEGV 시그널을 보내고 프로세스 종료.  \r\n하지만 커널이 메모리 접근을 잘못한 경우에는 이를 제어하기 어려움  \r\n커널에서의 메모리 침범은 중대한 커널 오류인 oops를 발생시킴  \r\nNULL 포인터 참조와 같이 잘못된 메모리 접근을 해서는 안 된다는 것은 당연하지만 커널에서 그 위험성이 훨씬 큼.\r\n\r\n또한 커널 메모리는 페이징 기능 사용 불가  \r\n커널에서 사용하는 모든 메모리는 실제 물리적인 메모리에 해당  \r\n나중에 커널에 새로운 기능을 추가해야 한다면 이 점 명심해야 함  \r\n\r\n##부동 소수점 쉽게 사용 불가\r\n\t\r\n사용자 공간 애플리케이션이 부동 소수점 연산을 사용할 경우, 커널이 정수와 부동 소수점 연산 모드 전환 관리  \r\n부동 소수점 연산 이용 시 커널이 해야 하는 일은 아키텍처에 따라 다르지만,   \r\n보통 커널이 트랩을 받아 정수 연산에서 부동 소수점 연산 모드로 전환하는 방식으로 동작  \r\n\r\n사용자 공간과 달리 커널은 자신의 트랩을 받을 수 없어 깔끔한 부동 소수점 전환 기능 이용 불가  \r\n커널 내에서 부동 소수점을 사용하려면 수동으로 부동 소수점 레지스터를 저장하고 복원하는 등 잡다한 일을 직접 해야 함.  \r\n사용하지 말아야 함. 아주 드문 경우 제외, 커널에서 부동 소수점 연산 사용 안 함.\r\n\r\n##작은 고정 크기의 스택\r\n\r\n사용자 공간에서는 스택에 커다란 구조체나 수 천 개 크기의 배열 등 많은 변수 정적 할당 가능  \r\n사용자 공간에는 동적으로 확장 가능한 커다란 스택이 있기 때문에 가능  \r\nDOS 같은 구식 OS 경우 사용자 공간에서도 고정 크기 스택 쓰기 때문에 문제 될 수는 있음  \r\n\r\n커널이 사용하는 스택은 크지도 않고, 동적으로 확장 불가  \r\n커널 스택의 정확한 크기는 아키텍처에 따라 다름  \r\nx86 아키텍처의 경우 : 컴파일 시에 4KB 또는 8KB로 정할 수 있음  \r\n관습적으로 커널 스택은 두 페이지로 구성하므로, 이는 커널 스택의 크기가 32비트 아키텍처에서는 8KB, 64비트 아키텍처에서는 16KB로 고정 되 있으며, 바꿀 수 없음을 의미  \r\n각 프로세스별로 각자의 스택이 할당됨  \r\n\r\n##동기화와 동시성\r\n\r\n커널은 경쟁 상태__race condition__에 놓이기 쉬움.  \r\n단일 스레드의 사용자 공간 애플리케이션과 달리, 커널은 공유 자원에 대한 동시 접근 허용해야 하므로 경쟁 방지하기 위한 동기화 필요\r\n\r\n다음과 같은 경우 존재  \r\n* 리눅스는 선점형 멀티태스킹 OS. 커널의 프로세스 스케줄러에 의해 프로세스의 실행 순서가 조정됨. 커널은 이 작업들 간의 동기화를 책임져야 함.\r\n* 리눅스는 대칭형 다중 프로세서(SMP) 지원. 따라서 적절한 보호 장치 없으면 동일한 자원에 하나 이상의 프로세스가 동시에 접근하는 커널 코드 실행할 수 있음. \r\n* 현재 실행하고 있는 코드와 상관없이 비동기식으로 인터럽트가 발생. 따라서 적절한 보호 장치 없을 시 자원 사용 도중 인터럽트가 발생하고 인터럽트 핸들러에서 같은 자원에 접근하는 상황 발생 가능.  \r\n* 리눅스 커널은 선점형. 따라서 적절한 보호 장치가 없을 시 같은 자원에 접근하는 다른 커널 코드가 실행 중인 커널 코드를 선점하는 일이 발생 가능. \r\n\r\n경쟁 상태 해결하는 전형적인 해법은 스핀락__spinlock__이나 세마포어__semaphore__를 이용하는 것.  \r\n\r\n##이식성의 중요성 \r\n\r\n사용자 공간 애플리케이션은 이식성이 그다지 중요하지 않을 수 있음  \r\n리눅스는 이식성이 좋은 OS이며, 그 특성 유지해야 함.  \r\n이는 아키텍처 독립적인 C 코드가 여러 다양한 시스템에서 컴파일되고 실행되어야 한다는 의미이며,  \r\n커널 소스 트리에서 아키텍처 독립적인 코드는 특정 시스템에 의존적인 코드와 적절하게 분리되어 있어야 한다는 뜻.  \r\n\r\n엔디언 중립성, 64비트 지원, 워드 및 페이지 크기 지정 등 몇 가지만 설명해도 방대함.\r\n\r\n##결론\r\n\r\n커널에는 고유한 특징 존재  \r\n커널은 자신만의 규칙을 사용하며 전체 시스템을 관리하는 만큼 분명 그에 따르는 위험도 큼  \r\n하지만 리눅스 커널의 복잡도와 진입장벽은 여타 대규모 소프트웨어 프로젝트와 질적으로 크게 다르지 않음  \r\n\r\n리눅스 개발에 있어 가장 중요한 단계는 커널이 두려움의 존재가 아니라는 것을 깨닫는 것.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/리눅스 커널 (2) - 빌드와 설치, 주의사항/"},"frontmatter":{"title":"리눅스 커널 (2) - 빌드와 설치, 주의사항","published":true}}},{"node":{"rawMarkdownBody":"\r\nLatex 문법으로 수식 표현을 간단하게 할 수 있는 플러그인으로 Katex, MathJax 두 가지가 있는데,  \r\n\r\nMathJax는 dependency도 많고 Katex가 렌더링이 체감될 정도로 빠르므로 Katex 플러그인으로 수식표기를 하기로 결정했다.\r\n\r\n \r\n\r\nKatex 플러그인을 Gatsby 블로그에 적용하기 위해서 우선,  \r\n\r\n`$ npm install --save gatsby-remark-katex katex`  \r\n또는  \r\n`$ yarn add gatsby-remark-katex katex`  \r\n을 통해 katex를 설치해준다.  \r\n\r\nKatex 플러그인을 사용하기 위해 __gatsby-transformer-remark__ 플러그인이 필요한데, 마크다운 설정이 미리 되어있다면 이미 설치되어있을 수 있다.  \r\n\r\n\r\n###gatsby-config.js\r\n```js\r\nmodule.exports = {\r\n  // \r\n  plugins: [\r\n    \r\n    {\r\n      resolve: `gatsby-transformer-remark`,\r\n      options: {\r\n        plugins: [\r\n          \r\n          {\r\n            resolve: `gatsby-remark-katex`,\r\n            options: {\r\n              // Add any KaTeX options from https://github.com/KaTeX/KaTeX/blob/master/docs/options.md here\r\n              strict: `ignore`,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    \r\n  ],\r\n}\r\n```\r\n__gatsby-transformer-remark__ 안에 __gatsby-remark-katex__이 들어가는 꼴로 작성해야 한다.\r\n\r\n\r\n***\r\n\r\n\r\n[공식문서](https://www.gatsbyjs.org/packages/gatsby-remark-katex)에   \r\n\r\nAdd Katex CSS to your template: Katex’s CSS file is required to render the formulas correctly. \r\nInclude the CSS file in your template (example):\r\n\r\n``require(`katex/dist/katex.min.css`)``  \r\n\r\n__katex.min.css__를 참조할 수 있도록 조치하라고 되어있는데,  \r\n\r\nblog post를 띄우는 __src/templates/(포스트 관련.js)__ 파일 안에\r\n\r\n나의 경우에는 `import '../../../node_modules/katex/dist/katex.min.css';`를 추가하여 해결하였다.\r\n\r\n\r\n***\r\n\r\n이제 Katex가 적용된다.\r\n\r\n'$' 문자 하나 사이에 표현하는 inline,\r\n두개 사이에 표현하는 block 방식으로 사용할 수 있다.\r\n\r\n`$a^2 + b^2 = c^2$ 인라인`  \r\n\r\n$a^2 + b^2 = c^2$ 인라인\r\n\r\n```\r\n$$\r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n```\r\n$$\r\na^2 + b^2 = c^2   \r\na^2 + b^2 = c^2  \r\na^2 + b^2 = c^2  \r\n$$ 블록\r\n\r\n","fields":{"slug":"/Gatsby 블로그 수식 표현 플러그인 Katex 적용법/"},"frontmatter":{"title":"Gatsby 블로그 수식 표현 플러그인 Katex 적용법","published":true}}},{"node":{"rawMarkdownBody":"\r\nnpm 설치를 위해 node.js 설치하는 과정에서 \r\n\r\n__C:\\Users\\\\(계정이름)\\AppData\\Roaming\\npm-cache\\\\_libvips__ 의\r\n\r\n__libvips-8.7.4-win32-x64.tar.gz__ 파일이 누락됨.   \r\n(__libvips-8.8.1-win32-x64.tar.gz__을 포함한 다른 버전도 동일.)\r\n\r\n네트워크 문제로 파일을 가져오는데에서 문제가 생긴 것으로 보임.\r\n\r\ngithub realese 페이지에서 직접 받아도 다운링크에 접속을 못하여\r\n\r\n구글링을 통해 libvips 압축파일을 정리해둔 링크를 찾아서 해결.  [http://18.176.30.221/list/libvips](http://18.176.30.221/list/libvips)\r\n\r\n\r\n이를 통해 npm install 명령 실행 도중 getaddrinfo EFNOTFOUND 오류가 나며\r\n\r\n링크에서 파일을 받지 못하는 경우 해결 할 수 있음. \r\n\r\n\r\n***\r\n\r\nnode-gyp 설치가 필요하다면,\r\n\r\n\r\n네이티브 애드온 모듈 컴파일링을 하는 __node-gyp__를 설치\r\n\r\n'node-gyp' is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js\r\n\r\n\r\n`$ npm install -g node-gyp`\r\n\r\n\r\n***\r\n\r\n\r\nnode.js를 윈도우에 설치하고서 필수 요소(python2.7 등) 자동 설치를 위한 빌드 툴을 설치해야함.  \r\n`$ npm install --global --production windows-build-tools`\r\n\r\n이번 블로그 적용 중에는 이 것으로 해결이 안되고 아래와 같은 문제가 생김.\r\n\r\n\r\n***\r\n\r\nnode.js 설치 시 파이썬 등 필수 요소 자동설치를 해줘야하는데 \r\n\r\n실패하여 npm이 Python v2.7을 찾지 못하는 경우 \r\n \r\n기본경로인 __C:\\python27__ 경로로 파이썬2.7을 설치해준다.\r\n\r\n\r\n***\r\n\r\nvisual studio가 2019 버전이라 MSBuild.exe ENOENT 에러가 나는 경우, \r\n\r\n빌드를 위해 Visual C++ Build tools의 2015 또는 2017 버전이 필요한데\r\n\r\n따라서 설치해주면 해결된다. [Visual C++ Build tools 설치](https://go.microsoft.com/fwlink/?LinkId=691126)\r\n\r\nwindows 8.1 sdk만 설치해주면 되고,\r\n\r\n`$ npm config set python python2.7`  \r\n`$ npm config set msvs_version 2015`\r\n\r\n위와 같이 컨픽을 설정해주면 에러 없이 빌드된다.\r\n\r\n이번 경우 npm install 시 이 에러 발생.\r\n\r\n- 참고 : [https://github.com/nodejs/node-gyp/issues/1747](https://github.com/nodejs/node-gyp/issues/1747)\r\n\r\n\r\n***\r\n\r\n```\r\n> gatsby develop\r\n\r\nThe above error occurred in the <StoreStateProvider> component:\r\n    in StoreStateProvider\r\n    in App\r\n```\r\n\r\n위의 오류가 발생하는 경우  \r\n\r\nyarn 설치 후   \r\n\r\n`npm install --global yarn`  \r\n\r\ngatsby의 새 버전 재설치를 yarn으로 해주면  \r\n\r\n`yarn add gatsby`  \r\n\r\n\r\n다시 `gatsby develop`가 정상 작동한다.\r\n\r\n- 참고 : [https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201](https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201)\r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n","fields":{"slug":"/Gatsby 블로그 적용 도중 만난 에러/"},"frontmatter":{"title":"Gatsby 블로그 적용 도중 만난 에러","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n# 운영체제와 커널\r\n\r\n__운영체제__ : 정의 힘듬, but 기술적 관점 => 기본적인 사용과 관리 담당하는 시스템의 일부분\r\n - 커널, 장치 드라이버, 부트로더, 명령행 셸(동등 역할의 사용자 인터페이스 포함), 기본적인 파일 및 시스템 유틸리티 등  \r\n\r\n__시스템__ : 운영체제 + 그 위에서 동작하는 모든 애플리케이션 통틀음    \r\n\r\n__커널__ : (a.k.a 관리자supervisor, 코어core, 내부internals) \r\n - 인터럽트 핸들러, 스케줄러, 메모리 관리 시스템, 네트워크나 프로세스간 통신 처리하는 시스템 서비스 등     \r\n \r\n***\r\n \r\n__커널 공간__kernel-space : 보호 메모리 공간 사용, 제약 없는 하드웨어 접근 등이 가능  \r\n과  \r\n__사용자 공간__user-space :\r\n - 사용자 애플리케이션 실행됨/ 장비의 가용 자원 중 일부만 사용 가능 \r\n - 특정 시스템 함수 실행 가능, 하드웨어 직접 접근 및 커널이 할당한 영역 밖에 메모리 접근은 잘못된 동작  \r\n\r\n은 다른 (시스템)상태를 가짐     \r\n \r\n***\r\n\r\n\r\n커널 코드 실행 시 시스템은 커널 모드로 커널 공간에 있음  \r\n일반적인 프로세스 처리 시 시스템은 사용자 모드로 사용자 공간에 있음  \r\n\r\n실행 애플리케이션은 시스템 호출을 통해 커널과 통신  \r\n주로) 애플리케이션이 라이브러리 함수 호출 => 라이브러리가 시스템 호출 인터페이스 이용 커널이 애플리케이션을 대신해 필요한 작업 수행\r\n\r\n일부 라이브러리 호출은 시스템 호출에는 없는 여러 기능 제공하기도 함, 이 경우 커널 호출은 커다란 함수의 일부 한 단계가 됨     \r\n\r\n\r\nex) printf() : 데이터 출력 형식 지정 or 버퍼링 기능\r\n - 화면에 데이터 출력하기 위해 write() 시스템 호출 이용하는 것은 이 함수의 일부분\r\n\r\n일부 라이브러리 호출은 커널 호출과 일대일 대응\r\n\r\n한편, strcpy() 같은 C 라이브러리 함수는 커널 호출을 직접 사용하지 않음     \r\n\r\n\r\n\r\n* 애플리케이션이 시스템 호출을 실행하는 것을 애플리케이션을 대신에 커널이 실행 중이라고 표현\r\n* 또는 (= 애플리케이션이 커널 공간에서 시스템 호출을 실행 중 = 커널이 프로세스 컨텍스트를 실행 중)\r\n \r\n애플리케이션이 시스템 호출을 통해 커널을 이용하는 방식이 애플리케이션의 작업 수행의 기초적인 방식     \r\n\r\n***\r\n \r\n__커널은 시스템 하드웨어도 관리__ : 인터럽트 개념  \r\n__인터럽트__ : 종류는 숫자로 구분, 커널은 숫자로 인터럽트 처리, 응답할 인터럽트 핸들러 실행  \r\n - 커널이 동기화를 위해 새로운 인터럽트 블락 가능(모든 인터럽트 다 or 특정 인터럽트만)  \r\n - 리눅스 포함 대다수 운영체제 인터럽트 핸들러를 프로세스 컨텍스트에서 실행 안함  \r\n - 대신 프로세스와 분리되어 있는 별도의 인터럽트(전용) 컨텍스트에서 실행      \r\n \r\n \r\n \r\n컨텍스트는 커널의 활동 범주 나타냄  \r\n리눅스에서 프로세스는 세가지 중 한가지 일 하는 중\r\n - 사용자 공간에서 프로세스의 사용자 코드를 실행\r\n - 커널 공간의 프로세스 컨텍스트에서 특정 프로세스를 대신해 코드를 실행\r\n - 커널 공간의 인터럽트 컨텍스트에서 프로세스와 상관없이 인터럽트를 처리\r\n ex) 시스템 유휴상태 = 커널이 커널 모드의 프로세스 컨텍스트에서 idle 프로세스 실행     \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널과 전통적인 유닉스 커널\r\n\r\n* __리눅스는 유닉스와 유사, but 유닉스 아님__ : 유닉스 API(POSIX가 제정한 유일한 유닉스 표준) 구현하고 있지만 소스 물려받지 않음     \r\n\r\n\r\n\r\n리눅스에 __MMU__메모리 관리 장치 필요, 특펼히 없는 버전은 아주 작은 임베디드 시스템용  \r\n\r\n__유닉스 커널__ : 모놀리딕monolithic의 정적 바이너리  \r\n__리눅스 커널__ : 모놀리딕monolithic 커널이지만 마이크로 커널의 장점 수용\r\n - 모듈화 설계, 커널 선점(커널이 자신을 선점), 커널 스레드 지원, 별도의 바이너리(커널 모듈)를 커널 이미지에 동적으로 로드\r\n - 모든 작업은 커널 모드에서 실행, 통신 방식으로 X메세지 전달, O직접 함수 호출     \r\n \r\n*** \r\n \r\n__리눅스 커널 기준 전통적인 유닉스 시스템의 주요 차이점__\r\n - 커널 모듈 동적 로딩, 모노리딕 형식이지만 필요에 따라 동적으로 커널 코드 로드, 제거\r\n - 대칭형 멀티프로세서SMP 지원\r\n - 선점형 : 커널 내부에서 실행 중인 작업도 선점 가능\r\n - 독특한 방식으로 스레드 지원 : 정상 프로세스와 스레드 구분 안함/ 커널 입장에서 동등, but 자원 공유하는 프로세스들이 스레드임\r\n - 디바이스 클래스, 핫플러그 이벤트, 사용자 공간 디바이스 파일시스템sysfs => 객체지향적인 장치 모델 지원     \r\n \r\n \r\n \r\n \r\n \r\n \r\n# 리눅스 커널 버전\r\n\r\n(주버전).(부버전).(개정판).(안정 버전 일련번호)  \r\n부버전 짝수가 안정 커널\r\n \r\n \r\n\r\n","fields":{"slug":"/리눅스 커널 (1) - 리눅스 커널 입문/"},"frontmatter":{"title":"리눅스 커널 (1) - 리눅스 커널 입문","published":true}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#","fields":{"slug":"/AAAHellow World!/"},"frontmatter":{"title":"Hellow World!","published":true}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}