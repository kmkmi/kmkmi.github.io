{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/리눅스 커널 (1) - 리눅스 커널 입문/","result":{"data":{"site":{"siteMetadata":{"title":"KMKMI","author":"Kangmo Han"}},"markdownRemark":{"id":"b6028584-9154-5783-94f1-4e5ecf58f683","html":"<h1>운영체제와 커널</h1>\n<p><strong>운영체제</strong> : 정의 힘듬, but 기술적 관점 => 기본적인 사용과 관리 담당하는 시스템의 일부분</p>\n<ul>\n<li>커널, 장치 드라이버, 부트로더, 명령행 셸(동등 역할의 사용자 인터페이스 포함), 기본적인 파일 및 시스템 유틸리티 등  </li>\n</ul>\n<p><strong>시스템</strong> : 운영체제 + 그 위에서 동작하는 모든 애플리케이션 통틀음    </p>\n<p><strong>커널</strong> : (a.k.a 관리자supervisor, 코어core, 내부internals) </p>\n<ul>\n<li>인터럽트 핸들러, 스케줄러, 메모리 관리 시스템, 네트워크나 프로세스간 통신 처리하는 시스템 서비스 등     </li>\n</ul>\n<hr>\n<p><strong>커널 공간</strong>kernel-space : 보호 메모리 공간 사용, 제약 없는 하드웨어 접근 등이 가능<br>\n과<br>\n<strong>사용자 공간</strong>user-space :</p>\n<ul>\n<li>사용자 애플리케이션 실행됨/ 장비의 가용 자원 중 일부만 사용 가능 </li>\n<li>특정 시스템 함수 실행 가능, 하드웨어 직접 접근 및 커널이 할당한 영역 밖에 메모리 접근은 잘못된 동작  </li>\n</ul>\n<p>은 다른 (시스템)상태를 가짐     </p>\n<hr>\n<p>커널 코드 실행 시 시스템은 커널 모드로 커널 공간에 있음<br>\n일반적인 프로세스 처리 시 시스템은 사용자 모드로 사용자 공간에 있음  </p>\n<p>실행 애플리케이션은 시스템 호출을 통해 커널과 통신<br>\n주로) 애플리케이션이 라이브러리 함수 호출 => 라이브러리가 시스템 호출 인터페이스 이용 커널이 애플리케이션을 대신해 필요한 작업 수행</p>\n<p>일부 라이브러리 호출은 시스템 호출에는 없는 여러 기능 제공하기도 함, 이 경우 커널 호출은 커다란 함수의 일부 한 단계가 됨     </p>\n<p>ex) printf() : 데이터 출력 형식 지정 or 버퍼링 기능</p>\n<ul>\n<li>화면에 데이터 출력하기 위해 write() 시스템 호출 이용하는 것은 이 함수의 일부분</li>\n</ul>\n<p>일부 라이브러리 호출은 커널 호출과 일대일 대응</p>\n<p>한편, strcpy() 같은 C 라이브러리 함수는 커널 호출을 직접 사용하지 않음     </p>\n<ul>\n<li>애플리케이션이 시스템 호출을 실행하는 것을 애플리케이션을 대신에 커널이 실행 중이라고 표현</li>\n<li>또는 (= 애플리케이션이 커널 공간에서 시스템 호출을 실행 중 = 커널이 프로세스 컨텍스트를 실행 중)</li>\n</ul>\n<p>애플리케이션이 시스템 호출을 통해 커널을 이용하는 방식이 애플리케이션의 작업 수행의 기초적인 방식     </p>\n<hr>\n<p><strong>커널은 시스템 하드웨어도 관리</strong> : 인터럽트 개념<br>\n<strong>인터럽트</strong> : 종류는 숫자로 구분, 커널은 숫자로 인터럽트 처리, 응답할 인터럽트 핸들러 실행  </p>\n<ul>\n<li>커널이 동기화를 위해 새로운 인터럽트 블락 가능(모든 인터럽트 다 or 특정 인터럽트만)  </li>\n<li>리눅스 포함 대다수 운영체제 인터럽트 핸들러를 프로세스 컨텍스트에서 실행 안함  </li>\n<li>대신 프로세스와 분리되어 있는 별도의 인터럽트(전용) 컨텍스트에서 실행      </li>\n</ul>\n<p>컨텍스트는 커널의 활동 범주 나타냄<br>\n리눅스에서 프로세스는 세가지 중 한가지 일 하는 중</p>\n<ul>\n<li>사용자 공간에서 프로세스의 사용자 코드를 실행</li>\n<li>커널 공간의 프로세스 컨텍스트에서 특정 프로세스를 대신해 코드를 실행</li>\n<li>커널 공간의 인터럽트 컨텍스트에서 프로세스와 상관없이 인터럽트를 처리\nex) 시스템 유휴상태 = 커널이 커널 모드의 프로세스 컨텍스트에서 idle 프로세스 실행     </li>\n</ul>\n<h1>리눅스 커널과 전통적인 유닉스 커널</h1>\n<ul>\n<li><strong>리눅스는 유닉스와 유사, but 유닉스 아님</strong> : 유닉스 API(POSIX가 제정한 유일한 유닉스 표준) 구현하고 있지만 소스 물려받지 않음     </li>\n</ul>\n<p>리눅스에 <strong>MMU</strong>메모리 관리 장치 필요, 특펼히 없는 버전은 아주 작은 임베디드 시스템용  </p>\n<p><strong>유닉스 커널</strong> : 모놀리딕monolithic의 정적 바이너리<br>\n<strong>리눅스 커널</strong> : 모놀리딕monolithic 커널이지만 마이크로 커널의 장점 수용</p>\n<ul>\n<li>모듈화 설계, 커널 선점(커널이 자신을 선점), 커널 스레드 지원, 별도의 바이너리(커널 모듈)를 커널 이미지에 동적으로 로드</li>\n<li>모든 작업은 커널 모드에서 실행, 통신 방식으로 X메세지 전달, O직접 함수 호출     </li>\n</ul>\n<hr>\n<p><strong>리눅스 커널 기준 전통적인 유닉스 시스템의 주요 차이점</strong></p>\n<ul>\n<li>커널 모듈 동적 로딩, 모노리딕 형식이지만 필요에 따라 동적으로 커널 코드 로드, 제거</li>\n<li>대칭형 멀티프로세서SMP 지원</li>\n<li>선점형 : 커널 내부에서 실행 중인 작업도 선점 가능</li>\n<li>독특한 방식으로 스레드 지원 : 정상 프로세스와 스레드 구분 안함/ 커널 입장에서 동등, but 자원 공유하는 프로세스들이 스레드임</li>\n<li>디바이스 클래스, 핫플러그 이벤트, 사용자 공간 디바이스 파일시스템sysfs => 객체지향적인 장치 모델 지원     </li>\n</ul>\n<h1>리눅스 커널 버전</h1>\n<p>(주버전).(부버전).(개정판).(안정 버전 일련번호)<br>\n부버전 짝수가 안정 커널</p>","excerpt":"운영체제와 커널 운영체제 : 정의 힘듬, but…","frontmatter":{"title":"리눅스 커널 (1) - 리눅스 커널 입문","date":"2019-11-08","tags":["커널","리눅스"],"keywords":["KMKMI"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/리눅스 커널 (1) - 리눅스 커널 입문/","previous":null,"next":{"fields":{"slug":"/Gatsby 블로그 적용 도중 만난 에러/"},"frontmatter":{"title":"Gatsby 블로그 적용 도중 만난 에러","tags":["Gatsby","에러"],"published":true}}}}}