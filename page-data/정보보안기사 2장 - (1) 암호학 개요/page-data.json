{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/정보보안기사 2장 - (1) 암호학 개요/","result":{"data":{"site":{"siteMetadata":{"title":"KMKMI","author":"Kangmo Han"}},"markdownRemark":{"id":"704a1c85-715a-5265-89ad-61bafa27d6b5","html":"<h2>1. 암호학의 기본개념</h2>\n<h3>1) 암호학(Cryptology)의 정의</h3>\n<ol>\n<li>암호 : 약속된 당사자나 집단에서만 내포된 내용을 알 수 있게하는 일종의 문서</li>\n<li>암호학 : 암호 기술과 암호해독에 관하여 연구하는 학문 </li>\n</ol>\n<h3>2) 암호학에서 사용하는 이름</h3>\n<ol>\n<li>앨리스(Alice), 밥(Bob) : 메시지 송수신 주체</li>\n<li>이브(Eve) : 도청자(eavesdropper), 소극적 공격자</li>\n<li>맬로리(Mallory) : 악의적인(malicious) 공격자</li>\n<li>트렌트(Trent) : 신뢰할 수 있는 중재자(trusted arbitrator)</li>\n<li>빅터(Victor) : verifier, 검증인</li>\n</ol>\n<h3>3) 송신자, 수신자, 도청자</h3>\n<ol>\n<li>송신자(sender), 수신자(receiver), 메시지(message)</li>\n<li>사람 이름이 사람이 아닌 기계나 프로그램일 수도 있다.</li>\n</ol>\n<h3>4) 암호화와 복호화</h3>\n<ol>\n<li>평문(plaintext) : 암호화하기 전 메시지<br>\n암호문(ciphertext) : 암호화한 메시지 </li>\n<li>암호(cryptography) 기술로 기밀성(confidentiality) 유지</li>\n</ol>\n<h3>5) 암호화와 복호화의 기호적 표현</h3>\n<ol>\n<li>\n<p>주로, </p>\n<p>평문 : P<br>\n암호문 : C<br>\n암호 알고리즘 : E<br>\n복호화 알고리즘 : D<br>\n키 : K</p>\n<ul>\n<li>키 스페이스 : 사용하는 키 값의 크기(size)  </li>\n</ul>\n</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mi>E</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C = E_{k}(P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> : 평문 P를 키 K로 암호화(E)하여 암호문 C</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>D</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P = D_{k}(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span> : 암호문 C를 키 K로 복호화(D)하여 평문 P</li>\n<li>또는 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C = E(K,P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>K</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P = D(K,C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>로 표현</li>\n<li>암호시스템(Cryptosystem) : 암호화와 복호화를 수행하는 시스템</li>\n</ol>\n<h3>6) 암호 알고리즘과 키의 분리</h3>\n<p>암호 알고리즘은 반복하고 키만 바꾸어 사용</p>\n<h3>7) 암호와 보안 상식</h3>\n<p><strong>(가) 비밀 암호 알고리즘 사용하지 말 것</strong><br>\n암호 알고리즘 구조가 폭로되면 파훼됨<br>\n숨기는 것에 의한 보안(security by obscurity)라 부르고 위험하고 어리석게 간주  </p>\n<p><strong>(나) 약한 암호는 암호화하지 않는 것보다 위험</strong><br>\n잘못된 안심을 하고 기밀성 높은 정보 소홀하게 취급할 가능성  </p>\n<p><strong>(다) 어떤 암호라도 언젠가는 해독됨</strong><br>\nBrute-force attack<br>\n해독에 들어가는 시간과 암호화할 평문의 중요성의 밸런스(trade-off) 고려  </p>\n<p><strong>(라) 암호는 보안의 일부분</strong><br>\n사회공격(social engineering attack)이 최근 자주 행해짐<br>\ne.g.) 피싱(Phshing) : 위장 홈페이지 등으로 접근하도록 하여 개인정보 빼 가는 해킹 방법,<br>\n트로이목마(Trojan Horse) : 정상적인 프로그램으로 가장해 다른 프로그램 안에 숨어 있다가 그 프로그램이 실행될 때 자신을 활성화하는 악성 프로그램,<br>\n키로거(Keylogger) : 키보드 움직임을 탐지해 개인정보를 몰래 빼 가는 해킹 공격  </p>\n<h2>2. 암호기법의 분류</h2>\n<h3>1) 치환 암호와 전치 암호</h3>\n<p><strong>(가) 치환 암호(대치 암호, Substitution Cipher)</strong><br>\n비트, 문자 또는 블록을 다른 비트, 문자 또는 블록으로 대체<br>\n평문에서 사용하는 문자의 집합과 암호문에서 사용하는 문자의 집합이 다를 수 있음<br>\n문자를 교환하는 규칙, 일대일 대응이 아닐 수 있음  </p>\n<p><strong>(나) 전치 암호(Transposition Cipher)</strong><br>\n비트, 문자 또는 블록이 원래 의미를 감추도록 재배열<br>\n평문과 암호문에서 사용하는 문자 집합이 동일<br>\n문자 집합 내부에서 자리를 바꾸는 규칙, 평문과 암호문의 문자가 일대일 대응 규칙  </p>\n<ul>\n<li>키 공간(Key space)의 크기와 키 비트수<br>\n암호화에서 키 공간의 크기는 전사 공격 방지에 매우 중요.<br>\n클 수록 안전.<br>\n하지만 키가 클 수록 키 비트수도 커짐.  </li>\n</ul>\n<h3>2) 블록 암호와 스트림 암호</h3>\n<p><strong>(가) 블록 암호(Block cipher)</strong><br>\n블록 암호는 특정 비트 수의 집합인 블록 단위로 암호화하는 알고리즘을 총칭<br>\n블록 비트 수  = 블록 길이(block length)<br>\n평문을 블록으로 나누어 암호화, 블록 크기는 8 또는 16의 배수<br>\n스트림 암호화와 다르게 Round를 사용하고, 반복적으로 암호화 과정을 수행해 암호화  </p>\n<p><strong>(나) 스트림 암호(Stream cipher)</strong><br>\n한번에 1비트 혹은 1바이트의 스트림(데이터 흐름)을 순차적으로 처리해 암호화하는 알고리즘 총칭<br>\n평문과 키 스트림을 XOR해서 암호화<br>\n블록 암호화와 다르게 스트림 암호화는 진행 상태를 알기 위해 내부 상태를 가짐<br>\n군사 및 외교용으로 널리 사용, 일부 상용으로<br>\n이동 통신 환경에서 구현 용이, 안전성을 수학적으로 엄밀 분석 가능하여 무선 데이터 보호에 적합  </p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">구분</th>\n<th align=\"left\">스트림 암호</th>\n<th align=\"left\">블록 암호</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">장점</td>\n<td align=\"left\">암호화 속도 빠름, 에러 전파현상 없음</td>\n<td align=\"left\">높은 확산, 기밀성 해시함수 등 다양</td>\n</tr>\n<tr>\n<td align=\"left\">단점</td>\n<td align=\"left\">낮은 확산</td>\n<td align=\"left\">느린 암호화, 에러 전달</td>\n</tr>\n<tr>\n<td align=\"left\">사례</td>\n<td align=\"left\">LFSR, MUX generator</td>\n<td align=\"left\">DES, IDEA, SEED, RC5, AES</td>\n</tr>\n<tr>\n<td align=\"left\">암호화 단위</td>\n<td align=\"left\">비트</td>\n<td align=\"left\">블록</td>\n</tr>\n<tr>\n<td align=\"left\">주요 대상</td>\n<td align=\"left\">음성, 오디오/비디오 스트리밍</td>\n<td align=\"left\">일반 데이터 전송, 스토리지 저장</td>\n</tr>\n</tbody>\n</table>\n<h3>3) 위치에 따른 암호화의 구분</h3>\n<p><strong>(가) 링크 암호화(Link Encryption)</strong><br>\n모든 정보는 암호화됨, 홉(라우터)에서 패킷 목적지를 알기 위해 해독됨<br>\n라우터는 패킷 헤더 부분을 해독하여 라우팅과 주소 정보를 읽고 다시 암호화한 후 다음 홉으로 전송<br>\n링크 암호화는 데이터 링크 또는 물리적 계층에서 일어남, 하드웨어 암호화 장치들은 물리적 계층과의 인터페이스를 가지고 통과하는 모든 데이터 암호화  </p>\n<p><strong>(나) 종단간 암호화(End-to-End Encryption)</strong><br>\n종단간 암호화에서는 헤더와 트레일러가 암호화되지 않기 때문에 패킷을 각 홉에서 해독하고 암호화할 필요가 없음<br>\n근원지와 목적지 사이의 장비들은 단지 필요 라우팅 정보만 읽고 진행 방향으로 통과<br>\n보통 근원지 컴퓨터 사용자가 종단간 암호화 시작, 이 점이 사용자가 어떤 메시지를 암호화할지 여부 결정하는 유연성 제공<br>\n종단간 암호화는 애플리케이션 계층에서 암호화 이루어짐  </p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">구분</th>\n<th align=\"left\">링크 암호화</th>\n<th align=\"left\">종단간 암호화</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">특징</td>\n<td align=\"left\">- ISP나 통신업자가 암호화 <br/> - 헤더를 포함한 모든 데이터를 암호화 <br/> - 유저가 알고리즘 통제 불가</td>\n<td align=\"left\">- 사용자가 암호화 <br/> - 헤더(라우팅 정보)는 암호화 안함 <br/> - 알고리즘에 대한 통제를 사용자가 함</td>\n</tr>\n<tr>\n<td align=\"left\">장점</td>\n<td align=\"left\">- User-transparent하게 암호화되므로 운영 간단(유저에게 보이지 않는다는 의미) <br/> - 트래픽분석을 어렵게 함 <br/> - 온라인으로 암호화</td>\n<td align=\"left\">- 사용자 인증 등 높은 수준의 보안 서비를 제공 가능 <br/> - 중간노드에서도 데이터가 암호문으로 존재</td>\n</tr>\n<tr>\n<td align=\"left\">단점</td>\n<td align=\"left\">- 중간 노드에서 데이터가 평문으로 노출 <br/> - 다양한 보안서비스를 제공하는데 한계 <br/> - 모든 노드가 암호화 장비를 갖추어야하므로 네트워크가 커지면 비용 과다</td>\n<td align=\"left\">- 트래픽분석이 취약 <br/> - 오프라인으로 암호화</td>\n</tr>\n</tbody>\n</table>\n<h3>4) 하드웨어와 소프트웨어 암호시스템</h3>\n<p><strong>(가) 하드웨어 암호시스템</strong><br>\n하드웨어로 구현하기 위해 컴퓨터와 통신기기 내부버스와 외부 인터페이스에 전용 암호처리용 하드웨어 설치<br>\n전용 하드웨어로 암호화함으로써 컴퓨터 CPU에 부담을 주지 않고 빠른 속도로 암호화, 보안성 확보에 바람직  </p>\n<p><strong>(나) 소프트웨어 암호시스템</strong><br>\n암호처리용 소프트웨어를 사용한 데이터 암호화<br>\n저렴한 비용으로 실현 가능, 허용범위 내에서 적당한 안정성과 처리속도 얻을 시 상당히 효과적<br>\n개인 PC 성능 증진으로 처리속도 문제되지 않아 최근에는 소프트웨어 암호화가 주류  </p>\n<h2>3. 주요 암호기술에 대한 개괄</h2>\n<h3>1) 대칭키 암호와 비대칭키 암호</h3>\n<p>대칭키 암호(symmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 동일<br>\n비대칭키 암호(asymmetric cryptography)는 암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 서로 다름<br>\n비대칭키 암호 알고리즘 사용 시 송신자도 한 쌍의 키를 가지고 있어야 하고 수신자도 자신만의 한 쌍의 키 가져야함  </p>\n<h3>2) 하이브리드 암호 시스템</h3>\n<p>대칭키 암호와 공개키 암호를 조합한 암호 방식을 하이브리드 암호 시스템(hybrid cryptosystem)이라고 함<br>\n두 방식의 장점을 조합  </p>\n<h3>3) 일방향 해시함수</h3>\n<p>해시값은 일방향 해시함수(one-way hash function)를 사용하여 계산한 값<br>\n무결성 제공  </p>\n<h3>4) 메시지 인증코드</h3>\n<p>메시지가 예상 통신 상대로부터 온 것을 확인하기 위해 메시지 인증코드(message authentication code)라는 기술 사용<br>\n메시지 인증코드 사용 시 메시지가 전송 도중에 변경되지 않았다는 것과 생각했던 통신 상대로부터 왔다는 것 확인 가능<br>\n메시지 인증코드는 무결성과 인증 제공  </p>\n<h3>5) 전자서명</h3>\n<p>거짓 행세(spoofing), 변경, 부인의 위험을 방지하는 기술<br>\n무결성 확인, 인증과 부인방지 제공  </p>\n<h3>6) 의사난수 생성기</h3>\n<p>의사난수 생성기(PRNG, pseudo random number generator)는 난수열을 생성하는 알고리즘<br>\n난수는 키 생성(key generator)이라는 매우 중요한 역할  </p>\n<h2>4. 암호 분석(암호 해독)</h2>\n<h3>1) 개요</h3>\n<p>암호 방식의 정규 참여자 외 제3자가 암호문으로부터 평문을 찾으려 하는 것을 암호 해독(cryptanalysis) 또는 공격이라 함<br>\n공격자 = 암호 해독자, 제3자, 침해자<br>\n평문의 통계적 성질, 암호에 관한 지식, 장비 등 통해 암호문에서 평문 또는 키 찾아냄  </p>\n<ul>\n<li>케르히호프의 원리(Kerchhoff's principle) : 암호시스템의 안전성은 암호 알고리즘의 비밀을 지키는데 의존되지 말고, 키의 비밀을 지키는데 의존되어야 한다는 원리</li>\n</ul>\n<h3>2) 암호 분석의 분류</h3>\n<p><strong>(가) 암호문 단독 공격(COA, Ciphertext Only Attack)</strong><br>\n암호문 단독 공격은 공격자가 암호문을 얻어서 대응되는 평문과 키를 찾는 것<br>\n공격에 암호문만 필요, 공격자의 메시지 복호화를 막기 위해 이런 종류의 공격에 안전해야 함, 다양한 방법이 이 공격에 사용(평문의 통계적 성질, 문장의 특성 등)  </p>\n<p><strong>(나) 기지 평문 공격 (KPA, Known Plaintext Attack)</strong><br>\n기지(알려진) 평문 공격에서 공격자는 암호문 외에 추가로 여러 개의 평문/암호문 쌍을 얻음(미리 갖고 있음)<br>\nAlice가 Bob에게 비밀 메시지를 보냈지만 나중에 그 메시지를 공개한다면, 공격자(Eve)가 공개된 평문/암호문 쌍을 사용해 다음 A to B 보내려는 비밀 메시지를 알아내는데 사용  </p>\n<p><strong>(다) 선택 평문 공격(CPA, Chosen Plaintext Attack)</strong><br>\n선택 평문 공격은 알려진 평문 공격과 유사하지만 공격자에게 주어지는 평문/암호문 쌍을 공격자가 선택<br>\ne.g.) 공격자가 A의 컴퓨터에 접속하여 어떤 평문을 선택하고 이에 대응하는 암호문을 얻음<br>\n공격자가 평문을 선택하면 대응하는 암호문을 얻을 수 있는 경우    </p>\n<p><strong>(라) 선택 암호문 공격(CCA, Chosen Ciphertext Attack)</strong><br>\n선택 암호문 공격은 공격자가 어떤 암호문을 선택하고 그에 대응되는 평문을 얻음(그 외에는 선택 평문 공격과 유사)<br>\n공격자가 수신자의 컴퓨터에 접속 가능할 경우 적용 가능(공격자가 복호기에 접근 가능한 경우 : 암호문 선택시 대응 평문 얻을 수 있을 경우)<br>\n선택된 암호문(임의의 암호문이거나 계획에 의한 암호문 모두)을 복호화할 수 잇는 능력을 갖추고 있는 기계를 일반적으로 [Decryption Oracle, 복호 오라클]이라 부름<br>\n개인키로 암호화된 암호문을 알려진 공개키로 복호화할 수 있는 공개키 암호화 시스템에 대한 해독 공격에 주로 사용됨<br>\n선택 암호문 공격에 견딜 수 있는 알고리즘은 강한 알고리즘이라 말할 수 있음  </p>\n<ul>\n<li>Rubber-Hose Cryptanalysis 고무호스 암호분석 : 암호분석가가 키를 얻을 때까지 키를 가진 사람을 공갈, 협박, 고문하여 키를 획득...</li>\n<li>임시파일 : 대부분 암호화 시스템은 계산과정에서 임시파일 사용, 임시파일 삭제 혹은 덮어 쓰기 안될 시 이 정보에 의해 암호 해독 가능  </li>\n</ul>\n<h2>5. 암호 알고리즘의 안전성 평가</h2>\n<h3>1) 안전성 개념</h3>\n<p>주어진 암호 시스템의 안전성을 말할 때는 두 가지 관점  </p>\n<ol>\n<li>암호시스템 공격을 위해 필요한 계산량이 매우 커 현실적으로 공격 불가한 경우 : <strong>계산적 안전</strong>  </li>\n<li>무한한 계산능력에도 공격 불가한 경우 <strong>무조건적으로 안전</strong><br>\n다음 기준을 만족하는 알고리즘 필요  </li>\n<li>암호 해독 비용이 암호화된 정보의 가치를 초과</li>\n<li>암호 해독 시간이 정보의 유효 기간을 초과</li>\n<li>워크팩터(Work Factor) : 공격자가 암호화 방법을 깨는데 걸리는 노력(리소스)</li>\n</ol>\n<h3>2) 암호제품 평가체계</h3>\n<p>정보보호제품의 신뢰기관의 안정성평가 결과 : 가장 대표적인 것이 <strong>CC(Common Criteria)</strong> 기반의 정보보호제품 평가<br>\nCC기반의 평가 기준은 암호 알고리즘에 대한 평가기준 명시 안됨, 각국이 독자적으로 규정, 평가<br>\n<strong>암호모듈</strong>에 대한 안정성평가로 가장 널리 참조 되는 미국 NIST가 수행하는 <strong>CMVP(Cryptographic Module Validation Program)</strong>, 세계적으로 인정 받음  </p>\n<h3>3) 암호기술 평가</h3>\n<p><strong>(가) 평가 종류</strong>  </p>\n<ol>\n<li>암호 알고리즘 평가\n정보보호제품에 탑대된 암호 알고리즘에 대한 안정성 평가\n알고리즘 자체만을 평가, 따라서 제품이나 시스템과 독립적, 일반적으로 알고리즘 자체의 이론적 안정성만을 평가  </li>\n<li>암호모듈 평가 e.g.) <strong>CMVP</strong><br>\n암호 알고리즘을 이용하여 제공되는 암호서비스(기밀성 기능 모듈, 무결성 기능 모듈)에 대한 안정성 평가<br>\n알고리즘 자체의 이론적 안정성과는 별개, 암호모듈의 암호서비스 기능의 안정성 평가  </li>\n<li>정보보호제품 평가<br>\n암호모듈을 탑재한 정보보호 제품(예 : 침입차단시스템, 침입탐지시스템)에 대한 안정성 평가  </li>\n<li>응용시스템 평가<br>\n각 제품을 상호 연동하여 구성되는 시스템(예 : 국가기관망의 네트워크에 대한 보안성 평가, 항공관제센터의 안전성 평가)에 대한 안정성 평가  </li>\n</ol>\n<p><strong>(나) 평가 과정</strong>  </p>\n<ol>\n<li>안전성 평가는 응용시스템을 평가하는게 가장 바람직하나 현실적으로 어려움  </li>\n<li>그러므로 응용시스템의 가장 기본이 되는 암호 알고리즘에 대한 안전성 평가 우선되어야함  </li>\n<li>알고리즘으로부터 모듈, 제품, 시스템 순으로 안전성 평가 수행 바람직  </li>\n</ol>\n<h3>4) 암호모듈의 안전성 평가(CMVP)</h3>\n<p><strong>(가) 개요</strong><br>\nㄱ. 암호기술의 구현 적합성 평가<br>\nㄴ. 암호키 운용 및 관리<br>\nㄷ. 물리적 보안  </p>\n<h2>6. 지적 재산권 보호</h2>\n<h3>(1) 디지털 저작권 관리</h3>\n<h4>1) 스테가노그래피(Steganography)</h4>\n<p>암호화와 다른 개념, 다른 무언가로 감추어 메시지 자체를 은폐<br>\ne.g.) 사진 속에 미세한 변화로 정보 입력  </p>\n<h4>2) 디지털 워터마킹(Digital Watermarking)</h4>\n<p>워터마킹 : 위조지폐 감별을 위해 물에 젖은 상태에서 인쇄한 그림을 불빛에 비추면 그림이 보이도록 하는 기술에서 유래<br>\n원본 내용 왜곡하지 않는 범위에서 저작권 정보를 디지털 컨텐츠에 삽입하는 기술  </p>\n<ul>\n<li>강한(강성) 워터마킹 : 공격을 받아도 쉽게 파괴, 손상 없음</li>\n<li>약한(연성) 워터마킹 : 공격 받을 시 쉽게 파괴, 손상  </li>\n</ul>\n<h4>3) 핑거프린팅(Fingerprinting)</h4>\n<ol>\n<li>디지털 컨텐츠 구매 시 구매자의 정보를 삽입, 불법 배포 발견 시 최초 배포자 추적 가능케 하는 기술  </li>\n<li>판매되는 컨텐츠마다 구매자의 정보 들어감, 불법 배포 컨텐츠 내에서 핑거프린팅 정보 추출하여 구매자 식별, 법적 조치 가능케 함  </li>\n</ol>\n<h4>4) 디지털 저작권 관리(DRM, Digital Rights Management)</h4>\n<p><strong>(가) 개요</strong>  </p>\n<ol>\n<li>DRM은 디지털 컨텐츠 소유자가 자신의 컨텐츠에 대한 접근을 자신 또는 자신의 위임자가 지정하는 다양한 방식으로 제어 가능케 하는 기술적 방법 또는 방법의 집합  </li>\n<li>컨텐츠 접근을 제한 실행, 보기, 복제, 출력, 변경 등  </li>\n</ol>\n<p><strong>(나) DRM 구성 요소</strong>  </p>\n<ol>\n<li>메타데이터(Metadata)  </li>\n<li>패키저(Packager) : 컨텐츠와 메타데이터를 함께 Secure Container 포맷으로 패키징하는 모듈  </li>\n<li>시큐어 컨테이너(Secure Container) : DRM 보호 범위 내 유통되는 컨텐츠 배포 단위  </li>\n<li>식별자(Identifier) : 컨텐츠 식별  </li>\n<li>DRM 제어기(DRM Controller) : 컨텐츠를 이용하는 사용자의 PC 또는 디바이스 플랫폼에서 컨텐츠가 라이센스에 명시된 범위 내에서 지속적으로 보호될 수 있도록 프로세스 제어  </li>\n</ol>\n<p><strong>(다) DRM 모델</strong>  </p>\n<ol>\n<li>컨텐츠 제공자(Content Provider), 컨텐츠 배포자(Distributer), 컨텐츠 소비자(Content Consumer), 클리어링하우스(ClearingHouse)  </li>\n<li>컨텐츠 제공자<br>\n컨텐츠의 디지털 권리를 가지고 권리 보호 원하는 DRM 사용자<br>\n권리 표현 언어(REL, Rights Expression Language) : 컨텐츠 사용 규칙 표현 언어 e.g.) 대표적으로 ODRL(Open Digital Rights Language), MPEG(Moving Picture Expert Group)  </li>\n<li>컨텐츠 배포자<br>\n컨텐츠 유통 채널(e.g. 온라인 쇼핑몰)\n정당 소비자에게 컨텐츠 안전하게 전달, 클리어링하우스로부터 대금 분배 받음  </li>\n<li>컨텐츠 소비자<br>\n클리어링하우스를 통해 컨텐츠에 대한 권리 요청, 대금 지불  </li>\n<li>클리어링하우스<br>\n디지털 허가를 소비자에게 발급, 제공자에게 로열티 수수료 지불, 배급자에게 배급 수수료 지불하는 재정적 거래 취급, 모든 소비자에게 허가된 사용을 기록하는 책임 있음  </li>\n</ol>","excerpt":"1. 암호학의 기본개념 1) 암호학(Cryptology)의 정의 암호 : 약속된 당사자나 집단에서만 내포된 내용을 알 수 있게하는 일종의 문서 암호학 : 암호 기술과 암호해독에 관하여 연구하는 학문  2) 암호학에서 사용하는 이름 앨리스(Alice…","frontmatter":{"title":"정보보안기사 2장 - (1) 암호학 개요","date":"2019-11-14","tags":["정보보안기사","보안"],"keywords":["KMKMI"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/정보보안기사 2장 - (1) 암호학 개요/","previous":{"fields":{"slug":"/정보보안기사 1장 정보보호 개요/"},"frontmatter":{"title":"정보보안기사 1장 정보보호 개요","tags":["정보보안기사","보안"],"published":true}},"next":{"fields":{"slug":"/리눅스 커널 (2) - 빌드와 설치, 주의사항/"},"frontmatter":{"title":"리눅스 커널 (2) - 빌드와 설치, 주의사항","tags":["커널","리눅스"],"published":true}}}}}