<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Your Site's RSS Feed]]></title><description><![CDATA[ ]]></description><link>https://kmkmi.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 07 Jul 2020 14:58:13 GMT</lastBuildDate><item><title><![CDATA[IoT 해킹 기초]]></title><description><![CDATA[임베디드 해킹 펌웨어 추출하고 분석하는 것으로 시작 abnormal action이 취약점인지는 상황에 따라 다를 수 있다! command injection stdin으로 들어온 인자가 system…]]></description><link>https://kmkmi.github.io/IoT 해킹 기초/</link><guid isPermaLink="false">https://kmkmi.github.io/IoT 해킹 기초/</guid><pubDate>Tue, 07 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;임베디드 해킹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;펌웨어 추출하고 분석하는 것으로 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;abnormal action이 취약점인지는 상황에 따라 다를 수 있다!&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;command injection&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stdin으로 들어온 인자가 system 함수로 들어 가면서 임의 명령어 실행&lt;/li&gt;
&lt;li&gt;유저 권한인 경우 취약점 아님&lt;/li&gt;
&lt;li&gt;취약점인지는 sandboxing 정책이나 root에 따라 다름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;memory corruption&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;취약점인지는 abort 되더라도 상황에 따라 다름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tee, trustzone, SGX : 루트 권한일 때도 보호해줘야 할 수 있다!&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;펌웨어 보호 로직 존재&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보호 기능 적용 시 비용 증가하고 성능 저하함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RF(Radio Frequency) 통신&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스마트 차량 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OBD2 : 차량 상태 검사, 블루투스&lt;/li&gt;
&lt;li&gt;CAN :  라디오 통신&lt;/li&gt;
&lt;li&gt;ECU engine control unit&lt;/li&gt;
&lt;li&gt;gps, lte 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스마트 홈 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도어락, 무인 택배, 엘레베이터, 조명/난방, 카메라 등&lt;/li&gt;
&lt;li&gt;동 게이트웨이 제어&lt;/li&gt;
&lt;li&gt;공용시설 제어&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;카드 포스 단말기 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;금융, 개인 정보&lt;/li&gt;
&lt;li&gt;환불 등 거래 조작&lt;/li&gt;
&lt;li&gt;연결된 PC 해킹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;복합기기 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;탈취, 변조&lt;/li&gt;
&lt;li&gt;문서 위변조&lt;/li&gt;
&lt;li&gt;팩스 보내기&lt;/li&gt;
&lt;li&gt;클라우드 전송도 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스마트 TV 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카메라&lt;/li&gt;
&lt;li&gt;유료 결제&lt;/li&gt;
&lt;li&gt;TV 내 어플리케이션&lt;/li&gt;
&lt;li&gt;브라우저(pc버전에서 브라우저 취약점 발견하고 스마트TV에서 바로 조치하기 어려움)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;냉장고 취약점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방화 : 프레온 가스 폭발?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동적 디버깅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;에뮬레이팅 필요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그외 요소들도 맞춰줘야 해서 동적 디버깅 환경 구성이 매우 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프리다, 하우스(프리다 매핑 하우스) : 동적 분석 도구&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JTAG : HW gdb라고 볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JTAG 등 디버그 포트 제외하고 출시하여 해킹 방지하기도 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모든 디버그 포트 막을 시 사후 분석 리스크 존재&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디버그 불가 시 교체하는 방법뿐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;임베디드 칩의 데이터시트 내용 따라서 신호 교환&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제 3의 기기가 신호 교환을 할 수 있어 이를 이용해 임베디드 해킹할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디솔더링 후 덤프 시 데이터 이상한 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;덤프를 잘못한 경우 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;binwalk : 펌웨어 분석 도구&lt;/li&gt;
&lt;li&gt;Return Oriented Programming(ROP)&lt;/li&gt;
&lt;li&gt;heap exploit : 잘 찾기 (매우)어려움, 성과를 내려고 할 때 잘 안씀&lt;/li&gt;
&lt;li&gt;fuzzing(fuzzer) : 취약점 분석 도구&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;차상길 교수님 : fuzzer 정형화 논문&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메이헴 개발(데프콘 출전)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IDA : 디스어셈블러&lt;/li&gt;
&lt;li&gt;JEB : 디컴파일러&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하우스로 인증서 우회하는 스크립트를 통해 앱 해킹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해킹하는 스크립트 자동으로 생성&lt;/li&gt;
&lt;li&gt;프리다로도 모두 가능(다만 세팅이 필요함)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;후킹(영어: hooking)은 소프트웨어 공학 용어로, 운영 체제나 응용 소프트웨어 등의 각종 컴퓨터 프로그램에서 소프트웨어 구성 요소 간에 발생하는 함수 호출, 메시지, 이벤트 등을 중간에서 바꾸거나 가로채는 명령, 방법, 기술이나 행위를 말한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;: &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%9B%84%ED%82%B9&quot;&gt;https://ko.wikipedia.org/wiki/후킹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ptrace : &lt;a href=&quot;https://ko.wikipedia.org/wiki/Ptrace&quot;&gt;https://ko.wikipedia.org/wiki/Ptrace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LD_PRELOAD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tcp 분석만으로 해킹 가능&lt;/li&gt;
&lt;li&gt;SDR(Software-Defined Radio)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;diff : 컴퓨터에서 diff 는 두 개의 파일 간 차이에 대한 정보를 출력하는 파일 비교 유틸리티이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해킹 시 실제 동작과 패킷을 바꿔가며 확인하여 수행&lt;/li&gt;
&lt;li&gt;암호화 통신으로 방지&lt;/li&gt;
&lt;li&gt;난독화 : 소프트웨어 단에서 해독 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;임베디드 기기의 키를 숨기는 문제 ← 공격 대상&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;임베디드가 인터넷에 연결 안된 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PKI 방식 사용 불가&lt;/li&gt;
&lt;li&gt;키를 메모리에 저장해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;임베디드 보안 공격을 막기는 어렵다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;취약점이 발견되기 마련!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하드웨어 해킹 자료 : &lt;a href=&quot;https://www.hackerschool.org/Sub_Html/HS_Posting/?uid=46&quot;&gt;https://www.hackerschool.org/Sub&lt;em&gt;Html/HS&lt;/em&gt;Posting/?uid=46&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RCE(Remote Code Execution)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[취약점 개념]]></title><description><![CDATA[CVE - Common Vulnerabilities and Exposures APT 그룹 라자루스 블루노로프 김수키 스카크러프트 RJB(Remote Jailbreak) "로컬 권한 상승(LPE)" 취약점 : local privilege…]]></description><link>https://kmkmi.github.io/취약점 개념/</link><guid isPermaLink="false">https://kmkmi.github.io/취약점 개념/</guid><pubDate>Tue, 07 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cve.mitre.org/&quot;&gt;CVE - Common Vulnerabilities and Exposures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;APT 그룹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;라자루스&lt;/li&gt;
&lt;li&gt;블루노로프&lt;/li&gt;
&lt;li&gt;김수키&lt;/li&gt;
&lt;li&gt;스카크러프트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RJB(Remote Jailbreak)&lt;/li&gt;
&lt;li&gt;&quot;로컬 권한 상승(LPE)&quot; 취약점 : local privilege escalation&lt;/li&gt;
&lt;li&gt;RCE, Remote Code Execution 공격&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;펨토셀(영어: Femtocell)은 가정이나 소규모 사무실을 위한 초소형, 저전력의 이동통신 기지국&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8E%A8%ED%86%A0%EC%85%80&quot;&gt;https://ko.wikipedia.org/wiki/펨토셀&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PoC : 개념 증명(Proof of concept)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;원격 데스크톱 프로토콜(Remote Desktop Protocol, RDP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;https://ko.wikipedia.org/wiki/원격&lt;em&gt;데스크톱&lt;/em&gt;프로토콜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FreeRDP : 오픈소스 구현체&lt;/li&gt;
&lt;li&gt;Virtual channel : 프로토콜으로 클라이언트 서버 통신 채널&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pwn : 해킹 공격으로 침투한다는 뜻&lt;/li&gt;
&lt;li&gt;AFL fuzz(american fuzzy lop)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ASan, AddressSanitizer : 버퍼 오버플로 또는 매달려있는 포인터 액세스와 같은 메모리 손상 버그를 감지하는 Google의 오픈 소스 프로그래밍 도구&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/AddressSanitizer&quot;&gt;https://en.wikipedia.org/wiki/AddressSanitizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;윈도우에서 적용하기 힘들어 PageHeap 사용 : 힙 손상 탐지&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ASan, pageheap으로 heapflag를 켤 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heapflag는 윈도우 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Heap Feng shui : 힙 풍수는 임의 코드 실행을 용이하게하기 위해 악용에 사용되는 기술로 신중하게 선택된 크기의 힙 할당을 만들어 힙의 레이아웃을 조작하려고 시도&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HACKERONE : 버그바운티 플랫폼&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackerone.com/&quot;&gt;https://www.hackerone.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UAF, Use and Free 취약점&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[하드웨어 해킹 기초]]></title><description><![CDATA[RTOS(←Real Time Operating System) 군사 제품 미사일, 전투기, 전차 등에 사용 실시간성 : 빠르게 실행되는 것이 아닌 정해진 시간(데드라인) 안에 수행되서 완료되어야 한다. Reliablity…]]></description><link>https://kmkmi.github.io/하드웨어 해킹 기초/</link><guid isPermaLink="false">https://kmkmi.github.io/하드웨어 해킹 기초/</guid><pubDate>Tue, 07 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RTOS(←Real Time Operating System)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;군사 제품 미사일, 전투기, 전차 등에 사용&lt;/li&gt;
&lt;li&gt;실시간성 : 빠르게 실행되는 것이 아닌 정해진 시간(데드라인) 안에 수행되서 완료되어야 한다.&lt;/li&gt;
&lt;li&gt;Reliablity가 요구되어 동적 할당 사용을 지양하고 항상 같은 결과가 나올 수 있도록 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS단에서 32비트를 64비트 시스템으로 포팅하는 것은 프로그램 단이랑 차원이 다르다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하드웨어 해킹이란&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주변의 흔한 제품 해킹&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흔하지 않은 제품&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CCTV, 자동차, 드론, 비행기 등&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;항공기 SW는 매우 엄격한 인증을 받아야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;설계부터 테스트까지 과정 추적&lt;/li&gt;
&lt;li&gt;모든 코드 테스트&lt;/li&gt;
&lt;li&gt;과정 추적에서 문제가 없다고 버그가 없다고 단정할 수 없음&lt;/li&gt;
&lt;li&gt;비행기 관련 소스는 오픈되있지 않고, 외부와 연결되있지 않아 안전한 편이지만 앞으로 AI나 Connectivity가 강화되면 외부와 연결될 가능성있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;의료기기, 스마트팜, 산업용 제품 등&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;산업용 제품은 구매 이후 오래되어 취약해질 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복합기의 경우 중요 문서 유출될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;multilevel feedback queue(다단계 피드백 큐) MLFQ : 스케줄링 방식&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;임베디드 개발&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;임베디드 SW는 일반 SW보다 작거나 같은 크기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;펌웨어, RTOS 레벨이 아니면 둘은 비슷하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기능이 매우 간단&lt;/li&gt;
&lt;li&gt;저성능 → 요구 전력이 낮음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;펌웨어 기능에 스케줄러가 필요하면 RTOS가 필요해진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;펌웨어는 기능을 루프하도록 되어있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과거에는 OS가 올라간 펌웨어가 없었기 때문에 OS와 분리된 개념으로 보고 엄밀히 보면 OS없는 것을 펌웨어라고 한다.&lt;/li&gt;
&lt;li&gt;최근에는 펌웨어에 OS가 올라간 형태를 펌웨어라고 통칭하기도 함&lt;/li&gt;
&lt;li&gt;인터럽트 핀 방식으로 외부 입력 비동기적으로 처리할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;펌웨어 크기는 최소 수백메가에서 수백기가까지 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;몇메가 수준도 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;부트로더 : 부팅 과정에서 다음에 실행될 프로그램 로딩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Microprocessor Unit, MCU&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;과거 임베디드 제품 특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구조가 단순하여 공격 벡터가 많지 않음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;→ 간단한 보완 해결 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HW에 대한 정보가 잘 공유되지 않아 해커의 정보 수집 어려움&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용할 수 있는 해킹 도구가 흔하지 않았음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HW 디버깅 도구나 기술이 적었음&lt;/li&gt;
&lt;li&gt;개발 도구가 굉장히 비싼 편&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현대의 임베디드/IoT 제품 특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;연결성 : 쉽게 접근 가능&lt;/li&gt;
&lt;li&gt;휴대성 : 위치 정보 등 사생활 침해 가능&lt;/li&gt;
&lt;li&gt;위험성 :  오작동 시 치명적 피해 발생 가능&lt;/li&gt;
&lt;li&gt;레거시 코드 : 산업 장비(비용 때문에 교체를 꺼림) 등 펌웨어 업데이트, 관리가 거의 안 되는 제품 많음 → 취약성 높음&lt;/li&gt;
&lt;li&gt;리버싱 난이도 하향 : HW, CPU 아키텍처 정보 공유됨, HW/SW 디버깅 기술이 진보했고 편리해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;임베디드 제품 구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SoC(System on Chip), MCU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MCU는 코어 외에 주변장치(각종 컨트롤러)들 포함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MCU는 RTOS 수준, 메모리도 포함되 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SoC는 MCU에 고성능 컨트롤러가 추가됨, 여러가지 기능들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU, 인코더 등 (컨트롤러, 칩들이 다른 전원 사용)&lt;/li&gt;
&lt;li&gt;범용 OS가 올라갈 수 있고, 메모리는 빠짐&lt;/li&gt;
&lt;li&gt;DRAM, 저장장치, 부팅장치(SD카드, 낸드플래시) 등을 따로 붙여줘야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DRAm, Flash 메모리&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;통신 인터페이스(UART, I2C, SPI)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Universal Asynchronous Receiver/Transmitter : 비동기 통신 전용 HW, 없으면 비동기 통신 프로토콜 직접 구현해야 함&lt;/li&gt;
&lt;li&gt;Inter-Integrated Circuit : MCU와 주변장치의 통신을 하는 Two Wire Interface&lt;/li&gt;
&lt;li&gt;Serial Peripheral Interconnect : 모토로라 개발 전이중통신 동기식 통신 규격&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;외부 통신 모듈&lt;/li&gt;
&lt;li&gt;디스플레이 장치&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전원부&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMIC : 칩 별로 필요 전원이 다르기 때문에 맞춰서 전원 공급해줌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Flash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAND Flash : 배드가 많이 나도 사용 가능&lt;/li&gt;
&lt;li&gt;NOR Flash&lt;/li&gt;
&lt;li&gt;SPI Flash&lt;/li&gt;
&lt;li&gt;EEPROM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SIP, System in Package&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;외부 통신 모듈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wi-Fi module&lt;/li&gt;
&lt;li&gt;Bluetooth module&lt;/li&gt;
&lt;li&gt;Wi-Fi/BT module&lt;/li&gt;
&lt;li&gt;DMB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일반적 HW 해킹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;펌웨어 추출 → 획득&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 Support site&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품 펌웨어 업데이트 시 패킷 캡쳐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;펌웨어와 펌웨어 url주소 획득 후 업데이트 인증 방식을 알아내서 업데이트 패킷을 캡쳐한다, →  업데이트 과정 중 버그를 찾아냄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;부트로더 기능 이용 펌웨어 dump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serial Port → 부트로더 쉘 → 부트로더 내장 기능 → 커널 인자 활용해 펌웨어 획득&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS 기능 이용 펌웨어 dump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux 계열, POSIX 지원 OS, RTOS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플래시 FS와 Partitioning 지원&lt;/li&gt;
&lt;li&gt;/dev/mtdblock0 등 dev 파일 접근하여 쉽게 저장장치 접근 가능&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mtd tool 사용하여 펌웨어 dump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTD(Memory Technology Device) : 플래시 메모리를와 상위 application 계층를 연결 통신하기 위한 별도 계층의 디바이스 파일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JTAG 디버거 연결해서 펌웨어 dump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JTAG 디버거를 통해 펌웨어 획득&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SoC 코어 및 주변 입출력 버스에 접근 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Core Register, Memory, 각종 controller, 주변 장치 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JTAG을 뚫으면 모두 침투 당하는 것과 마찬가지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chip Off&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;플래시 칩 떼어내기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매우 어렵다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디솔더링, 리볼링&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고가의 데이터를 읽어내는 툴 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;펌웨어 리버싱 → 취약점 분석&lt;/li&gt;
&lt;li&gt;외부 통신 인터페이스로 퍼징&lt;/li&gt;
&lt;li&gt;취약점 공격 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Decapping : the process of removing the protective cover of a microchip so that the contained die is revealed for visual inspection of the micro circuitry imprinted on the die.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SEM(Scanning Electron Microscope)(주사전자현미경) Imaging&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디캐핑 후 이미징함&lt;/li&gt;
&lt;li&gt;전자를 쏘아 튕겨져 나오는 전자로 이미지화함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[OS를 구성하는 시스템]]></title><description><![CDATA[OS system FS : NTFS, FAT33, exFAT 프로세스, 스케줄러: 프로세스 시스템 프로세스 : 실행중인 프로그램(의 일부) 하드디스크, 저장장치에 존재하는 프로그램을 FS을 통해 불러옴 실행파일 형식 execute file format…]]></description><link>https://kmkmi.github.io/OS를 구성하는 시스템/</link><guid isPermaLink="false">https://kmkmi.github.io/OS를 구성하는 시스템/</guid><pubDate>Mon, 06 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;system&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FS : NTFS, FAT33, exFAT&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로세스, 스케줄러: 프로세스 시스템&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 : 실행중인 프로그램(의 일부)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하드디스크, 저장장치에 존재하는 프로그램을 FS을 통해 불러옴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실행파일 형식 execute file format&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PE, ELF, COFF, MACH-O&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행파일 포맷 = 프로세스 관리 시스템&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;운영체제에게 요청하는 내용 있어야 함&lt;/li&gt;
&lt;li&gt;메모리 용량, 자원(장치, 드라이버, 인터럽트), 접근권한(ACL)&lt;/li&gt;
&lt;li&gt;위 내용을 관리하는 &lt;strong&gt;프로세스 관리 시스템이 제일 중요&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메모리 관리 시스템&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스레드, 멀티코어 프로그래밍&lt;/li&gt;
&lt;li&gt;Memory Address Space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;파일시스템&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플래시 메모리는 1~3년 정도 읽기, 쓰기 없으면 휘발됨&lt;/li&gt;
&lt;li&gt;하드디스크도 섹터 소실됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장치 관리 시스템&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;드라이버는 HW를 제어하기 위한 SW&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HW 제작사가 제작해서 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;드라이버 등록시 메모리 주소, 메모리 공간, IRQ 번호&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Active 장치 : IRQ 번호를 받음 = 인터럽트 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HDD  : Active 장치 → ATA 버스 컨트롤러, SAS 버스 컨트롤러, 플래시 메모리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메모리 버스 컨트롤러 : 메모리에 버스별로 제어 신호를 보냄&lt;/li&gt;
&lt;li&gt;컨트롤러 탑재되어 IRQ 번호도 할당됨&lt;/li&gt;
&lt;li&gt;버스 프로토콜을 이용하여 CPU와 통신하고, 제어, 협상하기 때문에 Active&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오류 메시지는 다양한 경로로부터 올 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HW, SW 등등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Passive 장치 : IRQ 번호 받지 않음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;USB 카메라 : 패시브 장치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메모리 버스를 사용하는 경우 대부분 패시브 장치&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU와 APIC(←컨트롤러) : CPU는 인터럽트를 걸기도 하고, 걸리기도 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;에러, 예외 등 인터럽트가 필요한 경우 CPU 드라이버가 주기적으로 검사하여 처리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예외처리가 된다!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크 관리 시스템 : 최근 OS에 포함되는 시스템에서 빼기도 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;권한, 계정, 보안 관리 시스템&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6가지 시스템이 존재&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이용하여 프로그래밍하는 것을 &lt;strong&gt;시스템 프로그래밍&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C언어 : 커널이 아직 C언어로 만들어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C언어 창시자 : Dennis Ritchie, Ken Thomson&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음 포터블 어셈블러 개념으로 개발&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;명령어 체계와 독립적인 프로그래밍 언어&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 명령어 체계든지 C로 표현 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LLVM : &lt;a href=&quot;https://ko.wikipedia.org/wiki/LLVM&quot;&gt;https://ko.wikipedia.org/wiki/LLVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[System HW와 C언어 연관 기술]]></title><description><![CDATA[현재 대다수 RISC이다. x86이나 amd cpu들은 CISC 명령어들을 처리하지만 이들을 micro ops로 쪼개서 RISC 구조로 실행하기 때문에 RISC cpu 컨트롤러가 가끔 CISC 사용 datapath 별 명령어가 적어서 Reduced…]]></description><link>https://kmkmi.github.io/System HW와 C언어 연관 기술/</link><guid isPermaLink="false">https://kmkmi.github.io/System HW와 C언어 연관 기술/</guid><pubDate>Mon, 06 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;현재 대다수 RISC이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x86이나 amd cpu들은 CISC 명령어들을 처리하지만 이들을 micro ops로 쪼개서 RISC 구조로 실행하기 때문에 RISC cpu&lt;/li&gt;
&lt;li&gt;컨트롤러가 가끔 CISC 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;datapath 별 명령어가 적어서 Reduced Instruction Set Computer&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x86 컴퓨터가 한 명령어 체계만 쓰고 있는 것이 아님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sse, AVX 등도 함께 사용&lt;/li&gt;
&lt;li&gt;Multi-Datapath based RISC&lt;/li&gt;
&lt;li&gt;명령어 체계 별로 datapath 가짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I 버스, D 버스 쓰는 경우 하버드 아키텍처&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;폰 노이만 아키텍처와 다르다!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;APIC(Advanced Programmable Interrupt Controller)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/APIC&quot;&gt;https://ko.wikipedia.org/wiki/APIC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DMA(Direct Memory Access)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 하드웨어 하위 시스템이 CPU와 독립적으로 메인 시스템 메모리에 접근할 수 있게 해주는 컴퓨터 시스템의 기능&lt;/li&gt;
&lt;li&gt;DMA에서 LPC핀의 경우 서버랑 통신할때 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Low Pin Count(LPC) :  하드웨어적으로 연결하는 핀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu에 낮은 광대역 장치 연결하는 인터페이스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bare-metal : 가상화에서 가상 cpu 안의 값을 외부 장치가 바꾸는 기술&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 하드웨어 단 경계를 넘어 직접 접근하는 것&lt;/li&gt;
&lt;li&gt;register 직접 접근&lt;/li&gt;
&lt;li&gt;physical register도 접근 가능&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상화의 경우 관리자가 편해짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. 사용자 cpu를 no operation으로 작동 못하게할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로세서에서 사용할 경우 장치 직접 제어가 가능해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Controller는 IO를 위해 이미 Bare-metal이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컨트롤러도 레지스터 가짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장치가 제어 역할을 하면 레지스터 가짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;register 직접 접근 가능 여부가 cpu와의 차이&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;char형은 int 형에서 인코딩 테이블에 맞춰 치환해주는 형태&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SR-IOV(Single Root I/O Virtualization)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PF[Physical Function] :  물리적인 PCI 카드를 나타냄&lt;/li&gt;
&lt;li&gt;VF[Virtual Function] : 가상 PCI 카드를 생성해 줄 수 있는 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정의 → #define : 심볼 테이블에 명시함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자료형, 함수명, 변수명 등 대다수 C언어 문법 안에 존재하는 것을 대상으로 할 수 있음&lt;/li&gt;
&lt;li&gt;선언과는 별개이지만 별칭(여러개 가능)을 붙였다고 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gcc -E hello.c&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-E 옵션 : 전처리 과정 화면에 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stdio.h&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템과 관련한 변수, 메모리 주소, 상수들을 선언&lt;/li&gt;
&lt;li&gt;메모리와 I/O 관계 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;primitive data format : 선언 내리면 할당되어 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C언어 C89에서는 선언, 할당, 대입을 한번에 할 수 없었지만(에러 발생) C99부터 사용 가능&lt;/li&gt;
&lt;li&gt;어셈블러(컴퓨터 자체가)는 메모리 주소만으로 자료형알 수 없음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;printf, scanf : 특수한 함수&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;va_args : 인자 개수가 가변적이고 제한이 없다.&lt;/li&gt;
&lt;li&gt;커널에서 한계가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 컴파일러의 4 stage : 만들 수 있는 바이너리 종류 4가지&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1st : Raw image ← 이 단계부터 printf, scanf 사용 가능&lt;/li&gt;
&lt;li&gt;2nd : KERNEL API&lt;/li&gt;
&lt;li&gt;3rd : Library&lt;/li&gt;
&lt;li&gt;4th : execute file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[해커의 관점]]></title><description><![CDATA[개발자는 모든 예외 및 엣지 케이스를 신경 쓸 수 없음 해커의 역할 : 예외 및 엣지 케이스에 대한 확실한 이해, 내부 API 구현체까지 완전히 이해하고, 기술 문서 또는 백서와 일치하는지 꼼꼼히 확인 State-sponsored Attacks e.g…]]></description><link>https://kmkmi.github.io/해커의 관점/</link><guid isPermaLink="false">https://kmkmi.github.io/해커의 관점/</guid><pubDate>Mon, 06 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발자는 모든 예외 및 엣지 케이스를 신경 쓸 수 없음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해커의 역할 : 예외 및 엣지 케이스에 대한 확실한 이해, 내부 API 구현체까지 완전히 이해하고, 기술 문서 또는 백서와 일치하는지 꼼꼼히 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;State-sponsored Attacks&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. stuxnet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zerodium.com/&quot;&gt;ZERODIUM - The Leading Exploit Acquisition Platform&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exploit 판매상&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Black Marcket : 취약점 및 익스플로잇 판매(Gray &amp;#x26; Black hat)&lt;/li&gt;
&lt;li&gt;버그바운티(White hat)&lt;/li&gt;
&lt;li&gt;CFG(Control Flow Guard)는 Windows 10과 Window8.1 update3에 채택된 보호매커니즘이다.&lt;/li&gt;
&lt;li&gt;데이터 실행 방지(Data Execution Prevention, DEP) : 현대의 마이크로소프트 윈도우 운영 체제에 포함된 보안 기능이며, 실행 방지 메모리 영역의 실행 코드에서 응용 프로그램이나 서비스가 실행되지 못하게 막기 위해 고안된 것이다. 이를테면 버퍼 오버플로를 통한 코드를 저장하는 특정한 이용을 막을 수 있다. : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%8B%A4%ED%96%89_%EB%B0%A9%EC%A7%80&quot;&gt;https://ko.wikipedia.org/wiki/데이터&lt;em&gt;실행&lt;/em&gt;방지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Return To Library,  RTL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DEP 방어 기법으로 불가능해 짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;문자 하나로 감염되는 경우도 있지만 실제 오퍼레이션에서 현실적 문제로 불가능할 수 있음&lt;/li&gt;
&lt;li&gt;Cyber Grand Challenge, CGC : 자동화된 해킹을 경쟁하는 대회&lt;/li&gt;
&lt;li&gt;드림핵(해킹 학습) : &lt;a href=&quot;https://dreamhack.io/&quot;&gt;https://dreamhack.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Gartner Top10 Technology til 2020]]></title><description><![CDATA[IT = Information Technology = 정보 기술 보안! 정보화 ← DB 서버 ← Service Provider가 조회 보안 ← 기술 기밀성 : 암호화 무결성 : 인증 가용성 : 웹, 모바일 Gartner…]]></description><link>https://kmkmi.github.io/Gartner Top10 Technology til 2020/</link><guid isPermaLink="false">https://kmkmi.github.io/Gartner Top10 Technology til 2020/</guid><pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IT = Information Technology = 정보 기술&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;보안!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보화 ← DB 서버 ← Service Provider가 조회&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;보안 ← 기술&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기밀성 : 암호화&lt;/li&gt;
&lt;li&gt;무결성 : 인증&lt;/li&gt;
&lt;li&gt;가용성 : 웹, 모바일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gartner&lt;/strong&gt; : 리서치, 정보 기술 연구 및 자문 회사&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gartner Hype-Cycle&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;다섯 개의 단계로 구분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술촉발 Technology Trigger&lt;/li&gt;
&lt;li&gt;기대 거품의 정점 The Peak of Inflated Expectations&lt;/li&gt;
&lt;li&gt;환멸의 계곡 Trough of Disillusionment&lt;/li&gt;
&lt;li&gt;깨우침의 단계 Slope of Enlightenment&lt;/li&gt;
&lt;li&gt;생산성의 안정기 Plateau of Productivity&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Emerging Tech를 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매년 말 Top10 기술 선정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Device Mesh : IoT 망 등을 의미&lt;/li&gt;
&lt;li&gt;Ambient User Experience : 반응형 웹 등 유저 친화적 경험&lt;/li&gt;
&lt;li&gt;IoE (Internet of Everything)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adaptive Security Architecture : 적응형 보안 구조 ← 지능형 기술 접목&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;→ Contiues Adaptive Risk and Trust Assessment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;→ Digital Ethics and Privacy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Privacy → Transparency and Traceability&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intelligent Things → Autonomous Things(AuT)&lt;/li&gt;
&lt;li&gt;Intelligent Apps and Analytics → Augmented Analytics&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Conversation System → Conversational Platforms&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. 큰틀에서의 E-mail과 챗봇 등 해당&lt;/li&gt;
&lt;li&gt;실시간 대화형 플랫폼 기술 (e.g. AI 스피커)로 주목받음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Digital Twins : 디지털 트윈(digital twin)은 미국 제너럴 일렉영(GE)이 주창한 개념으로, 컴퓨터에 현실 속 사물의 쌍둥이를 만들고, 현실에서 발생할 수 있는 상황을 컴퓨터로 시뮬레이션함으로써 결과를 미리 예측하는 기술이다. : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%94%94%EC%A7%80%ED%84%B8_%ED%8A%B8%EC%9C%88&quot;&gt;https://ko.wikipedia.org/wiki/디지털_트윈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cloud to the Edge (Computing) → Empowered Edge&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Edge : 중앙 서버와 같이 데이터 센터 보유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiexperience ← Immersive Experience  ← Virtual &amp;#x26; Augmented Reality ← Ambient User Experience&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성숙 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Distributed Ledgers → Blockchain → Practical Blockchain&lt;/li&gt;
&lt;li&gt;Event-Driven ← MASA: Mesh App and Service Architecture ← Mesh app, Iot arch&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안 패러다임 변화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이전 : 데이터 ← 기밀성, 무결성, 가용성&lt;/li&gt;
&lt;li&gt;최근 :  사람, 환경 ← 프라이버시, 안전성, 신뢰성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quantum Computing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;폰노이만 아키텍처를 탈피함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;멀티클라우드 : 여러 벤더가 제공하는 동일한 유형(퍼블릭 또는 프라이빗)의 클라우드를 여러개 배포&lt;/li&gt;
&lt;li&gt;하이브리드 클라우드 : 여러 배포 유형(퍼블릭 또는 프라이빗)이 있고 이들 사이에 통합 또는 오케스트레이션을 특정 방식으로 수행&lt;/li&gt;
&lt;li&gt;Democratization of Enterprise : 민주화됨을 의미&lt;/li&gt;
&lt;li&gt;Human Augmentation : 로봇 등으로 인간 증강함 e.g. &apos;엣지 오브 투모로우&apos;의 엑소슈트&lt;/li&gt;
&lt;li&gt;Distributed Cloud&lt;/li&gt;
&lt;li&gt;AI Security&lt;/li&gt;
&lt;li&gt;RPA(로보틱 처리 자동화), Hyperautomation&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[보안컨설팅과 보안 컨설턴트의 역량]]></title><description><![CDATA[Risk vs Issue risk는 예상(잠재) issue는 현재 일어난 것 Methodology(방법론) : Method + Knowledge DDD(Domain Driven Design…]]></description><link>https://kmkmi.github.io/보안컨설팅과 보안 컨설턴트의 역량/</link><guid isPermaLink="false">https://kmkmi.github.io/보안컨설팅과 보안 컨설턴트의 역량/</guid><pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Risk&lt;/strong&gt; vs &lt;strong&gt;Issue&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;risk는 예상(잠재)&lt;/li&gt;
&lt;li&gt;issue는 현재 일어난 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Methodology&lt;/strong&gt;(방법론) : Method + Knowledge&lt;/li&gt;
&lt;li&gt;DDD(Domain Driven Design) : 도메인 주도 설계&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안 컨설턴트의 요구 역량&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;경영진의 마인드, 경영의 흐름 읽기&lt;/li&gt;
&lt;li&gt;보안 기술적인 측면&lt;/li&gt;
&lt;li&gt;문제점과 현 상황 판단 능력, 분석력&lt;/li&gt;
&lt;li&gt;문서 작성 능력&lt;/li&gt;
&lt;li&gt;PT(presentation) 능력&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기밀 유지를 위한 &apos;윤리의식&apos;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보안 컨설턴트는 사내 민감 정보를 많이 파악하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;커뮤니케이션 능력&lt;/li&gt;
&lt;li&gt;보안 공격에 대한 방어 능력&lt;/li&gt;
&lt;li&gt;융합보안 트렌드 이해&lt;/li&gt;
&lt;li&gt;자기 감정 조절 능력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;People + Process + Technology 를 통한 보안 컨설팅&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마스킹 : 법률상 필수는 아니나 권고 사항이므로 불이익을 피하기 위해 대부분 기업들은 이름, 전화번호, 이메일 등을 마스킹함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마스킹 시 데이터의 특징을 분석해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;경영진은 숫자로 이야기하고 대안을 제시하는 직원을 원한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인증&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO 27001 : 국제 비즈니스 시 필요&lt;/li&gt;
&lt;li&gt;ISMS : 국내 기업 대상, ISO 27001 인증 받으면 수수료 감면됨&lt;/li&gt;
&lt;li&gt;ISMS-P : 개인정보보호 관리체계가 포함됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;벌금, 과태료, 과징금의 차이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;벌금은 사법상의 형벌(경미할 경우 과료)&lt;/li&gt;
&lt;li&gt;과태료는 행정상의 처분&lt;/li&gt;
&lt;li&gt;과징금은 행정상 처분이나 부당 이익의 환수조치 측면&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;취약점, 위협, 위험의 차이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;취약점은 고장난 문&lt;/li&gt;
&lt;li&gt;위협은 도둑&lt;/li&gt;
&lt;li&gt;위험은 손실된 자산&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[개인정보 개념 및 개인정보 보호 관련 법규]]></title><description><![CDATA[개인정보인 것(단독으로 또는 다른 정보와 쉽게 조합하여 특정 개인(살아있는)을 식별할 수 있는 것) 휴대전화번호 뒤 4자리 컴퓨터 IP…]]></description><link>https://kmkmi.github.io/개인정보 개념 및 개인정보 보호 관련 법규/</link><guid isPermaLink="false">https://kmkmi.github.io/개인정보 개념 및 개인정보 보호 관련 법규/</guid><pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개인정보인 것(단독으로 또는 다른 정보와 쉽게 조합하여 특정 개인(살아있는)을 식별할 수 있는 것)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;휴대전화번호 뒤 4자리&lt;/li&gt;
&lt;li&gt;컴퓨터 IP주소(단독으로도 개인정보가 될 수 있다!)&lt;/li&gt;
&lt;li&gt;차량번호(법인차량이면 아닐 수도)&lt;/li&gt;
&lt;li&gt;회사에서 부여한 사번&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보가 아닌 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;돌아가신 할아버지의 주민등록번호&lt;/li&gt;
&lt;li&gt;대표이사 또는 대표자의 성명(대표자이기 때문, 직원 이름은 개인정보다!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[개인정보 보호법] 제2조(정의) ← 개인정보의 법률적 의미&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.law.go.kr/%EB%B2%95%EB%A0%B9/%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%B2%95/(14839,20170726)&quot;&gt;http://www.law.go.kr/법령/개인정보보호법/(14839,20170726)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;가명정보&lt;/strong&gt;는 개인정보다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가명정보 : ~~에 따라 가명처리함으로써 원래의 상태로 복원하기 위한 추가 정보의 사용, 결합 없이는 특정 개인을 알아볼 수 없는 정보&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;즉 추가 정보의 사용, 결합으로 특정 개인 식별 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개인정보 수집 시 알리고 동의 받아&lt;/strong&gt;야하는 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개인정보의 수집 및 이용 목적&lt;/li&gt;
&lt;li&gt;수집하려는 개인정보의 항목&lt;/li&gt;
&lt;li&gt;개인정보의 보유 및 이용 기간&lt;/li&gt;
&lt;li&gt;동의를 거부할 권리가 있다는 사실 및 동의 거부에 따른 불이익이 있는 경우에는 그 불이익의 내용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;민감정보 : ① 사상•신념, ② 노동조합•정당의 가입•탈퇴, ③ 정치적 견해, ④ 건강, 성생활 등에 관한 정보, ⑤ 그 밖에 정보주체의 사생활을 현저히 침해할 우려가 있는 개인정보&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;민감정보, 고유식별번호&lt;/strong&gt;는 별도 동의를 받고 수집 가능&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;주민등록번호&lt;/strong&gt;는 주체의 별도 동의가 있어도 수집 불가&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;법령에 의해서만 수집 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;중요한 내용은 명확히&lt;/strong&gt; 표시해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. 민감정보, 고유식별번호, 불이익의 내용 등을 밑줄, 볼드체 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;개인정보처리자는 보유기간 경과, 개인정보의 처리 목적 달성 등 그 개인정보가 불필요하게 되었을 때에는 지체 없이 &lt;strong&gt;5(영업)일&lt;/strong&gt; 이내, 그 개인정보를 파기하여야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보통신서비스 제공자 등은 정보통신서비스를 &lt;strong&gt;1년&lt;/strong&gt;의 기간 동안 이용 안할 경우 이용자의 개인정보를 기간 만료 &lt;strong&gt;30일&lt;/strong&gt; 전까지 개인정보가 파기되는 사실, 기간 만료일 및 파기되는 개인정보 항목 등을 이용자에게 알려야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1년 미이용 고객 정보는 파기 혹은 파기에 준하는 별도 분리보관해야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ID 정도는 남겨놓을 수 있다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계정복구를 위해 최소한의 정보만 가능! ← 타당하고 사업자가 입증 가능해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개인정보 업무위탁&lt;/strong&gt; vs &lt;strong&gt;제3자 제공&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위탁 시 수탁사에 대해 위탁사가 관리감독하고 책임지도록 되어있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;법적으로 방문해야하는 것은 아니지만 보통 방문점검함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;위탁자의 업무를 위한 처리가 업무위탁, 제3자의 이익을 위한 처리 시 제3자 제공&lt;/li&gt;
&lt;li&gt;위탁 시에는 동의 받을 필요 없음, 제3자 제공은 제공에 대한 정보 주체의 동의 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;[개인정보 보호법]보다 [정보통신망법],[신용정보의 이용 및 보호에 관한 법률]이 우선함&lt;/li&gt;
&lt;li&gt;병원 내원 환자들에 대해서도 개인정보 수집 동의없이 개인정보 수집 가능 : [의료법]에 명시된 항목&lt;/li&gt;
&lt;li&gt;영상정보처리기기 설치 및 운영안내에 대한 안내판 설치는 잘 보이는 곳 한 곳(몇 곳)에 붙여도 된다.&lt;/li&gt;
&lt;li&gt;내부 직원에 대한 교육을 외부 업체에 위탁 시 위탁에 대한 동의를 직원들에게 받을 필요는 없지만 고지는 해야 한다.&lt;/li&gt;
&lt;li&gt;건물출입시에 출입증 교부를 위해 주민등록증을 받아 보관 시 정보주체로부터 개인정보 및 고유식별정보 수집 동의서 받지 않아도 된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기업에서 지원자들로부터 입사지원서를 접수받을 때 개인정보 수집, 이용 동의서를 받을 필요 없다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;관행적으로 동의서를 받기는 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;개인정보처리자는 비밀번호가 복호화되지 않게  반드시 일방향 암호화하여 저장해야 한다.&lt;/li&gt;
&lt;li&gt;쇼핑몰 비회원 주문의 경우 성명, 배송지주소 및 연락처, 비밀번호 등 간략한 정보만 수집하더라도 개인정보 안전성 조치 취해야 함&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;콜센터 고객 상담 시 자동으로 통화내용 녹취 시 고객에게 고지하지 않아도 됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대화 참여자의 녹취는 합법이다!&lt;/li&gt;
&lt;li&gt;관행적으로 고지하긴 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1년 미이용 고객의 개인정보를 별도 분리보관 한 경우, 대상 정보를 통계 등의 목적으로 이용 불가하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;별도 분리보관은 파기에 준하는 조치로 특별한 규정이 있는 경우 제외하고 제3자 제공 불가&lt;/li&gt;
&lt;li&gt;하지만 별도 분리보관 전 개인을 식별할 수 없는 상태에서 통계정보를 얻어 보관하는 것은 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;국가법령정보센터&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.law.go.kr&quot;&gt;www.law.go.kr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보보호 종합포털&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.privacy.go.kr&quot;&gt;www.privacy.go.kr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISMS-P 인증 기준 안내서&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보 유출 : 개인정보처리자가 통제를 상실 또는 권한 없는 자의 접근을 허용할 경우 모두 해당&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해커가 침투해서 빼간 경우&lt;/li&gt;
&lt;li&gt;개인정보가 들어있는 USB를 분실한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회사 고객의 개인정보 유출 시&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;법에 의한 처벌 - 벌금 최대 5,000만원&lt;/li&gt;
&lt;li&gt;소송에 의한 배상 - 손해배상금 + 소송 비용&lt;/li&gt;
&lt;li&gt;유무형 손실 - 매출 감소, 이미지 손실&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보의 안정성 확보 조치 기준 ← 개인정보보호법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제5조(접근 권한의 관리) : ~~에 의한 권한 부여, 변경 또는 말소에 대한 내역을 기록하고, 그 기록을 최소 &lt;strong&gt;3년간&lt;/strong&gt; 보관하여야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제6조(접근통제) : 개인정보 처리자는 개인정보취급자가 정보통신망을 통해 외부에서 개인정보처리시스템에 접속하려는 경우 가상사설망 또는 전용선 등 &lt;strong&gt;안전한 접속 수단을 적용하거나 안전한 인증수단을 적용&lt;/strong&gt;하여야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sms, 2차 비밀번호, IP접근제한, 문자인증, OTP 등이 안전한 인증수단&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비용이 많이 들어서 안하는 회사가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제7조(개인정보의 암호화)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;비밀번호 및 바이오 정보 암호화&lt;/strong&gt;해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비밀정보를 저장하는 경우에는 복호화되지 아니하도록 일방향 암호화하여 저장&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;고유식별정보를 저장하는 경우에는 이를 암호화&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;개인정보보호법 상에서는 이름, 전화번호, 주소 등은 암호화 의무 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제8조(접속기록의 보관 및 점검)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개인정보처리자는 개인정보취급자가 개인정보처리시스템에 접속한 기록 &lt;strong&gt;1년 이상&lt;/strong&gt; 보관,관리 해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;접속한 (일시, ip, 계정, 행위, 주체 정보) 5가지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고유식별정보 또는 민감정보는 &lt;strong&gt;2년 이상&lt;/strong&gt; 보관, 관리 해야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보처리자는 개인정보의 오,남용, 분실, 도난, 유출, 위조, 변조 또는 훼손 등에 대응하기 위하여 개인정보처리시스템의 접속기록 등을 &lt;strong&gt;월 1회&lt;/strong&gt; 이상 점검해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;특히 개인정보를 다운로드한 것이 발견되었을 경우에는 내부관리 계획으로 정하는 바에 따라 그 사유를 반드시 확인하여야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;개인정보처리자는 개인정보취급자의 접속기록이 위,변조 및 도난, 분실되지 않도록 해당 사유를 반드시 확인하여야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;개인정보처리자는 개인정보취급자의 접속기록이 위,변조 및 도난, 분실되지 않도록 해당 &lt;strong&gt;접속기록을 안전하게 보관&lt;/strong&gt;하여야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개인정보의 기술적,관리적 보호조치 기준 ← 정보통신망법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제4조(접근통제)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정보통신서비스 제공자들은 ~~에 의한 권한 부여, 변경 또는 말소에 대한 내역을 기록하고, 그 기록을 최소 &lt;strong&gt;5년&lt;/strong&gt; 간 보관한다.&lt;/li&gt;
&lt;li&gt;~~제공자들은 ~~정보통신망을 통해 외부에서 개인정보처리시스템에 접속이 필요한 경우 안전한 인증 수단 적용해야 한다.&lt;/li&gt;
&lt;li&gt;전년도 말 기준 직전 3개월간 그 개인정보가 저장,관리되고 있는 이용자 수가 일일평균 100만명 이상이거나 정보통신서비스 부문 전년도(법인인 경우에는 전 사업연도 의미) 매출액 100억원 이상인 정보통신서비스 제공자등은 개인정보처리시스템에서 &lt;strong&gt;개인정보를 다운로드 또는 파기할 수 있거나 개인정보시스템에 대한 접근권한을 설정&lt;/strong&gt;할 수 있는 개인정보취급자의 컴퓨터 등을 &lt;strong&gt;물리적  또는 논리적으로 망분리&lt;/strong&gt; 하여야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정보통신서비스 제공자등은 개인정보취급자를 대상으로 다음 각 호의 사항을 포함하는 비밀번호 작성규칙을 수립하고, 이를 적용 운용하여야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;영문, 숫자, 특수문자 중 2종류 이상을 조합하여 최소 10자리 이상 또는 3종류 이상을 조합하여 최소 8자리 이상의 길이로 구성&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;연속적인 숫자나 생일, 전화번호 등 추측하기 쉬운 개인정보 및 아이디와 비슷한 비밀번호는 사용하지 않는 것을 &lt;em&gt;권고&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비밀번호에 유효기간을 설정하여 &lt;em&gt;반기별&lt;/em&gt; 1회 이상 변경&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제5조(접속기록의 위,변조방지)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정보통신서비스 제공자들은 개인정보취급자가 개인정보처리시스템에 접속한 기록을 &lt;strong&gt;월 1회 이상&lt;/strong&gt; 정기적으로 확인,감독하여야 하며, 시스템 이상 유무의 확인 등을 위해 &lt;strong&gt;최소 1년 이상&lt;/strong&gt; 접속기록을 보존,관리하여야 한다.&lt;/li&gt;
&lt;li&gt;~~제공자들은 ~~취급자의 접속기록이 위,변조되지 않도록 별도의 물리적인 저장 장치에 보관하여야 하며 정기적인 백업을 수행하여야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제6조(개인정보의 암호화)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정보통신서비스 제공자들은 비밀번호는 복호화되지 아니하도록 일방향 암호화하여 저장한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~~제공자들은 다음 각 호의 정보에 대해서는 안전한 암호 알고리듬으로 암호화하여 저장한다. (비밀번호, 바이오정보는 일방향 암호화이며, 나머지는 양방향 암호화)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;주민등록번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;여권번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;운전면허번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;외국인등록번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신용카드번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;계좌번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;바이오정보&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;정보통신서비스 제공자들은 정보통신망을 통해 &lt;strong&gt;이용자의 개인정보 및 인증정보&lt;/strong&gt;를 송,수신할 때에는 안전한 보안서버 구축 등의 조치를 통해 이를 암호화해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[제4차 산업혁명의 정의와 특징]]></title><description><![CDATA[디지털 트랜스포메이션 : e.g. 코로나 언택트 시대 온라인 강의…]]></description><link>https://kmkmi.github.io/제4차 산업혁명의 정의와 특징/</link><guid isPermaLink="false">https://kmkmi.github.io/제4차 산업혁명의 정의와 특징/</guid><pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;디지털 트랜스포메이션 : e.g. 코로나 언택트 시대 온라인 강의&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4차 산업혁명의 정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디지털, 물리적, 생물학적 영역의 경계가 없어지면서 기술이 융합되는 인류가 한번도 경험하지 못한 새로운 세계&lt;/li&gt;
&lt;li&gt;제조기술 뿐만 아니라 데이터, 현대 사회 전반의 자동화 등의 총칭 Cyber-Physical System(&lt;strong&gt;CPS)&lt;/strong&gt;과 Iot, 인터넷 서비스 등의 모든 개념 포괄&lt;/li&gt;
&lt;li&gt;3개 세상의 융합이 만드는 산업혁명 : [현실+가상+인간]세계&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4차 산업혁명 3가지 특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;초연결성(IoT진화)&lt;/li&gt;
&lt;li&gt;초지능화(AI, 빅데이터)&lt;/li&gt;
&lt;li&gt;초융합(산업영역과 경계융합)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4차 산업혁명의 데이터의 대부분은 비정형 혹은 반정형 데이터&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비정형 데이터 : 텍스트, 이미지, 영상 등&lt;/li&gt;
&lt;li&gt;반정형 데이터 : html, xml 등&lt;/li&gt;
&lt;li&gt;3차 산업혁명까지는 정형 데이터 활용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4차 산업 혁명은 소프트 파워 바탕&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하드 파워 : 자원 → 생산품&lt;/li&gt;
&lt;li&gt;소프트 파워  : 상상아이디어 → 혁신적 서비스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;우리나라는 디지털 뉴딜을 추진 중&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IoT 기술&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;초광대역 (Ultra-wideband, UWB)&lt;/li&gt;
&lt;li&gt;Bluetooth Low Energy(BLE)&lt;/li&gt;
&lt;li&gt;지그비는 IEEE 802.15.4-2003을 기반으로 한 작고, 저전력의 디지털 라디오를 사용하는 하이레벨 통신 프로토콜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3V + 1V (빅데이터)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;volume, variety, velocity + value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[DFIR and Cyber Risk Leaders]]></title><description><![CDATA[Digital Forensics and Incident Response https://zeltser.com/digital-forensics-and-incident-response-disciplines/ Global Cybersecurity Camp…]]></description><link>https://kmkmi.github.io/DFIR and Cyber Risk Leaders/</link><guid isPermaLink="false">https://kmkmi.github.io/DFIR and Cyber Risk Leaders/</guid><pubDate>Sat, 04 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Digital Forensics and Incident Response&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zeltser.com/digital-forensics-and-incident-response-disciplines/&quot;&gt;https://zeltser.com/digital-forensics-and-incident-response-disciplines/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Global Cybersecurity Camp : &lt;a href=&quot;https://www.div0.sg/gcc&quot;&gt;https://www.div0.sg/gcc&lt;/a&gt;, &lt;a href=&quot;https://www.horangi.com/blog/horangi-and-global-cybersecurity-camp-gcc-empower&quot;&gt;https://www.horangi.com/blog/horangi-and-global-cybersecurity-camp-gcc-empower&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shotgun Forensics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Old school”&lt;/li&gt;
&lt;li&gt;Image everything&lt;/li&gt;
&lt;li&gt;Reliance on tools – autopilot&lt;/li&gt;
&lt;li&gt;Pull the plug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sniper Forensics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The process of taking a targeted, deliberate approach to
forensic investigations&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOC2 Compliance&lt;/strong&gt; (compliance like iso 27001)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tools and Samples&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fast IR&lt;/li&gt;
&lt;li&gt;Yara&lt;/li&gt;
&lt;li&gt;Open IOC(Indicators of Compromise, 침해지표)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cloud floyd is the deep learning platform : &lt;a href=&quot;https://www.floydhub.com/&quot;&gt;https://www.floydhub.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CISO&lt;/strong&gt;(Chief Information Security Officer) : 최고정보보호책임자&lt;/li&gt;
&lt;li&gt;Open source projects (e.g. androguard)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Security Monitoring&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIEM(Security information and event management)&lt;/li&gt;
&lt;li&gt;EDR(Endpoint Detection &amp;#x26; Response)&lt;/li&gt;
&lt;li&gt;SOC(Security Operation Center)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컴퓨터 비상 대응팀(computer emergency response team, CERT)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSIRT, Computer Security Incident Response Team : 컴퓨터 보안사고 대응팀&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red team : focused on penetration testing of different systems and their levels of security programs.&lt;/li&gt;
&lt;li&gt;Blue team : it also assesses network security and identifies any possible vulnerabilities. (지속적인 특성)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CERT vs. CSIRT vs. SOC: A look at the similarities, differences&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://searchsecurity.techtarget.com/tip/CERT-vs-CSIRT-vs-SOC-Whats-the-difference&quot;&gt;https://searchsecurity.techtarget.com/tip/CERT-vs-CSIRT-vs-SOC-Whats-the-difference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[수사 및 조사와 포렌식]]></title><description><![CDATA[조사와 수사는 강제성의 차이 증거 능력 요건 중 분석가의 전문성에 대한 요건 있음 정보보안의 추적 및 기소 방식에 디지털포렌식이 활용됨. e-디스커버리 : https://ko.wikipedia.org/wiki/전자_디스커버리 (민사 소송) hero…]]></description><link>https://kmkmi.github.io/수사 및 조사와 포렌식/</link><guid isPermaLink="false">https://kmkmi.github.io/수사 및 조사와 포렌식/</guid><pubDate>Sat, 04 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;조사와 수사는 강제성의 차이&lt;/li&gt;
&lt;li&gt;증거 능력 요건 중 분석가의 전문성에 대한 요건 있음&lt;/li&gt;
&lt;li&gt;정보보안의 추적 및 기소 방식에 디지털포렌식이 활용됨.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;e-디스커버리 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%9E%90_%EB%94%94%EC%8A%A4%EC%BB%A4%EB%B2%84%EB%A6%AC&quot;&gt;https://ko.wikipedia.org/wiki/전자_디스커버리&lt;/a&gt; (민사 소송)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hero(디지털포렌식 전문가를 일컬음) sheet 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어원 forum에서 forensic이 발생됨.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디지털포렌식: &lt;strong&gt;법적 목적으로 사용을 위한 디지털 증거 분석과 관련된 컴퓨터 과학 및 법적(수사) 절차의 적용&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디지털포렌식은 증거 사용을 위해 법정까지 증거를 가져다놓는 절차의 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 복구와 디스크 포렌식의 차이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스크 포렌식 안에 데이터 복구라는 기술이 포함됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;디지털포렌식의 일반원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;정당성(Legitimacy)의 원칙&lt;/strong&gt; : 위법수집증거배제법칙(형사소송법에 명시), 독수독과론&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;df에서 자료수집(data collection)이 가장 중요한 단계&lt;/li&gt;
&lt;li&gt;증거능력(유무)과 증명력(강약)(weight)의 구분&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;무결성(Integrity)의 원칙&lt;/strong&gt; : &lt;strong&gt;증거가 최초 수집된 이후&lt;/strong&gt; 법정에 제출될 때까지 변경이나 훼손 없이 보호되어야 한다. 디지털 증거는 위&lt;em&gt;변조가 쉽고, 위&lt;/em&gt;변조 탐지가 어려운 특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이미징 : 저장매체 물리적 데이터 (*.dd, *.ewf 등 )파일로 이미지 파일 내부 편집 불가 특징&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해시 함수 : 일방향 함수로 입력 데이터 변경되지 않음을 입증&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 법정에서 md5 사용 : md5의 안전성은 깨졌지만 단기간내 위조는 어렵다고 여겨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;연계보관성(Chain of Custody, CoC)의 원칙&lt;/strong&gt; : 보관의 사슬이라는 뜻, 일련의 과정 및 과정 마다의 담당자, 증거 상태가 명확해야 한다는 원칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;실제로는 무결성과 관련 없지만&lt;/strong&gt;(디지털 증거의 경우 Hash가 존재하기 때문에 CoC 문서의 연계보관성의 무결성에는 관계가 없다,하지만 전원 인가 시 트림 등 무결성 침해 요소 있을때에는 필요)&lt;strong&gt;,&lt;/strong&gt; 유체물 증거를 담당자가 육안으로 상태 확인하여 무결성 확인한다는 점에서 &lt;strong&gt;무결성과 밀접한 관계가 있다고 답해야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;증거 능력이 없는 경우에도 (e.g. 해시 값이 변경될 수 있는 상황이 있어도) 판결 시 증거 채택될 수 있음(자유 심증 주의)&lt;/li&gt;
&lt;li&gt;연계보관성은 증거의 하자의 치유, 하자의 보수에 있어서 중요함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;재현성(Reproducibility)의 원칙&lt;/strong&gt; :  동일한 조건과 동일한 상황에서의 디지털포렌식 분석은 항상 같은 결과를 도출해야 함, 분석 도구 및 방법, 분석자의 신뢰성(Reliability) 검증을 위한 방법으로 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NIST의 CFTT를 통해 도구의 신뢰성 검증 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;신뢰성(Immediacy)의 원칙&lt;/strong&gt; :  디지털포렌식 수행의 전 과정은 지체없이 신속하게 수행되어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변하기 쉬운 데이터에 대응, 피해에 빠른 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디지털포렌식 전문가 : 학회에서 능력을 인정하는 경우 인정됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;침해사고, 악성코드, 컴퓨터, 네트워크, 포렌식전문가 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;회계법인의 디지털포렌식(3~4달 소요)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;외부감사인이 부정 징후를 발견한 것을 회사가 외부전문가 고용, 외부전문가가 감사하고 그것을 감사인측 전문가가 다시 감사&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Positive Assurance&lt;/li&gt;
&lt;li&gt;Negative Assurance : 지금까지는 문제가 없다고 감사&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;De-NIST : 화이트리스트에 들어있는 파일 제외&lt;/li&gt;
&lt;li&gt;De-Dup : 중복 파일 제외&lt;/li&gt;
&lt;li&gt;Scope Limitation : 스코프 제한&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[정보보안 기초 개념]]></title><description><![CDATA[정보보안에는 우선순위가 필요 자산(Asset)의 가치 고려 피싱과 파밍의 차이 파밍은 도메인 주소 조작하여 정상 주소 접속하여 공격 당함 피싱은 가짜 도메인 주소에 접속하여 공격 당함 OSINT : https://ko.wikipedia.org/wiki…]]></description><link>https://kmkmi.github.io/정보 보안 기초 개념/</link><guid isPermaLink="false">https://kmkmi.github.io/정보 보안 기초 개념/</guid><pubDate>Sat, 04 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정보보안에는 우선순위가 필요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자산(Asset)의 가치 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;피싱과 파밍의 차이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파밍은 도메인 주소 조작하여 정상 주소 접속하여 공격 당함&lt;/li&gt;
&lt;li&gt;피싱은 가짜 도메인 주소에 접속하여 공격 당함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSINT : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%A4%EC%8B%A0%ED%8A%B8&quot;&gt;https://ko.wikipedia.org/wiki/오신트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;스피어 피싱과 APT 공격&lt;/li&gt;
&lt;li&gt;RAT(Remote Access Trojan, Remote Administration Tool)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;랜섬웨어&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가상화폐 등장으로 부각됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[디지털 포렌식의 학습]]></title><description><![CDATA[슬라이드 자료 : https://github.com/proneer/Slides…]]></description><link>https://kmkmi.github.io/디지털 포렌식의 학습/</link><guid isPermaLink="false">https://kmkmi.github.io/디지털 포렌식의 학습/</guid><pubDate>Sat, 04 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;슬라이드 자료 : &lt;a href=&quot;https://github.com/proneer/Slides&quot;&gt;https://github.com/proneer/Slides&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;디지털 데이터&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일시스템&lt;/li&gt;
&lt;li&gt;로그 : 정형적 산물&lt;/li&gt;
&lt;li&gt;아티팩트 : 경험적 산물, 절대적 지표가 아니므로 재현을 하여 입증&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사실 관계 규명&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타임라인 분석&lt;/li&gt;
&lt;li&gt;연관 분석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;증거가 제출되면 민사, 형사 경우 모두 기본적으로 상대측이 부동의하지 않으면 증거능력 가짐&lt;/li&gt;
&lt;li&gt;아이폰의 경우 brute-force로 암호 해제하여 분석&lt;/li&gt;
&lt;li&gt;포렌식 수사 시 압수 수색에서 선별하여 분석(시간 많이 소요)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SANS&lt;/strong&gt;DFIR : df 교육기관&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;디지털 포렌식 학습&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자주 접하는 파일시스템 우선 학습&lt;/li&gt;
&lt;li&gt;세부 데이터 구조 이해 → 큰 그림의 이해&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BitLocker : brute-force 거의 불가&lt;/li&gt;
&lt;li&gt;THIS WEEK IN 4N6 : 포렌식 뉴스 사이트&lt;/li&gt;
&lt;li&gt;실제 로그 분석 시 CentOS 많이 사용&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[해킹 공격과 포렌식]]></title><description><![CDATA[웹서버 데몬 : 아파치 등 로깅 시 풀 패킷 저장하지 않음 보안 룰 등에 맞춰 일부만 저장 네트워크에서 로깅을 할 경우 상위계층 정보는 열어볼 수 없어 알 수 없음 e.g. 방화벽은 port…]]></description><link>https://kmkmi.github.io/해킹 공격과 포렌식/</link><guid isPermaLink="false">https://kmkmi.github.io/해킹 공격과 포렌식/</guid><pubDate>Sat, 04 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;웹서버 데몬 : 아파치 등&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;로깅 시 풀 패킷 저장하지 않음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보안 룰 등에 맞춰 일부만 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네트워크에서 로깅을 할 경우 상위계층 정보는 열어볼 수 없어 알 수 없음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. 방화벽은 port주소까지 볼 수 있지만 응용 계층 정보를 볼 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;해커 컴퓨터 압수 시&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 브라우저 로그 확인(시크릿 모드 시 할 수 있는 것 없음)&lt;/li&gt;
&lt;li&gt;피들러 등 도구 사용(도구 기록 확인, 기록 저장 안되있을 시 할 수 있는 것 없음)&lt;/li&gt;
&lt;li&gt;직접 작성한 스크립트 사용(소스와 유저가 남긴 로그 없을 시 할 수 있는 것 없음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fiddler : 웹 디버그 툴&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;방화벽 분석은 해커 IP, Port와 접속 시간만 알 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 방화벽(WAF, Web Application Firewall)은 http(s) 패킷만 로깅&lt;/li&gt;
&lt;li&gt;알 수 있는 정보가 별로 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDS/IPS (L4 이상 주로 L7)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 프로토콜(TCP/IP) 패킷 데이터 확인(웹 방화벽 로깅의 상위 호환)&lt;/li&gt;
&lt;li&gt;IDS는 차단하지 않기 때문에 강경한 정책 적용 가능&lt;/li&gt;
&lt;li&gt;IPS는 차단 시 가용성에 문제&lt;/li&gt;
&lt;li&gt;최근 AI 도입 추세&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;로깅은 룰 위반 시에만 일어나기 때문에 룰 우회 시 로그 안 생김&lt;/li&gt;
&lt;li&gt;UTM(Unified Threat Management) : 통합위협관리&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http 대신 https 사용 시 공격이 성공하는 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPS가 고객으로부터 SSL 복호화 키를 제공받지 못한 경우(보안 정책을 우회)&lt;/li&gt;
&lt;li&gt;SSL 복호화 키를 받을 수도 있고, 키 제공을 꺼리는 고객도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안 업체는 IDS/IPS 룰셋에 많은 자원(인력)을 투자함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고객 요구 사항에 맞춰(발생하는 공격에 대응하여 지속적인) 룰셋 추가/수정&lt;/li&gt;
&lt;li&gt;룰 셋을 만드는 것이 업체의 실력의 척도&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모든 사이버 공격들이 사이버킬체인 7단계의 모든 단계를 수행하지는 않음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&apos;/bin/sh&apos;  문자열의 정규표현식 탐지 시 사용자가 예를들어 &apos;/bin/sh&apos; 문자열 포함한  게시글을 작성하면 오탐이 발생&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쉘 코드 아니어도 탐지하기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AI의 IDS/IPS의 적용은 상업적 목적이 크다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사업상 새로운 제품 개발 필요성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Supervised AI IDS/IPS의 경우 데이터 라벨링과 데이터 확보가 중요함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자체 또는 원격 보안 관제 시스템의 로그를 보고 공격인지 구분&lt;/li&gt;
&lt;li&gt;ids에 남은 로그는 ids/ips에 남은 로그 전제에 기반하기 때문에 전제에 부합해야 로깅됨&lt;/li&gt;
&lt;li&gt;IDS와 AI IPS의 제작 업체가 다른 경우 AI의 학습이 자사 IDS 로그 기반이기 때문에 성능이 안좋다.&lt;/li&gt;
&lt;li&gt;결론적으로 AI가 잘 적용 안되고 탐지가 잘 안된다.&lt;/li&gt;
&lt;li&gt;업체에서 정오탐 판별만 AI를 활용하는 추세&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unsupervised AI IDS/IPS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;세션 수(어느 소스에서 목적지로 몇개의 패킷이 전달됬는지, 패킷 크기 등)를 탐지&lt;/li&gt;
&lt;li&gt;Anomaly Detection : 공격 패턴을 학습하지 않고, 정상적 상황을 학습하여 이상한 상태를 탐지&lt;/li&gt;
&lt;li&gt;장비 구입 바로 사용하지 못하고 2~3달 간정상 상태를 학습하고서 사용할 수 있음(고객에 맞춰 학습해야되기 때문)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BMT(Benchmark Test)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[악성 소프트웨어 유형]]></title><description><![CDATA[…]]></description><link>https://kmkmi.github.io/악성 소프트웨어 유형/</link><guid isPermaLink="false">https://kmkmi.github.io/악성 소프트웨어 유형/</guid><pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;바이러스&lt;/strong&gt; : 프로그램에 기생해서 자신의 복제를 다른 프로그램으로 확산&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;웜&lt;/strong&gt; : 자신의 복제를 다른 컴퓨터로 확산&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;논리 폭탄&lt;/strong&gt; : 조건 충족 시 트리거 작동함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;트로이목마&lt;/strong&gt; : 생각지 못한 추가 기능(악의적) 포함하는 프로그램&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;백도어(트랩 도어)&lt;/strong&gt; : 기능에 허가받지 않은 접근 허용하는 프로그램의 변형&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모바일 코드&lt;/strong&gt; : 스크립트, 매크로나 다른 이동성 명령어 같은 SW, 서로 성격이 다른 많은 플랫폼으로 옮겨서 실행 가능하고 같은 기능 수행&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exploit&lt;/strong&gt; : 하나 혹은 여러 개의 취약점을 노리는 코드로 공격 시 타이밍 문제 또는 반복 작업 피하기 위해 적성된 자동화된 스크립트, 프로그램을 통칭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Downloaders&lt;/strong&gt; : 공격을 받는 컴퓨터에 다른 아이템을 설치하는 프로그램으로 보통 전자우편을 통해 전달됨&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dropper&lt;/strong&gt; : 공격 받는 컴퓨터에 설치되어 자신 내부에 있는 데이터 이용하여 악성코드 생성&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Auto-rooter&lt;/strong&gt; : 악성 해킹 도구로 새로운 시스템에 원격으로 침입할 때 사용하는 툴&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kit(Virus generator)&lt;/strong&gt; : 바이러스를 자동으로 생성하는 도구 모음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스패머 프로그램&lt;/strong&gt; : 원하지 않는 대량의 전자우편물을 보내는 데 사용&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;플러더(Flooders)(Dos Client)&lt;/strong&gt; : 네트워크 컴퓨터 시스템에 대량의 자료를 보내어 서비스 거부 공격을 감행하는 데 사용하는 코드&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Keyloggers&lt;/strong&gt; : 피해를 입은 시스템의 키 입력 갈취&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rootkit&lt;/strong&gt; : 컴퓨터 시스템에 침입 후 루트 수준의 접근허락을 얻기 위해 사용하는 해커 도구모음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;공격 킷(Attack kit)&lt;/strong&gt; : 다양한 번식 방법과 payload 기술을 사용하는 새로운 악성코드를 자동으로 만들어 주는 툴의 모음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;좀비(Zombie)&lt;/strong&gt; : 감염된 컴퓨터에서 활성화되는 프로그램으로 다른 컴퓨터에 대한 공격을 시작하는 데 사용됨&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스파이웨어&lt;/strong&gt; : 컴퓨터에서 정보를 수집해서 다른 시스템으로 전송하는 SW&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;애드웨어&lt;/strong&gt; : SW에 내장된 광고, 감염 시 팝업 광고가 뜨거나 브라우저가 광고 사이트로 연결함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;크라임웨어&lt;/strong&gt; : 온라인을 통해 불법적인 행동을 하기 위해 만들어진 프로그램&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;브라우저 하이재커&lt;/strong&gt; : 브라우저를 하이재킹하여 홈페이지와 검색 페이지, 툴바를 통제하고 조작하는 프로그램(잘못된 주소 입력 시 해커가 만들어논 사이트로 이동시킴)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;다이얼러(Dialers)&lt;/strong&gt; : 모뎀이 특정 번호(1-900)로 연결되도록 하여 전화 걸 때마다 공격자가 수익 얻게 만드는 프로그램&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;조크&lt;/strong&gt; : 실제 바이러스는 아니지만 사용자에게 심리적 위협을 주고 불안 조장하는 프로그램&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hoax&lt;/strong&gt; : 남을 속이거나 장난을 목적으로 퍼트리는 가짜 바이러스로, 일반적으로 허위 바이러스 경고 메일형태&lt;/p&gt;</content:encoded></item><item><title><![CDATA[알고리즘 기본 - 코딩, 디버깅]]></title><description><![CDATA[…]]></description><link>https://kmkmi.github.io/알고리즘 기본 - 코딩, 디버깅/</link><guid isPermaLink="false">https://kmkmi.github.io/알고리즘 기본 - 코딩, 디버깅/</guid><pubDate>Thu, 12 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;읽기 쉬운 코드&lt;/strong&gt; : 간결, 효율적, 디버깅 쉬워짐, 코드 완성도 높아짐&lt;/p&gt;
&lt;h1&gt;알고리즘 문제 풀이에서 좋은 코드 원칙&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;전역 변수 광범위한 사용&lt;/strong&gt;: 프로그램 흐름 파악에 안 좋지만,&lt;br&gt;
알고리즘 문제 풀이 시 작성 코드가 단순, 변수 사용하는 부분 파악이 명확해 잃는 것이 적음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;foreach 구문 사용&lt;/strong&gt;: 범위 기반 for문&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3항 조건 연산자 활용&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;반복되는 코드를 함수나 클래스로 분리&lt;/strong&gt;: 알고리즘 문제 풀이에서는 활용할 경우 적음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;표준 라이브러리 숙지&lt;/strong&gt;:  C++ STL(또는 JAVA Collection/Collections)에 이미 구현된 문자열, 동적 배열, 스택, 큐, 리스트, 사전 등 자료구조를 숙지해야 스스로 구현하는 실수 막을 수 있음&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;일관적이고 명료한 명명법 사용&lt;/strong&gt;: (e.g.) isDoSomething(int doing, int what)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;같은 자료는 같은 형태로 저장&lt;/strong&gt;: 형태, 단위 등 하나로 통일&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;코드와 데이터 분리&lt;/strong&gt;: 월을 출력 시 숫자 대신 &quot;Jan&quot;, &quot;Feb&quot; 등으로 출력,&lt;br&gt;
연산으로만 표현하는 대신 &lt;code class=&quot;language-text&quot;&gt;int move_left[2] = {1, -1};&lt;/code&gt;와 같이 왼쪽 이동을 배열로 저장함 &lt;/p&gt;
&lt;h1&gt;실수 주의&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;산술 오버플로우&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;배열 밖 원소 접근&lt;/strong&gt;: C/C++ 컴파일러가 확인해 주지 않음(성능을 위해)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스택 오버플로우&lt;/strong&gt;: call stack 오버플로우로 프로그램 강제종료됨, 재귀 함수 사용 시 재귀 호출 깊이 주의, 지역 변수는 스택 메모리 사용하므로 배열을 지역 변수로 사용하면 스택 오버플로우 나기 쉬움, 전역 변수 또는 힙에 메모리 할당하는 STL 컨테이너 사용&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;너무 느린 입출력 방식&lt;/strong&gt;: C++ cin, cout 등 고수준 입출력 방식 대신 printf, scanf 사용 권장(입출력 1만개 이상일 때 권장)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;변수 초기화&lt;/strong&gt;: 초기화 안하면 쓰레기 값 들어 있음 명심&lt;/p&gt;</content:encoded></item><item><title><![CDATA[소프트웨어 공학 - 애자일 프로세스, 스크럼]]></title><description><![CDATA[애자일 프로세스 출처 : https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C…]]></description><link>https://kmkmi.github.io/소프트웨어 공학 - 애자일 프로세스, 스크럼/</link><guid isPermaLink="false">https://kmkmi.github.io/소프트웨어 공학 - 애자일 프로세스, 스크럼/</guid><pubDate>Fri, 06 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;애자일 프로세스&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C&quot;&gt;출처 : https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC&lt;em&gt;%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4&lt;/em&gt;%EA%B0%9C%EB%B0%9C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아무런 계획이 없는 개발 방법과 계획이 지나치게 많은 개발 방법들 사이에서 타협점을 찾고자 하는 방법론&lt;/p&gt;
&lt;p&gt;계획이 없는 방법론의 경우, 앞으로의 일을 예측하기 힘들고 효율적이지 못하다는 점에서 취약점을 가지고 있으며,&lt;br&gt;
계획에 너무 의존하는 경우는 그 형식적인 절차를 따르는데 필요한 시간과 비용을 무시할 수 없으며, 전체적인 개발의 흐름 자체를 느리게 하는 단점&lt;/p&gt;
&lt;p&gt;폭포수 모델 또는 나선 모형과 구별되는 가장 큰 차이점은&lt;br&gt;
less document-oriented, 즉 문서를 통한 개발 방법이 아니라,&lt;br&gt;
code-oriented, 실질적인 코딩을 통한 방법론이라는 점&lt;/p&gt;
&lt;p&gt;소프트웨어를 포함한 IT의 개발은 경험적 프로세스 제어 모델로 접근할 필요가 있다.&lt;br&gt;
경험적 프로세스 제어 모델은 항상 불확실성을 수반하고 포용하고 있다.&lt;br&gt;
애자일 개발 프로세스는 경험적 프로세스 제어모델로 개발을 관리한다.&lt;/p&gt;
&lt;h1&gt;스크럼&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)&quot;&gt;출처 : https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC&lt;em&gt;(%EC%95%A0%EC%9E%90%EC%9D%BC&lt;/em&gt;%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;일본 히토츠바시 대학의 노나카 이쿠지로와 타케우지 히로타카가 1986년 1~2월 Harvard Business Review에 올린 &quot;The New New Product Developement Game&quot;에서 시작된다. &lt;/p&gt;
&lt;p&gt;프로젝트관리를 위한 상호,점진적 개발방법론이며, 애자일 소프트웨어 공학 중의 하나이다.&lt;br&gt;
스크럼(Scrum)은 소프트웨어 개발 프로젝트를 위하여 고안되었지만,&lt;br&gt;
소프트웨어 유지보수 팀이나 일반적인 프로젝트/프로그램 관리에서도 적용될 수 있다.&lt;/p&gt;
&lt;p&gt;스크럼은 특정 언어나 방법론에 의존적이지 않으며, 개발 언어는 물론이고 객체지향 언어와도 관련이 없는 넓은 응용 범위의 개발 기법이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;솔루션에 포함할 기능/개선점에 대한 우선 순위를 부여한다.&lt;/li&gt;
&lt;li&gt;개발 주기는 30일 정도로 조절하고 개발 주기마다 실제 동작할 수 있는 결과를 제공하라.&lt;/li&gt;
&lt;li&gt;개발 주기마다 적용할 기능이나 개선에 대한 목록을 제공하라.&lt;/li&gt;
&lt;li&gt;날마다 15분 정도 회의를 가져라.&lt;/li&gt;
&lt;li&gt;항상 팀 단위로 생각하라.&lt;/li&gt;
&lt;li&gt;원활한 의사소통을 위하여, 구분 없는 열린 공간을 유지하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스크럼의 기반(일본의 조직론에 이론적 기반) - 지식 창조 프로세스를 촉진시키는 5가지 요소&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조직의 의도 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지식 창조의 목표나 팀을 지탱하는 축&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자율성 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀의 멤버에게 자유로운 행동을 인정하는 열린 환경(시스템)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;역동적이고 창조적인 카오스 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;조직 내 외부 간의 역동적인 상호작용을 통한 지식창조 환경&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;잉여성 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의도적으로 조직에 넘쳐나는 여분의 정보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최소 유효 다양성 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡하고 다양한 환경에 기민하게 대응하기 위해서는 조직 구성원이 가져야 하는 다양성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스크럼이 추구하는 가치&lt;/h2&gt;
&lt;p&gt;스크럼은 다음의 5가지 가치에 중점을 두어 진행된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;확약 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;약속한 것을 확실히 실현하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전념 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;확약한 것의 실현에 전념하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정직 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 것이 자신에게 불리해도 숨기지 않는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;존중 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자신과 다른 사람에게 경의를 표하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;용기 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀 구성원 은 자신이 옳은 일을 할 수 있도록 팀원간 갈등과 도전을 통해 작업 할 수있는 용기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;스크럼의 진행&lt;/h2&gt;
&lt;p&gt;스크럼에서는, 30일간의 주기로 실제 동작하는 제품을 만들면서 개발을 진행시킨다.&lt;br&gt;
- 일반적인 권장기간은 30일 이지만, 스크럼 적응도 및 진행 상황에 따라 1주~4주의 유연성을 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제품 백로그(Product Backlog) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발할 제품에 대한 요구 사항 목록&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트(Sprint) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반복적인 개발 주기 (회사에서 정하는 이터레이션이 개발 주기가 된다. 계획 회의 부터 제품 리뷰가 진행 되는 날짜 까지의 기간이 1스프린트 이다)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트 계획 회의(Sprint Planning Meeting) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프린트 목표와 스프린트 백로그를 계획하는 회의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스프린트 백로그(Sprint Backlog) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일일 스크럼 회의(Daily Scrum Meeting) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;날마다 진행되는 미팅 (어제 한일, 오늘 할일, 장애 현상 등을 공유)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행 가능한 제품(shippable product) 개발 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프린트의 결과로써 나오는 실행 가능한 제품&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;상기 요소들을 아래와 같은 순서에 따라 사용하여 스크럼을 진행시킨다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;제품에서 요구하는 기능과 우선순위를 제품 백로그로 정한다.&lt;/li&gt;
&lt;li&gt;PO가 정한 제품의 우선순위에서 어디까지 작업을 할지 팀과 조율 한다. 조율하여 선정된 제품 백로그가 이번 스프린트의 목표가 된다.&lt;/li&gt;
&lt;li&gt;스프린트 목표를 구현 가능 하도록 팀에서 스프린트 백로그를 작성한 뒤 작업을 할당한다.&lt;/li&gt;
&lt;li&gt;스프린트를 진행하는 동안, 매일 정해진 장소와 시간에 모든 개발 팀원이 참여하는 일일 스크럼 회의를 가진다.&lt;/li&gt;
&lt;li&gt;매회의 스프린트가 종료할 때마다, 스프린트 리뷰 미팅을 통해 만들어진 제품을 학습하고 이해 한다.&lt;/li&gt;
&lt;li&gt;제품의 학습과 이해가 끝나면, 스프린트 회고를 통해 팀의 개발 프로세스에 대한 개선의 시간을 갖는다.&lt;/li&gt;
&lt;li&gt;스프린트 기간 중 다음 스프린트를 준비 하기 위해 PO와 필요 인원이 모여 백로그를 준비하는 시간을 갖는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제품 책임자(Product Owner) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품 백 로그를 정의하여 우선순위를 정해 준다.  제품 책임자는 스프린트 목표와 백로그등의 결정에 있어 중심이 되는 상위 관리자로, 제품 책임자가 독단적으로 목표를 결정하지 않고, 고객과 관리자 및 팀원들이 모여서 목표를 정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스크럼 마스터(ScrumMaster) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 관리자(코치), 일반적인 관리를 수행하는 프로젝트 관리자들과는 달리 팀원을 코칭하고 프로젝트의 문제 상황을 해결하는 역할을 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 과정을 거친 뒤, 개발 팀원들이 주도적으로 스프린트 목표를 달성하기 위한 작업을 정해 나가게 된다. 보통, 각 작업들은 4시간에서 16시간 정도 걸리도록 정한다. 물론, 작업을 정하고 할당하는데는 고객이나 제품 책임자와는 상관 없이 팀원 자율로 진행된다. 이와 같은 자율적인 행위를 통해서 팀원들은 의사를 활발하게 주고 받게 되고, 끈끈한 협업체계를 가지게 된다.&lt;/p&gt;
&lt;p&gt;애자일 프로세스는 외부로부터의 질서보다는 팀원 스스로가 만들어나가는 자기 조직화를 중요하게 여기고 있다. 하지만, 이러한 부분과 더불어 애자일 프로세스는 무질서해 보이기 때문에 전통적인 프로세스 개선과 마찰이 생기게 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리눅스 커널 (4) - 프로세스 스케줄링]]></title><description><![CDATA[프로세스 스케줄러 어떤 프로세스 얼마나 오랫동안 실행할지 결정 실행 중인 시스템 프로세스에 프로세서 동작 시간이라는 유한한 자원 분배 리눅스 같은 멀티태스킹 OS…]]></description><link>https://kmkmi.github.io/리눅스 커널 (4) - 프로세스 스케줄링/</link><guid isPermaLink="false">https://kmkmi.github.io/리눅스 커널 (4) - 프로세스 스케줄링/</guid><pubDate>Fri, 06 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;프로세스 스케줄러&lt;/h1&gt;
&lt;p&gt;어떤 프로세스 얼마나 오랫동안 실행할지 결정&lt;br&gt;
실행 중인 시스템 프로세스에 프로세서 동작 시간이라는 유한한 자원 분배&lt;br&gt;
리눅스 같은 멀티태스킹 OS의 기본 요소&lt;br&gt;
실행 프로세스 선택 과정을 통해, 시스템 최대 사용률 끌어내야 하고,&lt;br&gt;
사용자에게 여러 개의 프로세스가 동시에 실행되는 느낌을 줘야 함&lt;/p&gt;
&lt;p&gt;원리는 간단&lt;br&gt;
실행 가능한 프로세스가 있다면, 그 중 어떤 것이던 실행되야 함&lt;br&gt;
프로세서 개수보다 프로세스의 개수가 많다면 특정 순간에 일부 프로세스는 실행 중 아니게 됨&lt;br&gt;
이 경우 실행되기를 기다림&lt;br&gt;
스케줄러가 해결할 근본적 문제는 실행 가능한 프로세스 여러 개가 있을 때 어떤 프로세스를 다음에 실행할 것인가 결정하는 것  &lt;/p&gt;
&lt;h1&gt;멀티태스킹&lt;/h1&gt;
&lt;p&gt;멀티태스킹 OS : 하나 이상의 프로세스를 동시에 중첩 형태로 실행할 수 있는 OS&lt;/p&gt;
&lt;p&gt;멀티태스킹을 통해 프로세서 하나인 시스템에서도 여러 개의 프로세스를 동시 실행하는 느낌 줄 수 있음&lt;br&gt;
프로세서가 여러 개면 실제로 여러 프로세스 동시 실행 가능&lt;/p&gt;
&lt;p&gt;많은 프로세스 대기 상태 혹은 잠든 상태 될 수 있음(이 경우 메모리상에는 있지만 실행 가능한 상태 아님)&lt;br&gt;
커널은 이런 프로세스를 특정 조건(인터럽트) 발생전까지 대기 상태로 둠 &lt;/p&gt;
&lt;p&gt;메모리상엔 많은 프로세스 있을 수 있지만 현대 리눅스 시스템에서 실행 중인 프로세스는 하나뿐  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;멀티태스킹 운영체제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;협동형 멀티태스킹&lt;strong&gt;cooperative multitasking&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;선점형 멀티태스킹&lt;strong&gt;preemptive multitasking&lt;/strong&gt; : 프로세스 실행을 언제 중단하고 다른 프로세스 실행할지 스케줄러가 결정하는데 실행 중인 프로세스 강제 중지하는 작업을 선점&lt;strong&gt;preemption&lt;/strong&gt;이라 함, 리눅스도 이것 지원함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;선점형 멀티태스킹&lt;strong&gt;preemptive multitasking&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;프로세스가 선점되기 전까지 프로세스에 주어지는 시간 보통 미리 정해지고 프로세스의 타임슬라이스&lt;strong&gt;timeslice&lt;/strong&gt;라고 함&lt;br&gt;
타임슬라이스 관리하는 방식으로 전체적인 시스템 스케줄링 결정&lt;br&gt;
한 프로세스가 프로세서 독점 방지  &lt;/p&gt;
&lt;p&gt;요즘 OS 시스템 정책과 프로세스 동작 관련 함수 이용 동적으로 타임슬라이스 계산  &lt;/p&gt;
&lt;p&gt;리눅스 특유 &apos;공정&lt;strong&gt;fair&lt;/strong&gt;&apos; 스케줄러는 타임슬라이스 값을 그 자체로 적용 안하는 방식으로 동작  &lt;/p&gt;
&lt;p&gt;대부분 OS 선점형 멀티태스킹 지원
유닉스는 태초부터 선점형 멀티태스킹 지원&lt;/p&gt;
&lt;h2&gt;협동형 멀티태스킹&lt;strong&gt;cooperative multitasking&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;프로세스가 자발적으로 실행 중단 안하면 한 프로세스 중지 불가능&lt;br&gt;
프로세스가 자발적으로 동작 중단하는 행동을 양보&lt;strong&gt;yield&lt;/strong&gt;라고 함&lt;br&gt;
이상적으로 프로세스가 자주 양보해서 실행 중인 프로세스가 충분한 프로세서 동작 시간 확보 가능하지만 OS가 이것을 강제 불가함&lt;br&gt;
스케줄러가 실행 시간에 관해 전체적 결정 불가함&lt;br&gt;
사용자 의도보다 더 오래 독점할 가능성 있음&lt;br&gt;
양보하지 않는 큰 프로세스가 전체 시스템 먹통 만들 수 있음  &lt;/p&gt;
&lt;p&gt;Mac OS 9, 윈도우 3.1과 이것들의 이전버전이 해당됨&lt;/p&gt;
&lt;h1&gt;리눅스의 프로세스 스케줄러&lt;/h1&gt;
&lt;p&gt;2.5 커널에 도입된 O(1) 스케줄러 : 상수 시간 알고리즘 사용, 프로세서마다 별도의 실행 대기열&lt;strong&gt;queue&lt;/strong&gt; 사용으로 이전 스케줄러의 설계상 제약 제거함&lt;/p&gt;
&lt;p&gt;잘 동작하다 이후 문제 발견됨&lt;br&gt;
커다란 서버 작업에는 이상적이나&lt;br&gt;
응답시간에 민감한 애플리케이션인 대화형&lt;strong&gt;interactive&lt;/strong&gt; 프로세스가 중요한 데스크톱 시스템에서 평균 이하 성능 보임&lt;/p&gt;
&lt;p&gt;2.6 커널에 도입된 새로운 프로세스 스케줄러
회전 계단식 기한&lt;strong&gt;Rotating Staircase Deadline&lt;/strong&gt; 스케줄러 : 공정 스케줄링 개념을 큐잉 이론에서 빌려 적용함&lt;br&gt;
위로부터 영감을 받아 2.6.23 커널부터 &lt;strong&gt;CFS&lt;/strong&gt;라고 부르는 완전 공정 스케줄러가 O(1) 스케줄러 대신하게 됨&lt;/p&gt;
&lt;h1&gt;정책&lt;/h1&gt;
&lt;p&gt;정책&lt;strong&gt;Policy&lt;/strong&gt;는 스케줄러가 무엇을 언제 실행할 것인지를 정하는 동작을 말함&lt;br&gt;
스케줄러의 정책을 통해 시스템의 전체적인 느낌 정해지는 경향&lt;br&gt;
프로세서 시간의 사용을 최적화하는 책임이 있어 매우 중요함&lt;/p&gt;
&lt;h2&gt;입출력중심 프로세스와 프로세서중심 프로세스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스를 두 가지로 분류 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;입출력중심 프로세스 : 입출력 요청 후 기다리는데 대부분 시간 사용, 실제 실행시간 매우 짧음, (디스크, 키보드, 네트워크 등 대기 상태 발생 가능한 모든 시스템 자원의 입출력 대상) &lt;/li&gt;
&lt;li&gt;프로세서중심 프로세스 : 대부분의 시간 코드 실행에 사용, 보통 선점될때까지 계속 실행됨, 이런 프로세스 자주 실행할수록 시스템 반응 나빠짐, 좀 더 긴시간 덜 자주 실행하는게 좋음, 많은 양 수학적 계산 실행하는 ssh-keygen, MATLAB이 예시
위 분류는 상호배타적이지는 않음&lt;br&gt;
동시에 두 가지 특성 가질 수 있음 (e.g. X 윈도우 서버, 워드 프로세서)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시스템의 스케줄링 정책은 상충되는 두 가지 목적 달성하고자 함&lt;br&gt;
프로세스 응답시간(지연시간) 빠르게, 시스템 사용률 최대화(산출물&lt;strong&gt;throughput&lt;/strong&gt; 극대화) &lt;/p&gt;
&lt;p&gt;유닉스 시스템 스케줄러 정책은 입출력중심 프로세스에 관대한 경향 =&gt; 빠른 프로세스 응답시간&lt;br&gt;
리눅스도 대화형 작업에 쾌적한 응답시간과 데스크톱 성능 제공 목적으로 입출력중심 프로세스에 관대함 =&gt; 빠른 프로세스 응답시간&lt;br&gt;
리눅스는 독창적 방식으로 이 작업 구현하여 프로세서 중심 프로세스 소홀히 하지 않음&lt;/p&gt;
&lt;h2&gt;프로세스 우선순위&lt;/h2&gt;
&lt;p&gt;스케줄링 알고리즘 일반적 형태 : 우선순위 기반 스케줄링 = 가치와 필요에 따라 프로세스의 순위 매겨 프로세스 시간 할당&lt;br&gt;
일반적으로 우선순위 높은 프로세스 낮은 것보다 먼저 실행, 같은 경우 순환방식&lt;strong&gt;round-robin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;일부 시스템은 우선순위 높은 프로세스 타임슬라이스 길게 함&lt;/p&gt;
&lt;p&gt;시스템은 물론 사용자도 프로세스 우선순위 조작 가능&lt;/p&gt;
&lt;p&gt;리눅스 커널은 두 가지 별개의 우선순위 단위 가짐&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;나이스&lt;strong&gt;nice&lt;/strong&gt; 값 : -20 ~ +19 사이의 값 가짐, 기본값 0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클수록 우선순위 낮음(더 친절nice해짐)&lt;/li&gt;
&lt;li&gt;낮은 값 프로세스가 높은 것보다 프로세서 사용 시간 더 많이 할당받음&lt;/li&gt;
&lt;li&gt;유닉스 시스템 우선순위 표기 형식이지만 활용은 알고리즘마다 다르게 함(e.g. Mac OS X 등 유닉스 기반 OS는 nice 값으로 타임슬라이스 절대값 조절, 리눅스는 타임슬라이스 비율 조절, &lt;code class=&quot;language-text&quot;&gt;$ps -el&lt;/code&gt;로 시스템 ps목록과 각각의 나이스 값(NI 항목) 확인 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실시간 우선순위 : 0 ~ 99 사이의 값, 설정으로 범위 조절 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클수록 우선순위 높음&lt;/li&gt;
&lt;li&gt;모든 실시간 프로세스가 일반적 프로세스보다 높은값 가짐&lt;/li&gt;
&lt;li&gt;나이스 값과 별도의 값&lt;/li&gt;
&lt;li&gt;유닉스 표준 POSIX.1b에 따라 구현&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;$ps -eo state,uid,pid,ppid,rtprio,time,comm.&lt;/code&gt;의 rtprio항목으로 실시간 우선순위 확인 가능 (&apos;-&apos; 표시된 경우 실시간 프로세스 아님)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;타임슬라이스&lt;/h2&gt;
&lt;p&gt;타임슬라이스 너무 길면 시스템 대화형 성능 저하&lt;br&gt;
너무 짧으면 프로세스 전환 오버헤드 커짐(프로세서중심인 경우 불리함)&lt;br&gt;
입출력중심인지 프로세서중심인지 고려해야 함  &lt;/p&gt;
&lt;p&gt;많은 OS에서 기본 타임슬라이스 10ms로 설정&lt;/p&gt;
&lt;p&gt;리눅스 CFS 스케줄러 프로세스별로 프로세서 할당 비율 지정&lt;br&gt;
리눅스 프로세스 시간은 시스템 부하에 따른 함수로 결정됨&lt;br&gt;
이 할당값은 나이스 값에 영향 받음&lt;br&gt;
나이스 값은 가중치로 비율에 영향을 줌  &lt;/p&gt;
&lt;p&gt;리눅스는 새 프로세스가 현재 실행 중인 프로세스보다 낮은 비율의 프로세서 시간 사용 시 선점하고 즉시 실행됨&lt;br&gt;
그렇지 않으면 나중에 실행  &lt;/p&gt;
&lt;h2&gt;스케줄러 정책의 동작&lt;/h2&gt;
&lt;p&gt;대화형 작업에 많은 비율의 가용 프로세서 할당 : 프로세서 많이 필요하지 않지만 필요한 순간에 항상 프로세서 시간 얻기 위함, 깨어나는 순간 프로세서중심 프로세스 실행하는 프로세서 선점해야 함&lt;br&gt;
=&gt; 이렇게 해야 좋은 대화형 성능 보장 가능 &lt;/p&gt;
&lt;p&gt;많은 OS는 대화형 작업에 높은 우선순위, 긴 타임슬라이스 할당해 해결&lt;br&gt;
발전된 OS는 대화형 작업인지 자동 탐지하여 이 과정 수행&lt;br&gt;
리눅스는 다른 방법 사용  &lt;/p&gt;
&lt;p&gt;리눅스는 대화형 작업에 특정 우선순위, 타임슬라이스 할당하지 않고,&lt;br&gt;
일정 비율의 프로세서 시간 보장함  &lt;/p&gt;
&lt;p&gt;같은 나이스 값 가진 프로세스가 대화형 작업 A, 프로세서중심 작업 B 둘뿐이라면 이 비율은 50%임&lt;br&gt;
각 프로세스는 절반의 프로세서 시간 보장받음&lt;br&gt;
자연스럽게 대화형 작업이 입출력 기다리며 사용 시간 덜 사용하여 비율 커짐
대화형 작업이 깨어났을 때, CFS가 비율 차이를 알게 되고 A가 선점할 수 있게함
A가 다시 입출력 대기 상태로 들어가면 B가 실행됨&lt;/p&gt;
&lt;h1&gt;리눅스 스케줄링 알고리즘&lt;/h1&gt;
&lt;h2&gt;스케줄러 클래스&lt;/h2&gt;
&lt;p&gt;리눅스 스케줄러는 모듈화되어 있음&lt;br&gt;
여러 유형의 프로세스를 각기 다른 알고리즘 적용 스케줄링 가능  &lt;/p&gt;
&lt;p&gt;스케줄러 클래스 이용 교체 가능한 여러 알고리즘 동시 사용하며 클래스별로 독자적 방식 프로세스 스케줄링 가능&lt;/p&gt;
&lt;p&gt;각 스케줄러 클래스에 우선순위 존재&lt;br&gt;
kernel/sched.c에 정의된 기본 스케줄러 코드는 각 스케줄러 클래스를 우선순위에 따라 차례대로 실행함&lt;br&gt;
실행 가능한 프로세스가 있는 가장 우선순위 높은 스케줄러가 다음에 실행할 프로세스 선택함  &lt;/p&gt;
&lt;p&gt;CFS는 SCHED_NORMAL로 정의된(POSIX 표준에서는 SCHED_OTHER) 리눅스의 일반 프로세스용 스케줄러 클래스
CFS는 kernel/sched_fair.c에 정의됨  &lt;/p&gt;
&lt;h2&gt;유닉스 시스템의 프로세스 스케줄링&lt;/h2&gt;
&lt;p&gt;현대 프로세스 스케줄러의 두 가지 공통 개념 : 프로세스 우선순위, 타임슬라이스&lt;/p&gt;
&lt;p&gt;유닉스에서 우선순위 : 나이스 값 형태로 사용자 공간에 개방됨&lt;br&gt;
=&gt; 방법론적인 문제 존재 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;나이스 값과 타임슬라이스 연계시키려면 각 나이스 값에 할당할 타임슬라이스 절대값 정해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작업 전환이 최적화 잘 안됨 : 같은 우선순위 두 개 프로세스만 존재 시 두 프로세스의 우선순위가 높은 경우는 오래, 낮은 경우는 짧게 실행됨&lt;br&gt;
하지만 높은 우선순위인 경우 포어그라운드 사용자 작업, 낮은 우선순위 경우 백그라운드 프로세서중심 작업일 가능성 커서 비이상적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나이스 값 1 차이가 5ms의 타임슬라이스 차이를 만듬&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10ms와 5ms간의 차이와 100ms와 95ms간의 차이의 간극 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대부분 OS에서 타이머 클럭의 일정 배수로 타임슬라이스 단위 정해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타이머 틱이 10ms일수도 1ms일수도 있으므로, 타이머 틱보다 타임슬라이스 작아질 수 없고, 시스템 타이머에 타임슬라이스 차이가 의존적이게 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;깨어난 즉시 해당 작업 실행될 수 있도록 타임슬라이스 소진한 경우에도 해당 프로세스 우선순위 끌어올려 주고 싶은 경우 존재 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 프로세스가 나머지를 희생시키게 되는 불공정한 상황 만드는 방법론적 허점 야기함  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나이스 값에 따른 타임슬라이스 값을 선형이 아닌 기하적인 값 사용 시 2번째 문제 해결 가능&lt;/p&gt;
&lt;p&gt;나이스 값에 할당하는 타임슬라이스 단위를 타이머 틱에 영향 받지 않도록 정하여 3번째 문제 해결 가능&lt;/p&gt;
&lt;p&gt;하지만 타임슬라이스 값을 지정하는 고정된 전환 비율 사용 시 궁극적 해결책이 될 수 없음&lt;/p&gt;
&lt;p&gt;CFS는 작업 전환 비율 조정(타임슬라이스 값 무시하고 각 프로세스에 할당할 프로세서 비율 정함)을 통해 일정한 공정성 유지 &lt;/p&gt;
&lt;h2&gt;공정 스케줄링&lt;/h2&gt;
&lt;p&gt;단순한 개념 바탕&lt;br&gt;
이상적이고 완벽한 멀티태스킹 프로세서 가진 시스템의 프로세스 스케줄링 추구  &lt;/p&gt;
&lt;p&gt;실행 가능한 프로세스 n개 시,&lt;br&gt;
이상적 시스템 각 프로세스에 1/n의 프로세서 시간 할당,&lt;br&gt;
이런 프로세스를 무한히 작은 시간 단위로 스케줄링하여 특정 시간 안에 n개 프로세스 모두 동일 시간 동안 실행되게 할 수 있음&lt;/p&gt;
&lt;p&gt;표준 유닉스 방식에선 한 프로세스 5ms 실행 후 다른 것 5ms 실행(실행중인 프로세스가 프로세서 100% 사용하며)
이상적 완벽한 멀티태스킹 프로세서라면 10ms 동안 프로세서 50%씩 사용하는 두 프로세스 동시 실행 가능 &amp;#x3C;= 완전 멀티태스킹이라고 함&lt;/p&gt;
&lt;p&gt;하지만 한 프로세서에서 여러 개 프로세스 동시 실행 불가능하므로 비현실적인 방식임&lt;br&gt;
프로세스 전환 비용 때문에 극단적 짧은 시간 간격 실행은 비효율적  &lt;/p&gt;
&lt;p&gt;CFS는 각 프로세스 순차적으로 일정 시간 동안 실행하고, 가장 실행 덜 된 프로세스를 다음에 실행할 프로세스로 선택&lt;br&gt;
CFS는 프로세스별로 타임슬라이스 할당하기보다 실행 가능한 전체 프로세스 개수와 관련된 함수 이용 프로세스 실행 시간 계산&lt;br&gt;
CFS는 나이스 값 대신 프로세스에 할당할 프로세서 시간 비율의 가중치로 나이스 값을 사용함&lt;br&gt;
우선순위 낮고 나이스 값 높을수록 프로세스는 낮은 가중치를 받고, 우선순위 높고 나이스 값 낮을수록 높은 비율 가중치 받음&lt;/p&gt;
&lt;p&gt;각 프로세스 실행 시간 =  (자신의 가중치)/(실행 가능한 전체 프로세스 가중치 총합) 비율 해당하는 크기만큼의 타임슬라이스 동안&lt;/p&gt;
&lt;p&gt;CFS는 실제 타임슬라이스 값 계산 위해 완전 멀티태스킹의 무한히 작은 스케줄링 단위를 근사할 수 있는 목표치 정해 놓음&lt;br&gt;
이 목표치(전체 프로세스에 대한 시간)를 목표 응답시간이라고 함&lt;br&gt;
목표치가 작을수록 대화형 성능 좋아지고 완전 멀티태스킹에 가까워짐&lt;br&gt;
하지만 전환비용 커지기 때문에 전체 시스템 효율 나빠짐&lt;/p&gt;
&lt;p&gt;CFS는 타임슬라이스 최소 한계 가짐 = 최소 세밀도&lt;strong&gt;minimum granularity&lt;/strong&gt; &amp;#x3C;= 기본값 1ms&lt;br&gt;
비율이 최소 세밀도보다 낮아지면 완벽히 공정하게 작동 못함, 개선 방법 존재하긴 함&lt;/p&gt;
&lt;p&gt;CFS는 나이스 값의 절대적 크기가 아닌 상대적 차이가 시간 할당 비율에 영향 줌&lt;/p&gt;
&lt;h1&gt;리눅스 스케줄링 구현&lt;/h1&gt;
&lt;p&gt;CFS 실제 구현은 kernel/sched_fair.c에 있음&lt;/p&gt;
&lt;p&gt;CFS의 네가지 구성요소
- 시간 기록
- 프로세스 선택
- 스케줄러 진입 위치
- 휴면 및 깨어남&lt;/p&gt;
&lt;h2&gt;시간 기록&lt;/h2&gt;
&lt;p&gt;모든 프로세스 스케줄러는 각 프로세스 실행시간 기록해야 함&lt;br&gt;
대부분 유닉스 시프템은 프로세스에 타임슬라이스 할당하며 기록함  &lt;/p&gt;
&lt;h3&gt;스케줄러 단위 구조체&lt;/h3&gt;
&lt;p&gt;CFS에는 타임슬라이스 개념 없지만 실행시간 기록해 두어야 함&lt;br&gt;
&amp;#x3C;linux/sched.h&gt;에 정의된 struct sched_entity라는 스케줄러 단위 구조체 사용해 관련 정보 저장&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sched_entity&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;load_weight&lt;/span&gt;	load&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;rb_node&lt;/span&gt;		run_node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;list_head&lt;/span&gt; 	group_node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; 		on_rq&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			exec_start&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			sum_exec_runtime&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			vruntime&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			prev_sum_exec_runtime&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			last_wakeup&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			avg_overlap&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			nr_migrations&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			start_runtime&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	u64			avg_wakeup&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// CONFIG_SCHEDSTATS 값 설정 시 사용하는 통계용 변수 생략됨&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;스케줄러 단위 구조체는 프로세스 서술자인 struct task_struct 구조체에 se 항목으로 들어 있음&lt;/p&gt;
&lt;h3&gt;가상 실행시간&lt;/h3&gt;
&lt;p&gt;vruntime 변수에는 프로세스의 가상 실행시간 저장됨  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[캐시 컬러링(페이지 컬러링)]]></title><description><![CDATA[캐시 컬러링Cache coloring(=페이지 컬러링Page coloring) 출처 : 위키피디아 프로세서에 의해 캐시된 총 페이지 수를 최대화하기 위해, CPU 캐시에게 인접한 free page를 할당하려는 시도의 과정 OS의 low-level…]]></description><link>https://kmkmi.github.io/캐시 컬러링(페이지 컬러링)/</link><guid isPermaLink="false">https://kmkmi.github.io/캐시 컬러링(페이지 컬러링)/</guid><pubDate>Tue, 03 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;캐시 컬러링&lt;strong&gt;Cache coloring&lt;/strong&gt;(=페이지 컬러링&lt;strong&gt;Page coloring&lt;/strong&gt;)&lt;/h1&gt;
&lt;p&gt;출처 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_coloring&quot;&gt;위키피디아&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;프로세서에 의해 캐시된 총 페이지 수를 최대화하기 위해,&lt;br&gt;
CPU 캐시에게 인접한 free page를 할당하려는 시도의 과정&lt;br&gt;
OS의 low-level dynamic memory allocation code에 가상 메모리를 물리 메모리로 매핑할 때 자주 사용됨&lt;br&gt;
한 프로그램에서 다음 것까지로의 페이지 할당에서의 차이는 프로그램 퍼모먼스의 큰 차이로 이어질 수 있음에 따라,&lt;br&gt;
캐시 컬러링이 안되는 가상 메모리 서브시스템은 캐시 퍼포먼스 관련하여 덜 deteministic 함  &lt;/p&gt;
&lt;p&gt;물리적으로 인덱스된 CPU 캐시는 인접한 주소의 물리 메모리 블럭들이 다른 위치에 캐시되도록 디자인되어 있지만, 가상 메모리 경우는 아니다.&lt;br&gt;
가상 메모리에서 인접했지만 물리 메모리에서 인접하지 않은 메모리 블럭들이 할당될 때, 그들은 잠재적으로 같은 위치에 캐시될 수 있다.&lt;br&gt;
컬러링은 이웃 페이지들과 경쟁하지 않을 페이지를 선택하는 방법으로 위 문제를 해결하는 메모리 관리 소프트웨어에 적용되는 기법이다.&lt;br&gt;
캐시 컬러링에서 물리 메모리 페이지들은 다른 &quot;colors&quot;의 페이지들이 CPU 캐시 메모리의 다른 위치에 캐시되도록 &quot;colored&quot;된다.&lt;br&gt;
가상 메모리에 프로세스들을 위해 연속된 페이지를 할당할 때, 커널은 다른 &quot;colors&quot;의 페이지들을 모으고 그것들을 가상 메모리에 매핑한다.&lt;br&gt;
이 방법으로, 연속된 페이지들은 가상 메모리에서 같은 캐시 라인에 캐시되기 위해 경쟁하지 않게 된다.  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[리눅스 커널 (3) - 프로세스 관리]]></title><description><![CDATA[…]]></description><link>https://kmkmi.github.io/리눅스 커널 (3) - 프로세스 관리/</link><guid isPermaLink="false">https://kmkmi.github.io/리눅스 커널 (3) - 프로세스 관리/</guid><pubDate>Thu, 28 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;프로세스&lt;/h1&gt;
&lt;p&gt;프로세스는 실행 중인 프로그램(특정 매체에 저장된 오브젝트 코드)&lt;br&gt;
하지만 프로세스는 사용 중인 파일, 대기 중인 시그널, 커널 내부 데이터, 프로세서 상태, 하나 이상의 물리적 메모리 영역이 할당된 메모리 주소 공간, 실행 중인 하나 이상의 스레드 정보, 전역 데이터가 저장된 데이터 부분 등 모든 자원을 포함하는 개념&lt;/p&gt;
&lt;p&gt;사실상 프로세스는 프로그램 코드를 실행하면서 생기는 모든 결과물&lt;/p&gt;
&lt;p&gt;커널은 이 모든 세부 사항을 투명하고 효율적인 방식으로 관리해야 함&lt;/p&gt;
&lt;p&gt;실행 중인 스레드(보통 줄여서 스레드라 칭하는)는 프로세스 내부에서 동작하는 객체&lt;br&gt;
각 스레드는 개별적인 프로그램 카운터와 프로세스 스택, 프로세서 레지스터를 가지고 있음  &lt;/p&gt;
&lt;p&gt;커널은 프로세스가 아니라 이러한 각각의 스레드를 스케줄링 함&lt;/p&gt;
&lt;p&gt;전통적인 유닉스 시스템 : 프로세스가 하나의 스레드로 구성&lt;br&gt;
현대 시스템 : 여러 개의 스레드로 구성된 다중 스레드 프로그램 만연  &lt;/p&gt;
&lt;p&gt;리눅스는 독특한 방식으로 스레드 구현&lt;br&gt;
리눅스는 프로세스와 스레드 구분 안함&lt;br&gt;
리눅스에서 스레드는 조금 특별한 형태의 프로세스일 뿐&lt;/p&gt;
&lt;p&gt;현대 운영체제에서 프로세스는 가상 프로세서와 가상 메모리라는 두 가지 가상 환경 제공&lt;br&gt;
가상 프로세서는 실제로 수백 개의 프로세스가 프로세서를 공유하는 상황이라도, 프로세스가 혼자 시스템을 사용하는 듯한 가상 환경 제공&lt;br&gt;
가상 메모리는 프로세스가 시스템의 전체 메모리를 혼자 차지하고 있는 것처럼 메모리를 할당하고 관리할 수 있게 해줌  &lt;/p&gt;
&lt;p&gt;스레드는 각자 고유한 가상 프로세서를 할당받지만 가상 메모리는 공유함 &lt;/p&gt;
&lt;p&gt;프로그램 자체는 프로세스가 아님&lt;br&gt;
프로세스는 작동 중인 프로그램 및 그와 관련된 자원을 뜻함&lt;br&gt;
같은 프로그램 실행하는 둘 이상의 프로세스 존재 가능&lt;br&gt;
여러 프로세스가 같이 파일 사용, 주소 공간 등의 자원 공유 가능&lt;/p&gt;
&lt;p&gt;프로세스는 생성되면서 생을 시작&lt;br&gt;
리눅스에서는 기존 프로세스를 복사해서 새 프로세스를 만드는 fork() 시스템 호출을 통해 프로세스가 만들어짐&lt;br&gt;
fork()를 호출하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 됨&lt;br&gt;
부모 프로세스는 fork() 시스템 호출이 반환된 지점에서 실행을 계속, 자식 프로세스도 같은 위치에서 실행 시작&lt;br&gt;
즉, fork() 시스템 호출은 부모 프로세스에서 한 번, 자식 프로세스에서 한 번, 총 두 번 반환이 일어남  &lt;/p&gt;
&lt;p&gt;대개의 경우 fork한 직후 다른 새 프로그램 실행&lt;br&gt;
exec() 계열의 함수를 호출해 새로운 주소 공간 만들고 새 프로그램 불러들일 수 있음&lt;br&gt;
리눅스 커널의 fork() 시스템 호출은 실제로는 clone() 시스템 호출을 이용해 구현됨  &lt;/p&gt;
&lt;p&gt;프로그램은 exit() 시스템 호출을 통해 종료됨&lt;br&gt;
이 함수는 프로세스를 종료하고 프로세스의 모든 자원 반납&lt;br&gt;
부모 프로세스는 특정 프로세스가 종료할 때까지 기다리는 wait4() 시스템 호출을 이용해 자식 프로세스의 종료 상태 확인 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널이 구현하는 것은 wait4() 시스템 호출. 리눅스 시스템은 C 라이브러리를 통해 일반적인 wait(), waitpid(), wait3(), wait4() 함수를 제공함. 각 함수는 조금씩 다르지만 모두 종료된 프로세스의 상태 정보 제공함&lt;/li&gt;
&lt;li&gt;프로세스를 다른 말로 태스크(task, 작업)라고도 부름. 리눅스 커널 내부에서는 프로세스를 태스크라고 부르는 경우 많음. 보통 커널 관점에서 프로세스 지칭 시 태스크라는 용어 사용 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;프로세스 서술자와 태스크 구조체&lt;/h1&gt;
&lt;p&gt;커널은 프로세스 목록을 태스크 리스트라고 부르는 환형 양방향 연결 리스트 형태로 저장(태스크 배열로 부르는 경우도 있지만 연결 리스트이므로 태스크 리스트가 적절)&lt;br&gt;
태스크 리스트의 각 항목은 &amp;#x3C;linux/sched.h&gt;에 정의된 struct task_struct 형식으로 되어 있으며, 프로세스 서술자라고 부름&lt;br&gt;
프로세스 서술자에는 해당 프로세스와 관련된 모든 정보가 들어 있음  &lt;/p&gt;
&lt;p&gt;task_struct 구조체는 32비트 시스템에서 약 1.7KB의 상당히 큰 구조체&lt;br&gt;
커널이 프로세스를 관리하는데 필요한 모든 정보를 가지고 있다는 점을 감안 시 이 크기는 작은 것  &lt;/p&gt;
&lt;p&gt;프로세스 서술자에는 사용 중인 파일, 프로세스의 주소 공간, 대기 중인 시그널, 프로세스의 상태 등 실행 중인 프로그램을 설명하는 많은 정보가 들어 있음&lt;/p&gt;
&lt;h2&gt;프로세스 서술자의 할당&lt;/h2&gt;
&lt;p&gt;task_struct 구조체는 객체 재사용 및 &lt;a href=&quot;http://kmkmi.github.io/%EC%BA%90%EC%8B%9C%20%EC%BB%AC%EB%9F%AC%EB%A7%81(%ED%8E%98%EC%9D%B4%EC%A7%80%20%EC%BB%AC%EB%9F%AC%EB%A7%81)/&quot;&gt;캐시 컬러링&lt;/a&gt; 기능을 지원하는 슬랩 할당자&lt;strong&gt;slab allocator&lt;/strong&gt;를 사용해 할당  &lt;/p&gt;
&lt;p&gt;2.6 커널 이전에는 task_struct 구조체를 각 프로세스의 커널 스택 끝 부분에 저장했음&lt;br&gt;
(이렇게 하면 x86처럼 레지스터가 적은 아키텍처에서는 구조체 위치를 저장하는 레지스터를 별도로 사용하지 않고도 스택 포인터 통해 프로세스 서술자 위치 계산 가능했었음)&lt;br&gt;
이제는 슬랩 할당자 이용 동적으로 프로세스 서술자 만들기 때문에 thread_info라는 새로운 구조체를 스택이 아래쪽으로 확장 시 스택 밑바닥, 위쪽으로 확장 시 스택 꼭대기에 대신 둠&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레지스터 부족 시스템 위해서만 아니라 thread_info 구조체 사용으로 어셈블리 코드에서 사용하는 값 오프셋 계산을 쉽게 할 수 있도록 함 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 태스크의 thread_info 구조체는 프로세스 스택의 제일 끝부분에 할당됨&lt;br&gt;
구조체의 task 포인터가 태스크의 실제 task_struct 구조체를 가리킴  &lt;/p&gt;
&lt;h2&gt;프로세스 서술자 저장&lt;/h2&gt;
&lt;p&gt;시스템은 고유한 프로세스 인식 번호(PID)를 이용해 프로세스 구별함&lt;br&gt;
PID는 pid_t라는 부정형&lt;strong&gt;opaque&lt;/strong&gt;의 숫자 값으로, 보통은 실제로 int 형 사용함&lt;br&gt;
하지만 초기 유닉스 및 리눅스와의 하위 호환성 문제로 PID 최대값은 기본적으로 (short int 최대값인) 32,768이며, 이 값은 선택적으로(&amp;#x3C;linux/thread.h&gt; 파일을 통해) 400만으로 상향 조정 가능&lt;br&gt;
커널은 PID 값을 프로세스 서술자의 pid 항목에 저장  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부정형은 실제 물리적인 표현형 알려지지 않았거나 실제 표현형 노출할 필요 없을 때 사용하는 형이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;p&gt;근본적으로 PID 최대값은 시스템에 동시에 존재할 수 이쓴 최대 프로세스 수&lt;br&gt;
일반 데스크탑 시스템은 32,768개 충분하지만, 대용량 서버에서는 더 많은 프로세스 필요할 수 있음&lt;br&gt;
최대값이 낮을수록 상항을 넘어 다시 낮은 PID값 할당되는 상황 빨리 돌아옴&lt;br&gt;
=&gt; 이 경우 나중에 만든 프로세스 PID가 큰 값을 갖는다는 유용한 정보 사라짐&lt;/p&gt;
&lt;p&gt;오래된 애플리케이션과의 호환성 고려할 필요 없다면, 시스템 관리자가 /proc/sys/kernel/pid_max 값 수정해 최대값 증가 가능  &lt;/p&gt;
&lt;p&gt;커널 내부에서 태스크에 접근할 때 보통 task_struct 구조체의 포인터를 사용함&lt;br&gt;
따라서 현재 실행 중인 태스크의 프로세스 서술자를 빠르게 찾는 방법 필요 =&gt; current 매크로가 이 역할을 함  &lt;/p&gt;
&lt;p&gt;current 매크로 : 아키텍처별로 다른 방식으로 구현됨&lt;br&gt;
어떤 아키텍처는 현재 실행 중인 프로세스의 task_struct 포인터를 레지스터에 저장해 두고 접근하는 효율적인 방식을 쓸 수 있음&lt;br&gt;
(레지스터를 아껴야 하는)x86 같은 아키텍처에서는 thread_info 구조체가 커널 스택에 저장된다는 사실을 이용해 thread_info 구조체의 위치를 계산해내고, 이를 통해 task_struct의 위치 알아냄  &lt;/p&gt;
&lt;p&gt;x86의 current 매크로는 스택 포인터의 하위 13비트를 덮어쓰는 방식으로 thread_info 구조체 위치 계산해냄&lt;br&gt;
current_thread_info() 함수가 이 역할을 담당함&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;nasm&quot;&gt;
      &lt;pre class=&quot;language-nasm&quot;&gt;&lt;code class=&quot;language-nasm&quot;&gt;movl &lt;span class=&quot;token operator&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8192&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token register variable&quot;&gt;eax&lt;/span&gt;
andl &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token register variable&quot;&gt;esp&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token register variable&quot;&gt;esp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이 코드는 스택 크기가 8KB라고 가정함. 4KB 스택 사용 시 8192 대신 4096을 사용.&lt;/p&gt;
&lt;p&gt;마지막으로, 이 current 매크로는 thread_info의 항목을 참조해 task_struct 구조체를 반환&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;current_thread_info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;IBM의 RISC기반 PowerPC에서는 이와 다른 방식 사용하는데, 레지스터에 현재 task_struct 포인터를 저장하는 방식 사용함&lt;br&gt;
따라서 PPC에서 current 매크로는 r2 레지스터에 저장된 값을 반환하기만 하면 된다.&lt;br&gt;
프로세스 서술자에 접근하는 것은 매우 빈번하고 중요한 작업이기 때문에 이를 별도 레지스터를 할당할 만한 작업이라고 판단했기 때문&lt;/p&gt;
&lt;h2&gt;프로세스 상태&lt;/h2&gt;
&lt;p&gt;프로세스 서술자의 state 항목은 현재 프로세스가 처한 환경을 알려줌&lt;br&gt;
시스템의 프로세스는 정확히 다섯 가지 상태 중 하나에 있음&lt;br&gt;
각 상태값은 다음 다섯 가지 플래그를 이용해 표현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TASK_RUNNING - 프로세스가 실행 가능한 상태. 현재 실행 중이거나 실행되기 위해 실행 대기열에 있는 상태. 사용자 공간에서 실행된 프로세스는 이 상태만 가질 수 있음. 커널 공간에서 실행 중인 프로세스도 이 상태에 속함.&lt;/li&gt;
&lt;li&gt;TASK_INTERRUPTIBLE - 프로세스가 특정 조건이 발생하기를 기다리며 쉬는 중임(중단). 기다리는 조건이 발생하면 커널은 프로세스의 상태를 TASK_RUNNING으로 바꾼다. 프로세스가 시그널을 받은 경우에는 조건에 상관없이 실행 가능한 상태로 바뀜.&lt;/li&gt;
&lt;li&gt;TASK_UNINTERRUPTIBLE - 시그널을 받아도 실행 가능 상태로 바뀌지 않는 점 제외하면 TASK_INTERRUPTIBLE 상태와 같음. 이 상태는 프로세스가 방해받지 않고 특정 조건을 기다려야 하는 경우, 기다리는 조건이 금방 발생하는 경우에 사용. 이 상태에 있는 태스크는 시그널에 응답 안 하므로(이것 때문에 ps(1) 명령 결과에 D 상태로 ㅍ시되는 죽일 수 없는 프로세스가 등장하는 이유. 작업이 시그널에 응답 안 하므로 SIGKILL 시그널 보낼 수 없음. 게다가, 작업 종료가 가능해도 중요한 동작을 수행 중이거나 세마포어 사용 작업일 수 있으므로 종료 안 하는 것이 바람직), 이 플래그는 TASK_INTERRUPTIBLE만큼 자주 사용 안 함.&lt;/li&gt;
&lt;li&gt;__TASK_TRACED - 디버거 등의 다른 프로세스가 ptrace를 통해 해당 프로세스를 추적하는 상태&lt;/li&gt;
&lt;li&gt;__TASK_STOPPED - 프로세스 실행이 정지된 상태. 해당 태스크는 실행 중이지도 않고 실행 가능한 상태도 아님. 작업이 SIGSTOP, SGTSTP, SIGTTIN, SIGTTOU 같은 시그널을 받은 경우 디버그 중에 시그널을 받은 경우에 이 상태가 이 상태가 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;현재 프로세스 상태 조작&lt;/h2&gt;
&lt;p&gt;커널 코드에서 프로세스의 상태를 바꿀 필요가 생기는 경우 많음.&lt;br&gt;
다음 함수를 사용하기를 권장&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;set_task_state&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 태스크 &apos;task&apos;의 상태를 &apos;state&apos; 상태로 설정&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이 함수는 특정 태스크의 상태를 지정한 상태로 변경. 그리고 필요한 경우, 이 함수는 메모리 보호 기능 이용 다른 프로세서와 작업 순서 겹치는 것 방지(대칭형 다중 프로세스 시스템에서 이 기능 필요).  &lt;/p&gt;
&lt;p&gt;대칭형 다중 프로세스 시스템 경우 고려할 것을 빼면 이 함수는 다음 동작을 함&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;set_current_state(state) 함수는 set_task_state(current, state) 함수와 같음.&lt;br&gt;
해당 함수 구현은 &amp;#x3C;linux/sched.h&gt; 참고 &lt;/p&gt;
&lt;h2&gt;프로세스 컨텍스트&lt;/h2&gt;
&lt;p&gt;프로세스의 중요한 부분 중 하나는 실행 중인 프로그램 코드&lt;br&gt;
실행 파일에서 이 코드를 읽어 들이고, 프로그램 주소 공간에서 코드 실행함&lt;br&gt;
일반적인 프로그램은 사용자 공간에서 실행됨&lt;br&gt;
프로그램이 시스템 호출을 사용하거나 예외 처리 발생 시, 프로그램은 커널 공간으로 진입함&lt;br&gt;
이런 상황을 커널이 &apos;프로세스를 대신해 실행 중&apos; 또는 &apos;커널이 프로세스 컨텍스트에 있음&apos;이라고 함&lt;br&gt;
프로세스 컨텍스트에 있을 때 current 매크로 사용 가능&lt;br&gt;
그 사이에 우선순위가 높은 프로세스가 실행 가능한 상태가 되어 스케줄러가 그 프로세스 먼저 실행하지 않으면, 커널이 작업 끝내면 프로세스는 사용자 공간에서 실행 계속함  &lt;/p&gt;
&lt;p&gt;시스템 호출과 예외 처리기는 잘 정의된 커널 진입 인터페이스임&lt;br&gt;
프로세스는 이 두 가지 인터페이스 중 하나를 통해 커널 공간에 들어갈 수 있음&lt;br&gt;
즉, 커널에 대한 접근은 이 두 인터페이스를 통해야만 함&lt;/p&gt;
&lt;h2&gt;프로세스 계층 트리&lt;/h2&gt;
&lt;p&gt;유닉스 시스템처럼 리눅스도 프로세스 간 독특한 계층 구조 존재&lt;br&gt;
모든 프로세스는 PID가 1인 init 프로세스의 자손임&lt;br&gt;
init 프로세스는 부트 과정의 최종 단계에서 커널이 실행하는 프로세스임&lt;br&gt;
그 다음 init 프로세스는 시스템의 초기화 스크립트를 읽어 더 많은 프로그램 실행시켜 부트 과정 완료함  &lt;/p&gt;
&lt;p&gt;시스템의 모든 프로세스는 정확히 하나의 부모 프로세스를 가짐&lt;br&gt;
또한 모든 프로세스는 하나 이상의 자식 프로세스를 가질 수 있음&lt;br&gt;
같은 부모 프로세스를 가지는 자식 프로세스를 형제 프로세스&lt;strong&gt;sibling&lt;/strong&gt;라고 부름&lt;br&gt;
프로세스간의 관계는 프로세스 서술자에 저장됨&lt;br&gt;
각 task_struct 구조체에는 부모의 task_struct를 가리키는 parent라는 포인터와 자식의 task_struct 리스트를 가리키는 children 포인터가 들어 있음  &lt;/p&gt;
&lt;p&gt;현재 프로세스에 대해 다음과 같은 코드를 이용 시 부모 프로세스의 프로세스 서술자 얻기 가능 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;my_parent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;parent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;다음과 같은 코드로 프로세스의 모든 자식 프로세스에 접근 가능&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;list&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;list_for_each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;list&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;current&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	task &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;list&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; sibling&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;// 이제 task는 현재 프로세스의 자식 프로세스 중 하나를 가리킴 &lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;init 태스크의 프로세스 서술자는 init_task라는 이름으로 정적으로 할당됨  &lt;/p&gt;
&lt;p&gt;다음 코드는 모든 프로세스 사이의 관계를 보여줌&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;task &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; task &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;init_task&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; task &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;parent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// task가 init을 가리킬 때까지 반복&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;프로세스 계층 구조 이용 시 시스템의 어떤 프로세스에서도 다른 특정 프로세스 찾아갈 수 있음&lt;br&gt;
시스템의 모든 프로세스를 훑고 싶을 때에는 작업(태스크) 리스트가 환형 양방향 리스트이므로 매우 쉽게 작업 가능  &lt;/p&gt;
&lt;p&gt;어떤 태스크가 주어졌을 때 리스트에서 다음 태스크를 얻기 위해서는 다음 코드를 실행하면 됨&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;tasks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; tasks&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이전 태스크를 얻기 위해서는 다음 코드 실행&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;tasks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prev&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; tasks&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;위 두 가지 루틴은 next_task(task)와 prev_task(task)라는 매크로로 제공됨  &lt;/p&gt;
&lt;p&gt;전체 태스크 열거하는 for_each_process(task) 매크로(반복 단계마다 task 포인터는 리스트의 다음 태스크 가리킴)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;for_each_process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;task&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;// 매크로의 각 반복마다 각 태스크의 이름과 PID 출력됨&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;%s[%d]\n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;comm&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; task&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;pid&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;모든 태스크 열거하는 일은 매우 부하가 큰 작업임&lt;/p&gt;
&lt;h1&gt;프로세스 생성&lt;/h1&gt;
&lt;p&gt;대부분 OS는 스폰&lt;strong&gt;spawn&lt;/strong&gt; 방식으로 새로운 주소 공간에 새 프로세스 만들고, 실행 파일 읽은 후 그 코드를 실행하여 프로세스 생성  &lt;/p&gt;
&lt;p&gt;유닉스는 독특하게 이 과정을 fork()와 exec()이라는 두 함수로 분리  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여기서 exec() 함수는 exec() 함수 군을 일컬음. 커널은 execve() 시스템 호출을 바탕으로 execlp(), execle(), execv(), execvp() 함수를 구현함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;p&gt;먼저 fork()는 현재 태스크를 복제해 자식 프로세스를 만듦&lt;br&gt;
이렇게 만들어진 프로세스는 (고유값을 갖는)PID와 (부모 프로세스 PID인)PPID, 상속되지 않는 지연된 시그널과 같은 일부 자원과 통계 수치 제외하고는 부모와 같은 값을 가짐&lt;br&gt;
다음 함수인 exec()은 새로운 실행파일을 주소 공간에 불러오고 이를 실행&lt;br&gt;
fork() 다음에 exec()을 실행하는 조합은 대부분 OS에서는 하나의 함수로 제공&lt;/p&gt;
&lt;h2&gt;Copy-on-Write&lt;/h2&gt;
&lt;p&gt;전통적인 fork()는 부모 프로세스의 모든 자원 복사해 자식 프로세스에게 넘겨줌&lt;br&gt;
이런 방식은 공규 가능한 많은 데이터를 복사하므로 단순하고 비효율적&lt;br&gt;
게다가 새로 만든 프로세스가 바로 다른 프로그램 실행하는 경우 복사 작업이 모두 헛수고가 됨&lt;br&gt;
리눅스에서는 &apos;copy-on-write(기록사항 발생 시 복사)&apos; 페이지를 이용해 fork() 함수 구현했음&lt;br&gt;
기록사항 발생 시 복사&lt;strong&gt;COW&lt;/strong&gt;, &lt;strong&gt;Copy-on-Write&lt;/strong&gt; 기능은 데이터 복사를 지연 또는 방지하는 기능임&lt;br&gt;
프로세스 주소 공간을 복사하는 대신 부모와 자식 프로세스가 같은 공간 공유함  &lt;/p&gt;
&lt;p&gt;그러나 기록사항 발생해 데이터 변경 필요 시 그 순간 사본을 만들어 각 프로세스가 별도의 내용 가지게 됨&lt;br&gt;
따라서 리소스 복사는 해당 리소스에 대한 기록이 발생하는 경우에만 일어남&lt;br&gt;
그때까지는 읽기전용 상태로 공유 가능&lt;br&gt;
이 기법은 주소 공간에 실제 기록 작업 일어날 때까지 각 페이지의 복사 작업을 지연시킴&lt;br&gt;
프로세스가 절대 기록을 하지 않는 경우, e.g. fork() 직후에 exec() 함수가 호출되는 경우에는 복사가 필요 없어짐  &lt;/p&gt;
&lt;p&gt;fork() 함수가 해야 할 일은 프로세스의 페이지 테이블을 복사하는 것, 자식 프로세스용 프로세스 서술자를 만들어 주는 것뿐임&lt;br&gt;
일반적으로 프로세스는 생성된 다음 다른 실행파일 실행하므로, 이 같은 최적화를 통해 많은 데이터 복사 낭비를 막음&lt;br&gt;
유닉스의 철학인 빠른 프로세스 실행에 부합  &lt;/p&gt;
&lt;h2&gt;프로세스 생성&lt;/h2&gt;
&lt;p&gt;리눅스는 clone() 시스템 호출 이용 fork() 구현&lt;br&gt;
clone() 시스템 호출은 다양한 플래그 사용해 부모와 자식 프로세스간 공유가 필요한 자원 지정&lt;br&gt;
fork(), vfork(), __clone() 라이브러리 함수는 각자 적절한 플래그 사용해 clone()을 호출함&lt;br&gt;
clone() 시스템 호출은 다시 do_fork() 함수를 호출  &lt;/p&gt;
&lt;p&gt;실제 프로세스 생성 작업은 kernel/fork.c에 정의된 do_fork() 함수에서 처리함&lt;br&gt;
이 함수는 copy_process() 함수 호출하고 프로세스 실행을 시작함&lt;br&gt;
copy_process() 함수가 하는 일은 다음과 같음  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dup_task_struct() 함수를 호출해 커널 스택 새로 만들고, 새 프로세스용 thread_info, task_struct 구조체 만듦. 새로 만들어진 데이터의 값은 현재 태스크와 동일함. 이 시점에 부모와 자식 프로세스의 프로세스 서술자는 같음.&lt;/li&gt;
&lt;li&gt;새로 만든 자식 프로세스로 인해 현재 사용자의 프로세스 개수 제한을 넘어가지 않는지 확인.&lt;/li&gt;
&lt;li&gt;이제 자식 프로세스를 부모와 구별해야 함. 프로세스 서술자의 다양한 항목의 값을 초기화함. 프로세스 서술자에서 부모 프로세스의 값을 물려받지 않는 항목은 주로 통계 정보. 대부분의 task_struct 항목 값은 바뀌지 않음. &lt;/li&gt;
&lt;li&gt;자식 프로세스의 상태를 TASK_UNINTERRUPTIBLE로 설정해 아직 실행되지 않게 함.&lt;/li&gt;
&lt;li&gt;copy_process()는 copy_flag() 함수를 호출해 task_struct 구조체의 flags 내용을 정리함. 작업이 관리자 권한을 가지고 있음을 뜻하는 PF_SUPERPRIV 플래그를 초기화함. 프로세스가 exec() 함수를 호출하지 않았음을 뜻하는 PF_FORKNOEXEC 플래그를 설정함.&lt;/li&gt;
&lt;li&gt;alloc_pid() 함수를 호출해 새로 만든 태스크에 새로운 PID 값을 할당함.&lt;/li&gt;
&lt;li&gt;clone() 함수에 전달된 플래그 값에 따라 copy_process()는 열린 파일 및 파일시스템 정보, 시그널 핸들러, 프로세스 주소 공간, 네임스페이스&lt;strong&gt;namespace&lt;/strong&gt; 등을 복제하거나 공유함. 보통 스레드 사이에서는 이런 자원을 공유하며, 그 외의 경우에는 개별적으로 사용하므로 이 단계에서 복제함.&lt;/li&gt;
&lt;li&gt;마지막으로 copy_process()는 나머지 정리 작업을 수행하고 호출한 쪽에 새로 만든 자식 프로세스의 포인터를 반환함.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;do_fork()로 반환되어 돌아오면 copy_process()가 성공한 경우에 새로 만든 자식 프로세스를 깨워서 실행함&lt;br&gt;
커널은 의도적으로 자식 프로세스를 먼저 실행함(제대로 동작 안 되는 경우 있음)&lt;br&gt;
일반적으로 자식 프로세스는 바로 exec() 함수 호출하므로, 부모 프로세스가 먼저 실행될 시 주소 공간에 쓰기 작업이 생겨 발생하는 COW 작업 막을 수 있음  &lt;/p&gt;
&lt;h2&gt;vfork()&lt;/h2&gt;
&lt;p&gt;vfork() 시스템 호출은 부모 프로세스의 페이지 테이블을 복사하지 않는다는 점만 빼면 fork()와 똑같이 동작함&lt;br&gt;
대신 자식 프로세스는 부모 프로세스의 주소 공간 속에서 별개의 스레드 형태로 실행되고, 부모 프로세스는 자식 프로세스가 exec()을 호출하거나 종료할 때까지 대기함&lt;br&gt;
자식 프로세스는 주소 공간의 내용을 바꿀 수 없음&lt;br&gt;
COW를 이용해 fork()를 구현할 수 없었던 옛날 3BSD 시절 상당히 좋은 최적화 기법이었음&lt;br&gt;
2.6 버전 기준 COW, 자식 프로세스 우선 실행 방식을 사용하기 때문에, vfork() 사용으로 얻을 수 있는 이점은 부모 프로세스의 페이지 테이블 복사 안 하는 것뿐임&lt;br&gt;
리눅스 페이지 테이블 항목에 대해서도 COW 기능 제공 시 이 장점도 사라짐&lt;br&gt;
vfork()의 작동 방식 상당히 까다로움(e.g. exec() 실패 시 대처 방법?)
이상적인 시스템이라면 vfork() 필요 없음으로 커널에서 꼭 이를 구현 안 해도 됨&lt;br&gt;
일반적인 fork() 이용해 vfork() 구현해도 문제 없음, 실제로 2.2 버전 커널까지 이 방식 사용  &lt;/p&gt;
&lt;p&gt;vfork() 시스템 호출은 clone() 시스템 호출에 특별한 플래그를 지정해 구현함  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;copy_process()에서 task_struct의 vfork_done 항목을 NULL로 설정함.&lt;/li&gt;
&lt;li&gt;특별한 플래그가 지정된 경우 do_fork()에서 vfork_done 포인터가 특정 주소를 가리키도록 함.&lt;/li&gt;
&lt;li&gt;부모 프로세스는 자식 프로세스를 우선 실행시킨 다음 반환하지 않고 자식 프로세스가 vfork_done 포인터 이용해 신호를 보낼 때까지 대기.&lt;/li&gt;
&lt;li&gt;태스크가 메모리 주소 공간을 반환할 때 호출되는 mm_release() 함수에서 vfork_done 포인터가 NULL인지 아닌지 확인함. NULL이 아니면 부모 프로세스에 신호 보냄. &lt;/li&gt;
&lt;li&gt;do_fork() 함수로 돌아가서 부모 프로세스 깨우고 반환함.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;계획대로 진행 시 자식 프로세스는 새 주소 공간에서 실행되고, 부모 프로세스는 원래 주소 공간에서 실행됨&lt;br&gt;
부담은 적지만 깔끔한 구현은 아님&lt;/p&gt;
&lt;h1&gt;리눅스의 스레드 구현&lt;/h1&gt;
&lt;p&gt;스레드는 널리 쓰이는 현대적 프로그래밍 기법&lt;br&gt;
스레드를 이용해 메모리 주소 공간을 공유하는 같은 프로그램 여러 개 동시에 실행 가능&lt;br&gt;
스레드는 사용 중인 파일 및 기타 자원을 공유함&lt;br&gt;
스레드를 통해 동시 프로그래밍&lt;strong&gt;concurrent programming&lt;/strong&gt;이 가능해지고, 다중 프로세서 시스템에서는 진정한 병렬처리를 구현 가능함 &lt;/p&gt;
&lt;p&gt;리눅스는 독특한 스레드 구현 방식 가짐&lt;br&gt;
리눅스 커널에는 별도의 스레드 개념 없음&lt;br&gt;
기본적인 프로세스로 모든 스레드를 구현  &lt;/p&gt;
&lt;p&gt;리눅스 커널은 스레드를 위한 별도의 자료구조, 특별한 스케줄링 기법 없음&lt;br&gt;
리눅스의 스레드는 특정 자원을 다른 프로세스와 공유하는 특별한 프로세스일 뿐&lt;br&gt;
각 스레드는 별도의 task_struct 구조체 가짐, 커널 입장에서 주소 공간과 같은 자원을 다른 프로세스와 공유하고 있는 정상적인 프로세스&lt;/p&gt;
&lt;p&gt;스레드에 대한 이런 접근 방식은 윈도우나 솔라리스처럼 커널에서 별도의 스레드(lightweigh process=경량 프로세스라 부르기도 함)를 지원하는 방식과 크게 다름&lt;br&gt;
경량 프로세스라는 이름이 시스템간 철학적 차이 보여줌&lt;br&gt;
리눅스 외 다른 OS에서 스레드는 무거운 프로세스에 비해 가볍고 빠륵 실행하는 기능을 제공하는 무언가&lt;br&gt;
리눅스에서는 다른 프로세스와 자원을 공유하는(이미 충분히 경량화된) 프로세스에 불과함&lt;br&gt;
e.g. 네 개의 스레드로 구성된 프로세스 경우&lt;br&gt;
리눅스 : 네 개의 프로세스에 각각 네 개의 프로세스 서술자, 프로세스간 일부 자원 공유&lt;br&gt;
다른 OS : 하나의 프로세스 서술자 안에 네 개의 스레드 가리키는 정보, 주소 공간이나 사용 중인 파일 등 공유 자원 정보는 서술자 내에 존재&lt;br&gt;
=&gt; 리눅스가 매우 명쾌한 구조  &lt;/p&gt;
&lt;h2&gt;스레드 생성&lt;/h2&gt;
&lt;p&gt;스레드는 정상적인 태스크와 마찬가지 방식으로 만들어짐&lt;br&gt;
다만, clone() 시스템 호출 시 특정 자원 공유하도록 플래그 지정해줌  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;CLONE_VM &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CLONE_FS &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CLONE_FILES &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CLONE_SIGHAND&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;위의 코드는 주소 공간, 파일시스템 자원, 파일 서술자, 시그널 핸들러 공유한다는 점 제외하면 정상적 fork() 시스템 호출과 결과가 같음&lt;br&gt;
즉, 새 태스크와 그 부모 프로세스는 흔히 말하는 스레드 관계가 됨  &lt;/p&gt;
&lt;p&gt;반면, 일반적인 fork()는 다음과 같은 방식으로 구현됨&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;SIGHAND&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;vfork()는 다음과 같이 구현됨&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;CLONE_VFORK &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CLONE_VM &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; SIGCHLD&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;clone()에 넘겨주는 플래그를 통해 새로운 프로세스의 동작을 정의&lt;br&gt;
부모 프로세스와 자식 프로세스간에 공유할 자원을 자세히 지어함&lt;br&gt;
clone에서 사용하는 플래그는 &amp;#x3C;linux/sched.h&gt;에 정의되어 있음 &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;clone()의 시스템 호출 플래그&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;플래그&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;의미&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_FILES&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스간 사용 중인 파일 공유&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_FS&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스간 파일시스템 정보를 공유&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_IDLETASK&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;PID를 0으로 설정(유휴 상태의 태스크에서만 사용)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_NEWNS&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스를 위한 새 네임스페이스 생성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_PARENT&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스가 부모 프로세스와 동일한 부모를 가지도록 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_PTRACE&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스에 대해서도 추적 기능을 활성화&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_SETTID&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TID(Thread ID)를 사용자 공간에도 기록&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_SETTLS&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스를 위한 새 TLS(스레드별 저장공간 thread-local storage)를 생성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_SIGHAND&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스간 시그널 핸들러 및 시그널 차단 사항을 공유&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_SYSVSEM&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스간 시스템 V SEM_UNDO 방식을 공유&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_THREAD&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스가 동일한 스레드군에 속하게 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_VFORK&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;vfork() 방식을 사용해 자식 프로세스가 깨울 때까지 부모 프로세스를 중지&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_UNTRACED&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;추적 프로세스가 자식 프로세스에 CLONE_PTRACE를 지정하지 못하게 함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_STOP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;프로세스를 TASK_STOPPED 상태에서 시작&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_CHILD_CLEARTID&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스의 TID를 초기화&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_CHILD_SETTID&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자식 프로세스의 TID를 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_PARENT_SETTID&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스의 TID를 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;CLONE_VM&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;부모 프로세스와 자식 프로세스간 주소 공간 공유&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;커널 스레드&lt;/h2&gt;
&lt;p&gt;커널도 일부 동작을 백그라운드에서 실행하는 것이 좋을 때가 있음&lt;br&gt;
커널 공간에서만 존재하는 표준 프로세스인 커널 스레드 이용해 이런 작업 가능&lt;br&gt;
커널 스레드와 정상 프로세스간 주요 차이점은 커널 스레드에는 주소 공간이 없다는 점(프로세스 주소 공간 가리키는 mm 포인터가 NULL임)&lt;br&gt;
커널 스레드는 커널 공간에서만 동작하며 사용자 공간으로 컨텍스트 전환 안 일어남&lt;br&gt;
하지만 정상 프로세스와 마찬가지로 커널 스레드도 스케줄링되며 선점 가능  &lt;/p&gt;
&lt;p&gt;리눅스는 일부 작업을 커널 스레드를 통해 처리함&lt;br&gt;
대표적으로 &lt;strong&gt;flush&lt;/strong&gt; 및 &lt;strong&gt;ksoftirqd&lt;/strong&gt; 작업이 있음&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;ps -ef&lt;/code&gt; 명령 이용하면 리눅스 시스템의 커널 스레드 확인 가능&lt;br&gt;
커널 스레드는 매우 많음&lt;br&gt;
커널 스레드는 시스템 부팅 시 다른 커널 스레드에 의해 만들어짐&lt;br&gt;
커널 스레드는 다른 커널 스레드를 통해서만 만들 수 있음&lt;br&gt;
리눅스는 &lt;strong&gt;kthreadd&lt;/strong&gt; 커널 프로세스가 모든 커널 스레드를 만드는 방식으로 커널 스레드 관리함  &lt;/p&gt;
&lt;p&gt;새 커널 스레드 만들려면 &amp;#x3C;linux/kthread.h&gt;에 정의된 다음 인터페이스 사용&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;kthread_create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;threadfn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; namefmt&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;kthread 커널 프로세스는 clone() 시스템 호출을 이용해 새 태스크를 만듦&lt;br&gt;
새로 만들어진 프로세스는 data 매개변수를 통해 전달된 threadfn 함수를 실행함&lt;br&gt;
새 프로세스는 printf 스타일로 여러 개의 매개 변수로 형식화한 namefmt 문자열에 해당하는 이름 가짐&lt;br&gt;
처음 프로세스는 실행할 수 없는 상태로 만들어짐&lt;br&gt;
wake_up_process() 함수를 통해 명시적으로 깨워주지 않으면 실행되지 않음&lt;br&gt;
kthread_run() 함수를 이용하면 실행 가능한 프로세스를 바로 만들 수 있음  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;kthread_run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;threadfn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; namefmt&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;이 함수는 매크로로 구현되었고, kthread_create()와 wake_up_process()를 호출하는 단순한 함수  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token macro property&quot;&gt;#&lt;span class=&quot;token directive keyword&quot;&gt;define&lt;/span&gt; kthread_run(threadfn, data, namefmt, ...)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;k&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	k &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;kthread_create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;threadfn&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; namefmt&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ## __VA_ARGS__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;IS_ERR&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;k&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;wake_up_process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;k&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	k&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;커널 스레드는 한번 시작되면 스스로 do_exit() 함수를 호출하거나, 커널의 다른 부분에서 kthread_create()가 반환한 task_struct 구조체의 주소와 함께 kthread_stop() 함수를 호출할 때까지 계속 실행됨  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;kthread_stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;k&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;h1&gt;프로세스 종료&lt;/h1&gt;
&lt;p&gt;프로세스가 종료되면 커널은 프로세스가 가지고 있던 자원 반납 후 부모 프로세스에 자식 프로세스의 종료를 알려줌  &lt;/p&gt;
&lt;p&gt;일반적으로 프로세스 종료는 자발적 발생&lt;br&gt;
프로세스가 준비됬을 때 명시적으로 exit() 함수를 호출하거나, 프로그램의 main 함수 반환 시에 묵시적으로 exit() 함수가 호출되면서(즉 main 함수를 반환하는 곳에 C 컴파일러가 exit() 함수를 호출하는 코드를 삽입) 종료 작업이 시작됨&lt;br&gt;
물론 프로세스가 비자발적으로 종료되기도 함&lt;br&gt;
위에 경우는 프로세스가 처리할 수도 무시할 수도 없는 시그널이나 예외를 만나는 경우가 해당&lt;br&gt;
어떤 방식으로 프로세스가 종료되든 프로세스를 종료하는 일련의 작업이 kernel/exit.c에 정의된 do_exit() 함수를 통해 진행됨  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;task_struct 구조체의 flags 항목에 PF_EXITING 플래그를 설정함. &lt;/li&gt;
&lt;li&gt;del_timer_sync() 함수를 호출해 커널 타이머를 제거함. 이 함수가 반환되면, 대기 중인 타이머와 실행 중인 타이머가 없다는 것 보장됨.  &lt;/li&gt;
&lt;li&gt;BSD 방식의 프로세스 정보 기록 기능 사용 시 do_exit() 함수는 acct_update_integrals() 함수를 호출해 관련 정보 기록함. &lt;/li&gt;
&lt;li&gt;exit_mm() 함수를 호출해 해당 프로세스가 가지고 있는 mm_struct를 반환함. 다른 프로세스에서 이 주소 공간 사용하지 않으면(이 주소 공간 공유되어 있지 않으면) 커널은 해당 자원 해제함.&lt;/li&gt;
&lt;li&gt;exit_sem() 함수를 호출함. 프로세스가 IPC 세마포어를 얻기 위해 대기하고 있었다면, 이 시점에 대기 상태가 해제됨. &lt;/li&gt;
&lt;li&gt;exit_files() 및 exit_fs() 함수를 호출해 관련 파일 서술자 및 파일시스템의 참조 횟수를 줄임. 참조 횟수가 0이 되면 해당 객체를 사용하는 프로세스가 없다는 뜻이므로 해당 자원을 반환함.&lt;/li&gt;
&lt;li&gt;태스크의 종료 코드를 task_struct의 exit_code 항목에 저장함. exit() 함수에서 지정한 값, 또는 커널의 종료 방식에 의해 종료 코드 값이 결정된다. 이 곳에 저장된 종료 코드 값은 부모 프로세스가 사용할 수 없음.&lt;/li&gt;
&lt;li&gt;exit_notify() 함수를 호출해 부모 프로세스에 시그널 보내고, 해당 프로세스가 속한 스레드군의 다른 스레드 또는 init 프로세스를 자식 프로세스의 새로운 부모로 설정함. task_struct 구조체의 exit_state 항목에 태스크 종료 상태를 EXIT_ZOMBIE로 설정함. &lt;/li&gt;
&lt;li&gt;do_exit() 함수는 schedule() 함수를 호출해 새로운 프로세스로 전환함. 이제 이 프로세스는 스케줄링 대상이 아니므로 이 코드가 종료되는 태스크가 실행하는 마지막 코드가 됨. do_exit() 함수는 반환 과정이 없음.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 시점에서 태스크와 관련된 모든 객체가 반환됨(이 태스크만 해당 자원 사용 시)&lt;br&gt;
이 태스크는 더 이상 실행 가능하지 않고(실행할 주소 공간도 없어짐), EXIT_ZOMBIE 상태가 됨&lt;br&gt;
종료된 태스크가 차지하고 있는 메모리는 커널 스택, thread_info 구조체, task_struct 구조체가 전부다&lt;br&gt;
이제 태스크는 부모 프로세스에 전달이 필요한 정보를 보관하기 위해서만 존재함&lt;br&gt;
부모 프로세스가 해당 정보를 처리하거나 커널이 정보가 더 이상 필요 없다고 알려주면 프로세스가 차지하고 있던 나머지 메모리도 차지하고 있던 나머지 메모리도 반환돼 시스템의 가용 메모리로 돌아감&lt;/p&gt;
&lt;h2&gt;프로세스 서술자 제거&lt;/h2&gt;
&lt;p&gt;do_exit() 함수가 완료되고 프로세스가 좀비 상태가 되어 더 이상 실행 가능하지 않더라도 프로세스 서술자는 여전히 남음&lt;br&gt;
이는 종료 후에도 시스템이 자식 프로세스의 정보를 얻을 수 있게 해주기 위함&lt;br&gt;
결국 프로세스 종료를 위한 정리작업과 프로세스 서술자 제거 작업은 분리된 별도의 작업&lt;br&gt;
부모 프로세스가 종료된 자식 프로세스의 정보를 처리하거나 커널이 해당 정보가 필요 없다고 알려주면, 자식 프로세스의 task_struct 구조체에 할당된 메모리가 해제됨  &lt;/p&gt;
&lt;p&gt;wait() 계열 함수는 하나의 복잡한 wait4() 시스템 호출을 통해 구현되어 있음&lt;br&gt;
기본적인 동작은 함수를 호출한 프로세스의 동작을 자식 프로세스가 종료될 때까지 정지시키는 것, 종료된 자식 프로세스의 PID 값을 반환값으로 가짐&lt;br&gt;
또한 종료된 자식 프로세스의 종료 코드를 저장할 포인터도 제공함  &lt;/p&gt;
&lt;p&gt;프로세스 서술자에 할당된 메모리를 제거해야 할 때가 되면 release_task() 함수를 호출해 다음 작업을 수행함&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;__exit_signal() 함수를 호출하고, 이 함수는 __unhash_process() 함수를 호출하며, 이어서 detach_pid() 함수에서 해당 프로세스를 &lt;strong&gt;pidhash&lt;/strong&gt;와 태스크 리스트에서 제거함.&lt;/li&gt;
&lt;li&gt;__exit_signal() 함수는 종료된 프로세스가 사용하던 남은 자원 반환하고, 통계값과 기타 정보를 기록함.&lt;/li&gt;
&lt;li&gt;해당 태스크가 스레드군의 마지막 스레드였다면 대표 스레드가 좀비가 된 것이므로, release_task() 함수는 대표 스레드의 부모 프로세스에 이 사실을 알림  &lt;/li&gt;
&lt;li&gt;release_task() 함수는 put_task_struct() 함수를 호출해 프로세스의 커널 스택 및 thread_info 구조체가 들어 있던 페이지를 반환하고, task_struct 구조체가 들어 있던 슬랩 캐시를 반환함&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 시점에서 프로세스 서술자와 해당 프로세스와 연관된 모든 자원이 해제됨 &lt;/p&gt;
&lt;h2&gt;부모 없는 태스크의 딜레마&lt;/h2&gt;
&lt;p&gt;부모 프로세스가 자식 프로세스보다 먼저 종료된 경우 다른 프로세스를 자식 프로세스의 부모로 지정하는 수단 반드시 필요함&lt;br&gt;
그렇지 않으면, 부모를 잃고 종료된 프로세스는 영원히 좀비 프로세스로 남아 시스템 메모리 낭비하게 됨&lt;br&gt;
해결책은 해당 프로세스가 속한 스레드군의 다른 프로세스를 부모 프로세스로 지정하거나, 이것이 불가능할 경우엔 init 프로세스를 부모 프로세스로 지정하는 것  &lt;/p&gt;
&lt;p&gt;do_exit() 함수는 exit_notify() 함수를 호출하고, 이 함수에서 forget_original_parent() 함수를 호출함, 여기서 find_new_reaper() 함수를 호출하는데, 이 곳에서 부모 프로세스 재지정이 처리됨  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;find_new_reaper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;pid_namespace&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;pid_ns &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;task_active_pid_ns&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;thread&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	thread &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; father&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;while_each_thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;father&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; thread&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;thread&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;flags &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; PF_EXITING&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pid_ns&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;child_reaper &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		pid_ns&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;child_reaper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; thread&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; thread&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pid_ns&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;child_reaper &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;write_unlock_irq&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tasklist_lock&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pid_ns &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;init_pid_ns&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;token function&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Attempted to kill init!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;token function&quot;&gt;zap_pid_ns_processes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pid_ns&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;write_lock_irq&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tasklist_lock&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;token comment&quot;&gt;// child_reaper 항목을 그대로 두거나 그냥 지워버릴 수 없음&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// children 포인터 내용 중에 EXIT_DEAD 상태인 태스크가&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// 들어있을 수 있으므로, forget_original_parent() 함수는&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// 이들을 어딘가로 옮겨야 함&lt;/span&gt;

		pid_ns&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;child_reaper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; init_pid_ns&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child_reaper&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; pid_ns&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;child_reaper&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;위의 코드는 해당 프로세스가 속한 스레드군의 다른 태스크를 찾아봄&lt;br&gt;
만약 스레드군에 다른 태스크가 없다면 init 프로세스를 찾아서 반환함&lt;br&gt;
위 코드로 새 부모를 찾았으니, 모든 자식 프로세스의 부모 프로세스를 reaper로 다시 지정해주는 작업 필요함&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;reaper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find_new_reaper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;list_for_each_entry_safe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;father&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; sibling&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;real_parent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reaper&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;parent &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;BUG_ON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptrace&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;parent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;real_parent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;reparent_thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; father&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;그 다음 ptrace_exit_finish() 함수를 호출해 추적 기능을 사용하는 자식 프로세스에 대해 마찬가지로 부모 프로세스를 다시 지정해줌&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;exit_ptrace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;tracer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;LIST_HEAD&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ptrace_dead&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token function&quot;&gt;write_lock_irq&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tasklist_lock&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;list_for_each_entry_safe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tracer&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptraced&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ptrace_entry&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;__ptrace_detach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tracer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;token function&quot;&gt;list_add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptrace_entry&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;ptrace_dead&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;write_unlock_irq&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tasklist_lock&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token function&quot;&gt;BUG_ON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;list_empty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;tracer&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptraced&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token function&quot;&gt;list_for_each_entry_safe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;ptrace_dead&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ptrace_entry&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;lsit_del_init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;ptrace_entry&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;release_task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;자식 프로세스 리스트와 추적 리스트 두 리스트가 만들어진 배경이 있음&lt;br&gt;
태스크가 추적 상태에 있는 경우, 해당 프로세스는 디버깅 프로세스를 부모 프로세스로 임시 변경함&lt;br&gt;
그러나 태스크의 원 부모 프로세스가 종료되면, 다른 형제 프로세스와 같이 새 부모 프로세스로 돌아갈 수 있어야 함&lt;br&gt;
이전 커널에서는 이런 조치가 필요한 자식 프로세스를 찾기 위해 시스템의 모든 프로세스 조사함&lt;br&gt;
이에 대한 해결책으로 나온 것이 추적 상태에 있는 자식 프로세스 리스트를 별도로 관리하는 간단한 방법&lt;br&gt;
이를 통해 자식 프로세스를 찾으려고 모든 프로세스 리스트를 뒤지던 작업을 상대적으로 작은 두 개의 프로세스 리스트를 탐색하는 작업으로 줄임  &lt;/p&gt;
&lt;p&gt;부모 프로세스를 재지정하면, 좀비 프로세스가 남아 있을 위험성 사라짐&lt;br&gt;
init 프로세스는 주기적으로 wait() 함수를 호출해 자신에게 할당된 좀비 프로세스를 정리함  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[리눅스 커널 (2) - 빌드와 설치, 주의사항]]></title><description><![CDATA[커널 소스 구하기 http://www.kernel.org https://github.com/torvalds/linux 커널 소스 설치 bzip2 형식 압축 해제    GNU zip 형식 압축 해제    커널 소스는 보통 /usr/src/linux…]]></description><link>https://kmkmi.github.io/리눅스 커널 (2) - 빌드와 설치, 주의사항/</link><guid isPermaLink="false">https://kmkmi.github.io/리눅스 커널 (2) - 빌드와 설치, 주의사항/</guid><pubDate>Thu, 14 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;커널 소스 구하기&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kernel.org&quot;&gt;http://www.kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux&quot;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;커널 소스 설치&lt;/h1&gt;
&lt;p&gt;bzip2 형식 압축 해제&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ tar xvjf linux-x.y.z.tar.bz2&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;GNU zip 형식 압축 해제&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ tar xvzf linux-x.y.z.tar.gz&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널 소스는 보통 /usr/src/linux에 설치된다. 여기 접근하려면 루트 권한 필요, 새 커널 설치 시에만 루트 권한 사용하여 접근하고 그때에도 이 디렉토리 내용은 건드리면 안된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;패치&lt;/h1&gt;
&lt;p&gt;점증적 패치를 적용하려면,&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ patch -p1 &amp;lt; ../patch-x.y.z&lt;/code&gt;  &lt;/p&gt;
&lt;h1&gt;커널 소스 트리&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;디렉토리&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;arch&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;특정 아키텍처와 관련된 소스&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;block&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;블록 입출력 계층&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;crypto&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;암호화 API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Documentation&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;커널 소스 문서&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;drivers&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;장치 드라이버&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;firmware&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;특정 드라이버를 사용할 때 필요한 장치 펌웨어&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;fs&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;가상 파일시스템 및 개별 파일시스템&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;include&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;커널 헤더 파일&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;init&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;커널 시작 및 초기화 관련 코드&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;ipc&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;프로세스 간 통신 관련 코드&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;kernel&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;스케줄러와 같은 핵심 커널 서브시스템&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;lib&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;유틸리티 루틴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;mm&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;메모리 관리 서브시스템 및 가상 메모리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;net&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;네트워크 서브시스템&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;samples&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;예제, 데모 코드&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;scripts&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;커널을 빌드하는 데 사용하는 스크립트&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;security&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;리눅스 보안 모듈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;sound&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;사운드 서브시스템&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;usr&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;초기 사용자 공간 코드 initramfs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;tools&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;리눅스 개발에 유용한 도구&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;virt&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;가상화 기반 구조&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;소스트리 최상위에 있는 파일 : COPYING 파일은 커널 저작권 파일, CREDITS 파일에는 커널 개발 기여 개발자 명단, MAINTAINERS 파일에는 커널 서브시스템과 드라이버를 관리하는 사람들 명단, Makefile은 커널의 기본 &lt;strong&gt;Makefile&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;커널 설정&lt;/h1&gt;
&lt;p&gt;커널 설정 옵션은 &lt;strong&gt;CONFIG&lt;/strong&gt;으로 시작하는 CONFIG_FEATURE과 같은 형태&lt;br&gt;
e.g.) CONFIG_SMP : SMP 지원 여부  &lt;/p&gt;
&lt;p&gt;두가지 혹은 세가지 설정 값(보통 드라이버의 경우 세 가지 선택이 가능)을 지님.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yes&lt;/strong&gt; or &lt;strong&gt;no&lt;/strong&gt; (or &lt;strong&gt;module&lt;/strong&gt;)  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module&lt;/strong&gt; 값을 가지는 경우 해당 기능은 모듈 형태(동적으로 로드할 수 있는 별도 오브젝트)로 컴파일된다.  &lt;/p&gt;
&lt;p&gt;설정 옵션은 문자열이나 숫자가 될 수도 있음&lt;br&gt;
이런 옵션은 빌드과정을 조절하는 데 사용하지 않음&lt;br&gt;
전처리 매크로를 통해 커널 소스가 참조하는 값을 지정하는 데 사용&lt;br&gt;
정적으로 배열 크기를 지정하는 옵션이 그러한 예  &lt;/p&gt;
&lt;p&gt;Ubuntu용으로 Canonical에서 제공하거나, Fedora용으로 Red Hat에서 제공하는 것과 같은 벤더 커널은 컴파일된 상태로 배포본에 들어 있다.
이런 커널에는 많이 사용하는 커널 기능이 모두 들어 있음.&lt;br&gt;
거의 모든 드라이버를 모듈 형태로 컴파일함.&lt;br&gt;
이렇게 하면, 모듈을 통해 다양한 하드웨어를 지원하는 기본 커널로 사용 가능&lt;br&gt;
스스로 커널을 컴파일하고, 어떤 모듈을 포함시킬 것인지 제외할 것인지 배워나가야 한다.&lt;/p&gt;
&lt;p&gt;커널은 설정을 조절하는 여러 가지 도구를 제공&lt;br&gt;
가장 간단한 도구로 텍스트 기반의 명령행 도구가 있다   &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make config&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;이 도구는 각 옵션을 하나씩 돌아가면서 대화식으로 사용자에게 yes, no, (세 가지 선택 가능 시) module 중에서 어떤 선택을 할지 물어본다.&lt;br&gt;
이는 시간이 아주 오래 걸리는 일이므로 시간당 급여를 받는 상황이 아니라면 ncurses 라이브러리 사용하는 그래픽 환경의 도구를 이용하는 편이 좋다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make menuconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;또는 gtk+ 기반의 그래픽 환경 도구를 이용할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make gconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이 두가지 도구는 다양한 설정 옵션을 &apos;프로세서 형식 및 기능&apos; 등의 항목으로 분류해 보여줌.&lt;br&gt;
각 분류항목을 오가면서 커널 옵션을 확인하고 값을 변경할 수 있다. &lt;/p&gt;
&lt;p&gt;다음 명령은 아키텍처에 맞는 기본 설정을 만들어 줌  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make defconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이렇게 만들어진 기본 값은 다소 임의적이기는 하지만(i386의 경우 리누스가 사용하는 설정 값이라는 소문 있음.)&lt;br&gt;
커널을 설정해본 적이 없는 경우에는 좋은 출발점이 될 수 있을 것이다.&lt;br&gt;
빨리 빌드해서 실행해보고 싶다면, 이 명령을 실행한 다음 하드웨어에 필요한 옵션이 설정되었는지 확인하자.  &lt;/p&gt;
&lt;p&gt;옵션 설정은 커널 소스 트리의 최상위에 있는 .config 파일에 저장된다. (대부분의 커널 개발자가 그렇듯이)&lt;br&gt;
이 파일을 직접 수정하는 편이 쉽게 느껴질 수 있음.&lt;br&gt;
이 파일에서 설정 옵션을 찾아 값을 변경하는 일이 그다지 어렵지 않기 때문&lt;br&gt;
설정파일을 직접 변경한 경우나, 기존의 설정 파일을 새 커널 트리에 사용하는 경우에는 다음 명령을 이용해 설정 확인 및 갱신 가능  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make oldconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;커널을 빌드하기 전에 항상 이 명령을 실행해야 한다.&lt;br&gt;
CONFIG_IKCONFIG_PROC 설정 옵션을 사용하면 전체 커널 설정 파일을 압축해서 /proc/config.gz 파일에 저장한다.&lt;br&gt;
이를 이용하면 새 커널을 빌드할 때 현재 사용하는 설정을 쉽게 복사 가능&lt;br&gt;
현재 커널이 이 옵션을 사용하고 있다면, 다음과 같은 방법으로 /proc에 있는 설정 파일을 이용해 새 커널을 빌드할 수 있다.  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ zcat /proc/config.gz &amp;gt; .config
$ make oldconfig&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;어떤 방식으로든 커널 설정을 마쳤다면, 다음 명령으로 간단하게 커널을 빌드할 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이전 버전 커널과는 달리 2.6에서는 의존성 정보 자동 관리됨. =&gt; 커널 빌드하기 전 make dep 명령 실행 필요 없음&lt;br&gt;
또한, bzImage와 같은 특정 빌드 형식을 지정하거나 모듈을 별도로 빌드하지 않아도 된다.&lt;br&gt;
Makefile이 기본적인 모든 것을 처리함&lt;/p&gt;
&lt;h1&gt;빌드 메시지 최소화&lt;/h1&gt;
&lt;p&gt;빌드 시 쏟아지는 메시지를 최소화하면서도 경고나 오류 메시지를 놓치지 않으려면 make의 출력을 리다이렉트한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make &amp;gt; ../detritus&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;빌드 과정의 출력 메시지를 보고 싶다면 저장된 파일을 보면 된다.&lt;br&gt;
하지만 경고와 오류 메시지는 표준 에러 장치로 출력되므로 대개 이 파일을 볼 일은 없다.&lt;br&gt;
대신 다음을 실행  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make &amp;gt; /dev/null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이렇게 하면 모든 불필효한 출력을 다시는 돌아오지 못하는 커다란 하수구인 /dev/null로 보낸다. &lt;/p&gt;
&lt;h1&gt;빌드 작업을 동시에 여러 개 실행&lt;/h1&gt;
&lt;p&gt;make 프로그램에는 빌드 과정을 여러 개의 병렬 작업으로 분리해 주는 기능이 있다.&lt;br&gt;
각각의 작업은 별도로 동시에 실행되므로 다중 프로세서 시스템에서는 빌드 속도를 크게 향상시킬 수 있다.&lt;br&gt;
커다란 소스를 빌드하는 경우에는 입출력 대기 시간(프로세스가 입출력 요청이 완료되기를 기다리는 시간)이 차지하는 비중이 높으므로 이 기능을 이용해 프로세스 이용도 높일 수 있음  &lt;/p&gt;
&lt;p&gt;Makefile의 의존성 정보가 잘못되어 있는 경우가 너무나 많아 기본적으로는 make는 하나의 작업만 생성한다.&lt;br&gt;
잘못된 의존성 정보하에서 여러 개의 작업을 생성하면 다른 작업에 영향을 미쳐 전체 빌드 과정에서 오류가 발생할 수 있기 때문
커널 Makefile의 의존성 정보는 정확하므로 여러 개의 작업을 생성해도 문제가 발생하지 않는다.&lt;br&gt;
다중 make 작업을 통해 커널을 빌드하려면 다음 명령을 이용  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make -jn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;여기서 n은 생성할 작업의 개수 의미&lt;br&gt;
일반적으로 프로세서 하나당 하나 또는 두 개의 작업을 생성하는 것이 적당&lt;br&gt;
예를 들어 16코어 장비라면 다음과 같이 실행 가능  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ make -j32 &amp;gt; /dev/null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;distcc 또는 ccache와 같은 도구 사용 시 커널 빌드 시간을 극적으로 줄일 수 있다. &lt;/p&gt;
&lt;h1&gt;새 커널 설치&lt;/h1&gt;
&lt;p&gt;커널을 빌드하고 나면 커널 설치해야 함&lt;br&gt;
설치 방법은 아키텍처 및 부트 로더에 따라 다르므로 커널 이미지를 어디에 복사하고, 해당 이미지로 부팅하려면 어떻게 해야 하는지 부트 로더 사용법 참고&lt;br&gt;
새 커널이 문제를 일으킬 수 있으므로 안전한 것으로 확인된 커널 한두 개를 사용할 수 있도록 해두는 것을 잊지 말 것&lt;br&gt;
예를 들어, grub을 사용하는 x86 시스템이라면 arch/i386/boot/bzImage 파일을 /boot 디렉토리 안에 vmlinuz-version 같은 이름으로 넣어두고, /boot/grub/grub.conf 파일을 수정해 새 커널을 위한 항목을 추가&lt;br&gt;
&lt;strong&gt;LILO&lt;/strong&gt;를 사용해 부팅하는 시스템이라면 /etc/lilo.conf 파일을 편집하고 lilo 명령을 실행한다.  &lt;/p&gt;
&lt;p&gt;모듈 설치는 자동화되어 있고, 아키텍처에 따른 차이가 없음&lt;br&gt;
루트 권한으로 다음 명령을 실행하기만 하면 된다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;% make modules_install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이렇게 하면 컴파일된 모듈들이 정해진 위치인 /lib/modules 디렉토리에 설치된다.&lt;br&gt;
빌드 과정에서 커널 소스 트리 최상위에 System.map 파일이 만들어진다.&lt;br&gt;
이 파일에는 각 커널 심볼의 시작 주소의 위치를 찾을 수 있는 테이블이 들어 있다.&lt;br&gt;
디버깅 시에 이 정보를 이용해 메모리 주소 값을 그에 해당하는 함수나 변수 이름으로 변환해서 보여줄 수 있음  &lt;/p&gt;
&lt;h1&gt;다른 성질의 야수&lt;/h1&gt;
&lt;p&gt;리눅스 커널은 일반적인 사용자 공간 애플리케이션과 다른 몇 가지 독특한 특징 존재&lt;br&gt;
이런 차이가 커널 개발 작업을 사용자 프로그램 개발 작업과 다르게 만듬  &lt;/p&gt;
&lt;p&gt;다른 규칙이 적용됨&lt;br&gt;
당연해 보이는 차이점도 있지만, 명확해 보이지 않는 차이점도 존재&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널은 C 라이브러리나 표준 C 헤더 파일을 사용할 수 없다. &lt;/li&gt;
&lt;li&gt;커널은 GNU C를 사용한다.&lt;/li&gt;
&lt;li&gt;커널에는 사용자 공간에서와 같은 메모리 보호 기능이 없다. &lt;/li&gt;
&lt;li&gt;커널은 부동소수점 연산을 쉽게 실행할 수 없다.&lt;/li&gt;
&lt;li&gt;커널은 프로세스당 고정된 작은 크기의 스택을 사용한다.&lt;/li&gt;
&lt;li&gt;커널은 비동기식 인터럽트를 지원하며, 선점형이며, 대칭형 다중 프로세싱을 지원하므로 커널 내에서는 동기화 및 동시성 문제가 매우 중요하다.  &lt;/li&gt;
&lt;li&gt;이식성이 중요하다. &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;lib와 표준 헤더 파일을 사용할 수 없음&lt;/h1&gt;
&lt;p&gt;사용자 공간 애플리케이션과 달리, 커널은 표준 C 라이브러리(또는 그 외의 라이브러리)와도 링크되지 않음&lt;br&gt;
주요한 이유는 속도와 크기 때문&lt;br&gt;
전체 C 라이브러리, 아니면 그 중요 일부분이라도 커널 입장에서는 너무 크고 비효율적&lt;br&gt;
대신 일반적인 libc 함수의 상당수는 커널 안에 구현되어 있으므로 안심해도 좋음&lt;br&gt;
예를 들어, 보통의 문자열 처리 함수는 lib/string.c에 들어 있음&lt;br&gt;
&amp;#x3C;linux/string.h&gt; 헤더 파일 추가 시 해당 함수 사용 가능 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여기서 헤더 파일은 커널 소스 트리 안에 있는 커널 헤더 파일 일컬음.&lt;br&gt;
커널 소스에서 외부 라이브러리를 사용할 수 없는 것과 마찬가지로 커널 소스는 외부 헤더 파일을 사용 불가&lt;br&gt;
기본 파일은 커널 소스 트리 최상위의  include/ 디렉토리에 있음.  예를 들어, &amp;#x3C;linux/inotify.h&gt;에 해당하는 파일은 커널 소스 트리의 include/linux/inotify.h에 있다.
아키텍처별 특정 헤더 파일은 커널 소스 트리의 arch/(아키텍처)/include/asm 디렉토리에 있음.&lt;br&gt;
e.g. x86 아키텍처 =&gt; arch/x86/include/asm 디렉토리에 있음&lt;br&gt;
이 곳의 헤더 파일을 사용하는 경우에는 &amp;#x3C;asm/ioctl.h&gt;처럼 asm/ 접두사만 사용하면 된다. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;빠진 함수 중 가장 익숙한 함수 printf()&lt;br&gt;
커널 코드는 printf()를 사용할 수 없는 대신 printk() 함수를 제공,&lt;br&gt;
이 함수는 아주 익숙한 printf 함수와 거의 같은 방식으로 작동&lt;br&gt;
printk 함수는 형식화한 문자열을 커널 로그 버퍼에 복사하며, 이 메시지는 보통 &lt;strong&gt;syslog&lt;/strong&gt; 프로그램이 처리&lt;br&gt;
사용법은 printf() 함수와 유사&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Hello wolrd! A string &apos;%s&apos; and an integer &apos;%d&apos;\n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; str&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;printf 함수와 printk 함수 사이의 주목할 만한 차이점 하나는 printk 함수에는 우선순위 플래그를 줄 수 있다는 점이다.&lt;br&gt;
이 플래그를 통해 syslogd(데몬 프로그램)가 커널 메시지를 어느 곳에 표시할지를 결정할 수 있다.&lt;br&gt;
이 기능을 사용하는 예를 들어보면 다음과 같다.  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token function&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;KERN_ERR &lt;span class=&quot;token string&quot;&gt;&quot;this is an error!\n&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;KERN_ERR과 출력 메시지 사이에 쉼표가 없는 점에 주의&lt;br&gt;
이는 의도된 표현 방식&lt;br&gt;
우선순위 플래그는 문자형으로 표시된 선처리 지시자로 컴파일 과정에서 출력 메시지와 합쳐진다.  &lt;/p&gt;
&lt;h1&gt;GNU C&lt;/h1&gt;
&lt;p&gt;리눅스 커널은 유닉스 커널과 마찬가지로 C로 프로그램 되어 있음.&lt;br&gt;
커널은 엄격한 ANSI C로 되어있지 않고, 대신 개발자들은 필요하다고 생각되는 곳에 &lt;strong&gt;gcc&lt;/strong&gt;GNU Compiler Collection (커널 및 리눅스 시스템에 있는 C로 작성된 다른 거의 모든 프로그램 컴파일 시 사용하는 C 컴파일러)가 제공하는 다양한 언어 확장 기능 사용  &lt;/p&gt;
&lt;p&gt;커널 개발자들은 C 언어의 ISO C99과 GNU C 확장 기능 모두 사용&lt;br&gt;
gcc의 기능을 충분히 지원하는 최근 버전의 Intel C 컴파일러로도 리눅스 커널을 컴파일할 수 있지만,&lt;br&gt;
이런 점들로 인해 리눅스 커널은 gcc 편향되 있음&lt;br&gt;
지원하는 가장 오래된 gcc 버전은 3.2이며, 4.4 이후 버전을 권장&lt;br&gt;
ISO C99는 C 언어의 공식적인 개정판으로 기존과 큰 차이 없으므로 다른 코드에서도 서서히 이용되는 추세&lt;br&gt;
표준 ANSI C에 비해 더 생소한 확장 기능은 GNU C가 제공하는 확장 기능들  &lt;/p&gt;
&lt;h2&gt;인라인 함수&lt;/h2&gt;
&lt;p&gt;C99와 GNU C 모두 인라인 함수를 지원&lt;br&gt;
인라인 함수는 이름으로 짐작할 수 있듯이 각 함수 호출이 일어나는 자리의 줄 안에 삽입되는 함수&lt;br&gt;
이 기능을 통해 함수 호출과 반환 시에 발생하는 부가 비용(레지스터를 저장, 복원 등)을 제거 가능&lt;br&gt;
컨파일러가 함수를 호출하는 코드와 호출되는 코드를 하나로 보고 최적화 가능해 더 정교한 최적화가 가능&lt;br&gt;
함수의 내용이 호출하는 자리에 복사되어 들어가기 때문에 코드의 크기가 커지며,&lt;br&gt;
이로 인해 메모리 사용량과 명령어 캐시 사용량이 늘어남&lt;br&gt;
커널 개발자들은 일부 실행시간이 중요한 함수에 대해 인라인 함수 사용  &lt;/p&gt;
&lt;p&gt;큰 함수를 인라인으로 만드는 일은 해당 함수가 특별히 자주 사용되거나 실행시간에 극히 민감한 경우가 아니라면 피하는 것 권장  &lt;/p&gt;
&lt;p&gt;인라인 함수는 함수 정의부분에 static과 inline 지시어를 사용해 선언  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;wolf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; tail_size&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;인라인 함수 정의는 함수를 사용하기 전에 해야 함. 그렇지 않으면 컴파일러가 함수를 인라인으로 만들 수 없음.&lt;br&gt;
인라인 함수를 헤더 파일에 두고 사용하는 것이 일반적.  인라인 함수는 static으로 지정했으므로 외부에서 사용 불가.&lt;br&gt;
인라인 함수가 한 파일에서만 사용된다면 해당 파일의 최상단에 둘 수 있음.  &lt;/p&gt;
&lt;p&gt;커널에서는 형&lt;strong&gt;type&lt;/strong&gt; 보호 및 가독성 등의 이유로 복잡한 매크로를 사용하는 것보다 인라인 함수를 사용하는 것을 선호  &lt;/p&gt;
&lt;h2&gt;인라인 어셈블리&lt;/h2&gt;
&lt;p&gt;gcc C 컴파일러는 일반적인 C 함수 안에 어셈블리 명령을 삽입하는 기능을 제공&lt;br&gt;
이 기능은 특정 시스템 아키텍처에서만 사용하는 커널 소스에서 사용  &lt;/p&gt;
&lt;p&gt;인라인 어셈블리 이용 시 asm() 컴파일러 지시자 사용&lt;br&gt;
e.g. x86 프로세서의 rdtsc 명령 실행해서 타임스탬프 레지스터(tsc) 내용 받아오는 코드&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; low&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; high&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;rdtsc&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;=a&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;low&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;=d&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;high&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* 이제 low와 high에는 각각 64비트 tsc의 하위 32비트, 상위 32비트의 값이 들어간다. */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;리눅스 커널은 C와 어셈블리를 혼합해서 작성되어 있는데, 어셈블리는 주로 하부 아키텍처와 관련되어 있거나 빠른 속도를 요하는 부분에서 사용&lt;br&gt;
대부분의 커널 코드는 C로 작성 되어 있음  &lt;/p&gt;
&lt;h2&gt;분기 구문 표시&lt;/h2&gt;
&lt;p&gt;gcc C 컴파일러는 분기 시에 어느 쪽이 발생할 가능성이 높은지를 이용해 분기 구문을 최적화하는 내장 지시자를 가지고 있음&lt;br&gt;
컴파일러는 이 지시자를 이용해 분기를 예측 가능&lt;br&gt;
커널은 이 지시자를 사용하기 쉽게 likely()와 unlikely()라는 매크로로 만들어 사용  &lt;/p&gt;
&lt;p&gt;다음과 같은 코드에서&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;다음과 같은 방식으로 이 분기가 거의 실행되지 않음을 표시 가능 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* error 값이 거의 항상 0일 것으로 생각 가능 */&lt;/span&gt;
⁭&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;반면, 항상 실행될 것 같은 경우&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;
      &lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* success 값은 거의 항상 0이 아닐 것으로 간주 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;likely&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;분기의 방향이 거의 대부분 알려진 한 방향으로만 일어나는 경우, 또는 다른 경우를 무시하고 한 가지 경우에 대해서만 최적화가 필요한 경우 이 지시자 사용&lt;br&gt;
매우 중요한 사항으로, 이 지시자 오용 시에 심각한 성능저하&lt;br&gt;
일반적으로는 앞에서 봤듯이 오류가 발생하는 상황에서 unlikely()와 likely()를 사용&lt;br&gt;
특별히 예외를 처리하기 위해 if 문을 사용하는 경우 많음,&lt;br&gt;
커널에서도 주로 unlikely() 지시자 사용  &lt;/p&gt;
&lt;h2&gt;메모리 보호 없음&lt;/h2&gt;
&lt;p&gt;사용자 공간 애플리케이션이 메모리 접근을 잘못하면, 커널은 오류를 탐지해 SIGSEGV 시그널을 보내고 프로세스 종료.&lt;br&gt;
하지만 커널이 메모리 접근을 잘못한 경우에는 이를 제어하기 어려움&lt;br&gt;
커널에서의 메모리 침범은 중대한 커널 오류인 oops를 발생시킴&lt;br&gt;
NULL 포인터 참조와 같이 잘못된 메모리 접근을 해서는 안 된다는 것은 당연하지만 커널에서 그 위험성이 훨씬 큼.&lt;/p&gt;
&lt;p&gt;또한 커널 메모리는 페이징 기능 사용 불가&lt;br&gt;
커널에서 사용하는 모든 메모리는 실제 물리적인 메모리에 해당&lt;br&gt;
나중에 커널에 새로운 기능을 추가해야 한다면 이 점 명심해야 함  &lt;/p&gt;
&lt;h2&gt;부동 소수점 쉽게 사용 불가&lt;/h2&gt;
&lt;p&gt;사용자 공간 애플리케이션이 부동 소수점 연산을 사용할 경우, 커널이 정수와 부동 소수점 연산 모드 전환 관리&lt;br&gt;
부동 소수점 연산 이용 시 커널이 해야 하는 일은 아키텍처에 따라 다르지만,&lt;br&gt;
보통 커널이 트랩을 받아 정수 연산에서 부동 소수점 연산 모드로 전환하는 방식으로 동작  &lt;/p&gt;
&lt;p&gt;사용자 공간과 달리 커널은 자신의 트랩을 받을 수 없어 깔끔한 부동 소수점 전환 기능 이용 불가&lt;br&gt;
커널 내에서 부동 소수점을 사용하려면 수동으로 부동 소수점 레지스터를 저장하고 복원하는 등 잡다한 일을 직접 해야 함.&lt;br&gt;
사용하지 말아야 함. 아주 드문 경우 제외, 커널에서 부동 소수점 연산 사용 안 함.&lt;/p&gt;
&lt;h2&gt;작은 고정 크기의 스택&lt;/h2&gt;
&lt;p&gt;사용자 공간에서는 스택에 커다란 구조체나 수 천 개 크기의 배열 등 많은 변수 정적 할당 가능&lt;br&gt;
사용자 공간에는 동적으로 확장 가능한 커다란 스택이 있기 때문에 가능&lt;br&gt;
DOS 같은 구식 OS 경우 사용자 공간에서도 고정 크기 스택 쓰기 때문에 문제 될 수는 있음  &lt;/p&gt;
&lt;p&gt;커널이 사용하는 스택은 크지도 않고, 동적으로 확장 불가&lt;br&gt;
커널 스택의 정확한 크기는 아키텍처에 따라 다름&lt;br&gt;
x86 아키텍처의 경우 : 컴파일 시에 4KB 또는 8KB로 정할 수 있음&lt;br&gt;
관습적으로 커널 스택은 두 페이지로 구성하므로, 이는 커널 스택의 크기가 32비트 아키텍처에서는 8KB, 64비트 아키텍처에서는 16KB로 고정 되 있으며, 바꿀 수 없음을 의미&lt;br&gt;
각 프로세스별로 각자의 스택이 할당됨  &lt;/p&gt;
&lt;h2&gt;동기화와 동시성&lt;/h2&gt;
&lt;p&gt;커널은 경쟁 상태&lt;strong&gt;race condition&lt;/strong&gt;에 놓이기 쉬움.&lt;br&gt;
단일 스레드의 사용자 공간 애플리케이션과 달리, 커널은 공유 자원에 대한 동시 접근 허용해야 하므로 경쟁 방지하기 위한 동기화 필요&lt;/p&gt;
&lt;p&gt;다음과 같은 경우 존재  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리눅스는 선점형 멀티태스킹 OS. 커널의 프로세스 스케줄러에 의해 프로세스의 실행 순서가 조정됨. 커널은 이 작업들 간의 동기화를 책임져야 함.&lt;/li&gt;
&lt;li&gt;리눅스는 대칭형 다중 프로세서(SMP) 지원. 따라서 적절한 보호 장치 없으면 동일한 자원에 하나 이상의 프로세스가 동시에 접근하는 커널 코드 실행할 수 있음. &lt;/li&gt;
&lt;li&gt;현재 실행하고 있는 코드와 상관없이 비동기식으로 인터럽트가 발생. 따라서 적절한 보호 장치 없을 시 자원 사용 도중 인터럽트가 발생하고 인터럽트 핸들러에서 같은 자원에 접근하는 상황 발생 가능.  &lt;/li&gt;
&lt;li&gt;리눅스 커널은 선점형. 따라서 적절한 보호 장치가 없을 시 같은 자원에 접근하는 다른 커널 코드가 실행 중인 커널 코드를 선점하는 일이 발생 가능. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;경쟁 상태 해결하는 전형적인 해법은 스핀락&lt;strong&gt;spinlock&lt;/strong&gt;이나 세마포어&lt;strong&gt;semaphore&lt;/strong&gt;를 이용하는 것.  &lt;/p&gt;
&lt;h2&gt;이식성의 중요성&lt;/h2&gt;
&lt;p&gt;사용자 공간 애플리케이션은 이식성이 그다지 중요하지 않을 수 있음&lt;br&gt;
리눅스는 이식성이 좋은 OS이며, 그 특성 유지해야 함.&lt;br&gt;
이는 아키텍처 독립적인 C 코드가 여러 다양한 시스템에서 컴파일되고 실행되어야 한다는 의미이며,&lt;br&gt;
커널 소스 트리에서 아키텍처 독립적인 코드는 특정 시스템에 의존적인 코드와 적절하게 분리되어 있어야 한다는 뜻.  &lt;/p&gt;
&lt;p&gt;엔디언 중립성, 64비트 지원, 워드 및 페이지 크기 지정 등 몇 가지만 설명해도 방대함.&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;커널에는 고유한 특징 존재&lt;br&gt;
커널은 자신만의 규칙을 사용하며 전체 시스템을 관리하는 만큼 분명 그에 따르는 위험도 큼&lt;br&gt;
하지만 리눅스 커널의 복잡도와 진입장벽은 여타 대규모 소프트웨어 프로젝트와 질적으로 크게 다르지 않음  &lt;/p&gt;
&lt;p&gt;리눅스 개발에 있어 가장 중요한 단계는 커널이 두려움의 존재가 아니라는 것을 깨닫는 것.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그 수식 표현 플러그인 Katex 적용법]]></title><description><![CDATA[Latex 문법으로 수식 표현을 간단하게 할 수 있는 플러그인으로 Katex, MathJax 두 가지가 있는데,   MathJax는 dependency도 많고 Katex가 렌더링이 체감될 정도로 빠르므로 Katex…]]></description><link>https://kmkmi.github.io/Gatsby 블로그 수식 표현 플러그인 Katex 적용법/</link><guid isPermaLink="false">https://kmkmi.github.io/Gatsby 블로그 수식 표현 플러그인 Katex 적용법/</guid><pubDate>Wed, 13 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Latex 문법으로 수식 표현을 간단하게 할 수 있는 플러그인으로 Katex, MathJax 두 가지가 있는데,  &lt;/p&gt;
&lt;p&gt;MathJax는 dependency도 많고 Katex가 렌더링이 체감될 정도로 빠르므로 Katex 플러그인으로 수식표기를 하기로 결정했다.&lt;/p&gt;
&lt;p&gt;Katex 플러그인을 Gatsby 블로그에 적용하기 위해서 우선,  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm install --save gatsby-remark-katex katex&lt;/code&gt;&lt;br&gt;
또는&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ yarn add gatsby-remark-katex katex&lt;/code&gt;&lt;br&gt;
을 통해 katex를 설치해준다.  &lt;/p&gt;
&lt;p&gt;Katex 플러그인을 사용하기 위해 &lt;strong&gt;gatsby-transformer-remark&lt;/strong&gt; 플러그인이 필요한데, 마크다운 설정이 미리 되어있다면 이미 설치되어있을 수 있다.  &lt;/p&gt;
&lt;h3&gt;gatsby-config.js&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// &lt;/span&gt;
  plugins&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      resolve&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;gatsby-transformer-remark&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      options&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        plugins&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
          
          &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            resolve&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;gatsby-remark-katex&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            options&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;token comment&quot;&gt;// Add any KaTeX options from https://github.com/KaTeX/KaTeX/blob/master/docs/options.md here&lt;/span&gt;
              strict&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;strong&gt;gatsby-transformer-remark&lt;/strong&gt; 안에 &lt;strong&gt;gatsby-remark-katex&lt;/strong&gt;이 들어가는 꼴로 작성해야 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-remark-katex&quot;&gt;공식문서&lt;/a&gt;에   &lt;/p&gt;
&lt;p&gt;Add Katex CSS to your template: Katex’s CSS file is required to render the formulas correctly.
Include the CSS file in your template (example):&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;require(`katex/dist/katex.min.css`)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;katex.min.css&lt;/strong&gt;를 참조할 수 있도록 조치하라고 되어있는데,  &lt;/p&gt;
&lt;p&gt;blog post를 띄우는 &lt;strong&gt;src/templates/(포스트 관련.js)&lt;/strong&gt; 파일 안에&lt;/p&gt;
&lt;p&gt;나의 경우에는 &lt;code class=&quot;language-text&quot;&gt;import &amp;#39;../../../node_modules/katex/dist/katex.min.css&amp;#39;;&lt;/code&gt;를 추가하여 해결하였다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이제 Katex가 적용된다.&lt;/p&gt;
&lt;p&gt;&apos;$&apos; 문자 하나 사이에 표현하는 inline,
두개 사이에 표현하는 block 방식으로 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$a^2 + b^2 = c^2$ 인라인&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a^2 + b^2 = c^2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.897438em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8141079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8141079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 인라인&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$$
a^2 + b^2 = c^2  
a^2 + b^2 = c^2  
a^2 + b^2 = c^2  
$$ 블록&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a^2 + b^2 = c^2   
a^2 + b^2 = c^2  
a^2 + b^2 = c^2  &lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.9474379999999999em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8641079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.9474379999999999em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8641079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.9474379999999999em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8641079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8641079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8641079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.113em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그 적용 도중 만난 에러]]></title><description><![CDATA[npm 설치를 위해 node.js 설치하는 과정에서  C:\Users\(계정이름)\AppData\Roaming\npm-cache\_libvips 의 libvips-8.7.4-win32-x64.tar.gz 파일이 누락됨. (libvips-8.8.…]]></description><link>https://kmkmi.github.io/Gatsby 블로그 적용 도중 만난 에러/</link><guid isPermaLink="false">https://kmkmi.github.io/Gatsby 블로그 적용 도중 만난 에러/</guid><pubDate>Sun, 10 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;npm 설치를 위해 node.js 설치하는 과정에서 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C:\Users\(계정이름)\AppData\Roaming\npm-cache\_libvips&lt;/strong&gt; 의&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libvips-8.7.4-win32-x64.tar.gz&lt;/strong&gt; 파일이 누락됨.&lt;br&gt;
(&lt;strong&gt;libvips-8.8.1-win32-x64.tar.gz&lt;/strong&gt;을 포함한 다른 버전도 동일.)&lt;/p&gt;
&lt;p&gt;네트워크 문제로 파일을 가져오는데에서 문제가 생긴 것으로 보임.&lt;/p&gt;
&lt;p&gt;github realese 페이지에서 직접 받아도 다운링크에 접속을 못하여&lt;/p&gt;
&lt;p&gt;구글링을 통해 libvips 압축파일을 정리해둔 링크를 찾아서 해결.  &lt;a href=&quot;http://18.176.30.221/list/libvips&quot;&gt;http://18.176.30.221/list/libvips&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이를 통해 npm install 명령 실행 도중 getaddrinfo EFNOTFOUND 오류가 나며&lt;/p&gt;
&lt;p&gt;링크에서 파일을 받지 못하는 경우 해결 할 수 있음. &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;node-gyp 설치가 필요하다면,&lt;/p&gt;
&lt;p&gt;네이티브 애드온 모듈 컴파일링을 하는 &lt;strong&gt;node-gyp&lt;/strong&gt;를 설치&lt;/p&gt;
&lt;p&gt;&apos;node-gyp&apos; is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm install -g node-gyp&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;node.js를 윈도우에 설치하고서 필수 요소(python2.7 등) 자동 설치를 위한 빌드 툴을 설치해야함.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ npm install --global --production windows-build-tools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이번 블로그 적용 중에는 이 것으로 해결이 안되고 아래와 같은 문제가 생김.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;node.js 설치 시 파이썬 등 필수 요소 자동설치를 해줘야하는데 &lt;/p&gt;
&lt;p&gt;실패하여 npm이 Python v2.7을 찾지 못하는 경우 &lt;/p&gt;
&lt;p&gt;기본경로인 &lt;strong&gt;C:\python27&lt;/strong&gt; 경로로 파이썬2.7을 설치해준다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;visual studio가 2019 버전이라 MSBuild.exe ENOENT 에러가 나는 경우, &lt;/p&gt;
&lt;p&gt;빌드를 위해 Visual C++ Build tools의 2015 또는 2017 버전이 필요한데&lt;/p&gt;
&lt;p&gt;따라서 설치해주면 해결된다. &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkId=691126&quot;&gt;Visual C++ Build tools 설치&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows 8.1 sdk만 설치해주면 되고,&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$ npm config set python python2.7&lt;/code&gt;&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;$ npm config set msvs_version 2015&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 컨픽을 설정해주면 에러 없이 빌드된다.&lt;/p&gt;
&lt;p&gt;이번 경우 npm install 시 이 에러 발생.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참고 : &lt;a href=&quot;https://github.com/nodejs/node-gyp/issues/1747&quot;&gt;https://github.com/nodejs/node-gyp/issues/1747&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;gt; gatsby develop

The above error occurred in the &amp;lt;StoreStateProvider&amp;gt; component:
    in StoreStateProvider
    in App&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;위의 오류가 발생하는 경우  &lt;/p&gt;
&lt;p&gt;yarn 설치 후   &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npm install --global yarn&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;gatsby의 새 버전 재설치를 yarn으로 해주면  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add gatsby&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;다시 &lt;code class=&quot;language-text&quot;&gt;gatsby develop&lt;/code&gt;가 정상 작동한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참고 : &lt;a href=&quot;https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201&quot;&gt;https://github.com/gatsbyjs/gatsby/issues/19325#issuecomment-550977201&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리눅스 커널 (1) - 리눅스 커널 입문]]></title><description><![CDATA[운영체제와 커널 운영체제 : 정의 힘듬, but…]]></description><link>https://kmkmi.github.io/리눅스 커널 (1) - 리눅스 커널 입문/</link><guid isPermaLink="false">https://kmkmi.github.io/리눅스 커널 (1) - 리눅스 커널 입문/</guid><pubDate>Fri, 08 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;운영체제와 커널&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;운영체제&lt;/strong&gt; : 정의 힘듬, but 기술적 관점 =&gt; 기본적인 사용과 관리 담당하는 시스템의 일부분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널, 장치 드라이버, 부트로더, 명령행 셸(동등 역할의 사용자 인터페이스 포함), 기본적인 파일 및 시스템 유틸리티 등  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;시스템&lt;/strong&gt; : 운영체제 + 그 위에서 동작하는 모든 애플리케이션 통틀음    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;커널&lt;/strong&gt; : (a.k.a 관리자supervisor, 코어core, 내부internals) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터럽트 핸들러, 스케줄러, 메모리 관리 시스템, 네트워크나 프로세스간 통신 처리하는 시스템 서비스 등     &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;커널 공간&lt;/strong&gt;kernel-space : 보호 메모리 공간 사용, 제약 없는 하드웨어 접근 등이 가능&lt;br&gt;
과&lt;br&gt;
&lt;strong&gt;사용자 공간&lt;/strong&gt;user-space :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 애플리케이션 실행됨/ 장비의 가용 자원 중 일부만 사용 가능 &lt;/li&gt;
&lt;li&gt;특정 시스템 함수 실행 가능, 하드웨어 직접 접근 및 커널이 할당한 영역 밖에 메모리 접근은 잘못된 동작  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;은 다른 (시스템)상태를 가짐     &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;커널 코드 실행 시 시스템은 커널 모드로 커널 공간에 있음&lt;br&gt;
일반적인 프로세스 처리 시 시스템은 사용자 모드로 사용자 공간에 있음  &lt;/p&gt;
&lt;p&gt;실행 애플리케이션은 시스템 호출을 통해 커널과 통신&lt;br&gt;
주로) 애플리케이션이 라이브러리 함수 호출 =&gt; 라이브러리가 시스템 호출 인터페이스 이용 커널이 애플리케이션을 대신해 필요한 작업 수행&lt;/p&gt;
&lt;p&gt;일부 라이브러리 호출은 시스템 호출에는 없는 여러 기능 제공하기도 함, 이 경우 커널 호출은 커다란 함수의 일부 한 단계가 됨     &lt;/p&gt;
&lt;p&gt;ex) printf() : 데이터 출력 형식 지정 or 버퍼링 기능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;화면에 데이터 출력하기 위해 write() 시스템 호출 이용하는 것은 이 함수의 일부분&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일부 라이브러리 호출은 커널 호출과 일대일 대응&lt;/p&gt;
&lt;p&gt;한편, strcpy() 같은 C 라이브러리 함수는 커널 호출을 직접 사용하지 않음     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션이 시스템 호출을 실행하는 것을 애플리케이션을 대신에 커널이 실행 중이라고 표현&lt;/li&gt;
&lt;li&gt;또는 (= 애플리케이션이 커널 공간에서 시스템 호출을 실행 중 = 커널이 프로세스 컨텍스트를 실행 중)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;애플리케이션이 시스템 호출을 통해 커널을 이용하는 방식이 애플리케이션의 작업 수행의 기초적인 방식     &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;커널은 시스템 하드웨어도 관리&lt;/strong&gt; : 인터럽트 개념&lt;br&gt;
&lt;strong&gt;인터럽트&lt;/strong&gt; : 종류는 숫자로 구분, 커널은 숫자로 인터럽트 처리, 응답할 인터럽트 핸들러 실행  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널이 동기화를 위해 새로운 인터럽트 블락 가능(모든 인터럽트 다 or 특정 인터럽트만)  &lt;/li&gt;
&lt;li&gt;리눅스 포함 대다수 운영체제 인터럽트 핸들러를 프로세스 컨텍스트에서 실행 안함  &lt;/li&gt;
&lt;li&gt;대신 프로세스와 분리되어 있는 별도의 인터럽트(전용) 컨텍스트에서 실행      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컨텍스트는 커널의 활동 범주 나타냄&lt;br&gt;
리눅스에서 프로세스는 세가지 중 한가지 일 하는 중&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 공간에서 프로세스의 사용자 코드를 실행&lt;/li&gt;
&lt;li&gt;커널 공간의 프로세스 컨텍스트에서 특정 프로세스를 대신해 코드를 실행&lt;/li&gt;
&lt;li&gt;커널 공간의 인터럽트 컨텍스트에서 프로세스와 상관없이 인터럽트를 처리
ex) 시스템 유휴상태 = 커널이 커널 모드의 프로세스 컨텍스트에서 idle 프로세스 실행     &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;리눅스 커널과 전통적인 유닉스 커널&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;리눅스는 유닉스와 유사, but 유닉스 아님&lt;/strong&gt; : 유닉스 API(POSIX가 제정한 유일한 유닉스 표준) 구현하고 있지만 소스 물려받지 않음     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리눅스에 &lt;strong&gt;MMU&lt;/strong&gt;메모리 관리 장치 필요, 특펼히 없는 버전은 아주 작은 임베디드 시스템용  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;유닉스 커널&lt;/strong&gt; : 모놀리딕monolithic의 정적 바이너리&lt;br&gt;
&lt;strong&gt;리눅스 커널&lt;/strong&gt; : 모놀리딕monolithic 커널이지만 마이크로 커널의 장점 수용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모듈화 설계, 커널 선점(커널이 자신을 선점), 커널 스레드 지원, 별도의 바이너리(커널 모듈)를 커널 이미지에 동적으로 로드&lt;/li&gt;
&lt;li&gt;모든 작업은 커널 모드에서 실행, 통신 방식으로 X메세지 전달, O직접 함수 호출     &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;리눅스 커널 기준 전통적인 유닉스 시스템의 주요 차이점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커널 모듈 동적 로딩, 모노리딕 형식이지만 필요에 따라 동적으로 커널 코드 로드, 제거&lt;/li&gt;
&lt;li&gt;대칭형 멀티프로세서SMP 지원&lt;/li&gt;
&lt;li&gt;선점형 : 커널 내부에서 실행 중인 작업도 선점 가능&lt;/li&gt;
&lt;li&gt;독특한 방식으로 스레드 지원 : 정상 프로세스와 스레드 구분 안함/ 커널 입장에서 동등, but 자원 공유하는 프로세스들이 스레드임&lt;/li&gt;
&lt;li&gt;디바이스 클래스, 핫플러그 이벤트, 사용자 공간 디바이스 파일시스템sysfs =&gt; 객체지향적인 장치 모델 지원     &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;리눅스 커널 버전&lt;/h1&gt;
&lt;p&gt;(주버전).(부버전).(개정판).(안정 버전 일련번호)&lt;br&gt;
부버전 짝수가 안정 커널&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Hellow World!]]></title><link>https://kmkmi.github.io/AAAHellow World!/</link><guid isPermaLink="false">https://kmkmi.github.io/AAAHellow World!/</guid><pubDate>Fri, 01 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;/h1&gt;</content:encoded></item></channel></rss>